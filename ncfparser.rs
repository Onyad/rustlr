//Parser generated by rustlr

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_assignments)]
extern crate rustlr;
use rustlr::{RuntimeParser,RProduction,Stateaction};

 /* (i32,i32) defaults to (0,0), used to form two-counter automaton. */

pub fn make_parser() -> RuntimeParser<bool,(i32,i32)>
{
 let mut parser1:RuntimeParser<bool,(i32,i32)> = RuntimeParser::new(9,9);
 let mut rule = RProduction::<bool,(i32,i32)>::new_skeleton("start");
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("S");
 rule.Ruleaction = |parser|{ parser.stack.pop();   let ok:bool=parser.stack.pop().unwrap().value;   let (an,bn)=parser.exstate; println!("counters at end: an {}, bn {}",an,bn); ok && bn==0 };
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("AB");
 rule.Ruleaction = |parser|{ parser.stack.pop();  parser.stack.pop();   let (an,bn)=parser.exstate; if an!=bn {parser.abort("different numbers of a's and b's");} an==bn };
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("A");
 rule.Ruleaction = |parser|{ parser.stack.pop();  parser.stack.pop();   parser.exstate.0+=1; true };
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("A");
 rule.Ruleaction = |parser|{  return bool::default();};
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("B");
 rule.Ruleaction = |parser|{ parser.stack.pop();  parser.stack.pop();   parser.exstate.1+=1; true };
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("B");
 rule.Ruleaction = |parser|{  return bool::default();};
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("C");
 rule.Ruleaction = |parser|{ parser.stack.pop();  parser.stack.pop();   parser.exstate.1-=1; true };
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("C");
 rule.Ruleaction = |parser|{  return bool::default();};
 parser1.Rules.push(rule);
 rule = RProduction::<bool,(i32,i32)>::new_skeleton("START");
 rule.Ruleaction = |parser|{ parser.stack.pop();   return bool::default();};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.RSM[0].insert("a",Stateaction::Reduce(3));
 parser1.RSM[0].insert("AB",Stateaction::Gotonext(2));
 parser1.RSM[0].insert("A",Stateaction::Gotonext(1));
 parser1.RSM[0].insert("S",Stateaction::Gotonext(3));
 parser1.RSM[0].insert("EOF",Stateaction::Reduce(3));
 parser1.RSM[0].insert("c",Stateaction::Reduce(3));
 parser1.RSM[0].insert("b",Stateaction::Reduce(3));
 parser1.RSM[1].insert("a",Stateaction::Shift(5));
 parser1.RSM[1].insert("c",Stateaction::Reduce(5));
 parser1.RSM[1].insert("EOF",Stateaction::Reduce(5));
 parser1.RSM[1].insert("b",Stateaction::Reduce(5));
 parser1.RSM[1].insert("B",Stateaction::Gotonext(4));
 parser1.RSM[2].insert("C",Stateaction::Gotonext(6));
 parser1.RSM[2].insert("EOF",Stateaction::Reduce(7));
 parser1.RSM[2].insert("c",Stateaction::Reduce(7));
 parser1.RSM[3].insert("EOF",Stateaction::Accept);
 parser1.RSM[4].insert("EOF",Stateaction::Reduce(1));
 parser1.RSM[4].insert("c",Stateaction::Reduce(1));
 parser1.RSM[4].insert("b",Stateaction::Shift(7));
 parser1.RSM[5].insert("a",Stateaction::Reduce(2));
 parser1.RSM[5].insert("EOF",Stateaction::Reduce(2));
 parser1.RSM[5].insert("c",Stateaction::Reduce(2));
 parser1.RSM[5].insert("b",Stateaction::Reduce(2));
 parser1.RSM[6].insert("c",Stateaction::Shift(8));
 parser1.RSM[6].insert("EOF",Stateaction::Reduce(0));
 parser1.RSM[7].insert("b",Stateaction::Reduce(4));
 parser1.RSM[7].insert("c",Stateaction::Reduce(4));
 parser1.RSM[7].insert("EOF",Stateaction::Reduce(4));
 parser1.RSM[8].insert("EOF",Stateaction::Reduce(6));
 parser1.RSM[8].insert("c",Stateaction::Reduce(6));
 return parser1;
} //make_parser

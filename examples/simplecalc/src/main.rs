//Parser generated by rustlr for grammar simplecalc
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
use std::rc::Rc;
use std::cell::RefCell;
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
mod simplecalc_ast; // !-lines are injected verbatim into the parser
fn main()  {
  let mut scanner1 = simplecalclexer::from_str("10+-2*4");
  let mut parser1 = make_parser();
  let parseresult = parse_with(&mut parser1, &mut scanner1);
  let ast =
    parseresult.
    unwrap_or_else(|x| {
       println!("Parsing errors encountered; results not guaranteed..");
       x
    });
  println!("\nAST: {:?}\n",&ast);
}//main
use rustlr::LBox;
use crate::simplecalc_ast::*;

static SYMBOLS:[&'static str;13] = ["_WILDCARD_TOKEN_","+","*","-","/","(",")","INT","E","T","F","START","EOF"];

static TABLE:[u64;94] = [21474902016,34359934977,42949935105,12885295104,38654836737,30065098752,281496451612672,281513631547393,281505041809408,281517926645761,281509336907777,281487862005760,562958543880192,562962838454274,562967133880320,562975723356162,562954248519682,563001493159938,844437815754752,844476469739523,844429225754624,1125917087039490,1125904202137602,1125912792072194,1125925676974082,1125908497104898,1125951446777858,1407392063881218,1407400653815810,1407379178979330,1407387768913922,1407426423619586,1407383473946626,1688879925362688,1688892810723329,1688862745559040,1688871335165952,1970329132597248,1970350607630336,1970337722597376,2251812698980352,2251842764275713,2251821288587264,2251829878784000,2533317741051905,2533287675691008,2533296265297920,2533304855494656,2814779832205312,2814788422860801,2814792717041665,2814762652401664,2814771242008576,3096246218719232,3096237629112320,3096254808915968,3096263399636993,3096267693752321,3377751260528642,3377712605822978,3377708310855682,3377716900790274,3377725490724866,3377704015888386,3659178992730114,3659187582664706,3659191877632002,3659200467566594,3659183287697410,3659226237370370,3940666854014978,3940701213753346,3940675443949570,3940658264080386,3940653969113090,3940662559047682,4222141830791170,4222150420725762,4222137535823874,4222176190529538,4222133240856578,4222128945889282,4503608217829376,4503651166978050,4503625397174274,4503616807829504,4503612512272386,4503603922337794,4785087489048578,4785100373950466,4785126143754242,4785091784540160,4785078899113986,4785083194540032,];


fn _semaction_rule_0_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_8(_x_8)=parser.popstack().value { _x_8 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()};  E::BinaryOp("+",parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_1_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_8(_x_8)=parser.popstack().value { _x_8 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()};  E::BinaryOp("-",parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_2_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()};  _item0_ }

fn _semaction_rule_3_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_8(_x_8)=parser.popstack().value { _x_8 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()};  E::BinaryOp("*",parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_4_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_8(_x_8)=parser.popstack().value { _x_8 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()};  E::BinaryOp("/",parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_5_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()};  _item0_ }

fn _semaction_rule_6_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_8(_x_8)=parser.popstack().value { _x_8 } else {<()>::default()};  E::Neg(parser.lbx(1,_item1_)) }

fn _semaction_rule_7_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item0_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<i32>::default()};  E::Val(_item0_) }

fn _semaction_rule_8_(parser:&mut ZCParser<RetTypeEnum,()>) -> E {
let mut _item2_ = if let RetTypeEnum::Enumvariant_8(_x_8)=parser.popstack().value { _x_8 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_8(_x_8)=parser.popstack().value { _x_8 } else {<()>::default()};  _item1_ }

fn _semaction_rule_9_(parser:&mut ZCParser<RetTypeEnum,()>) -> () {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<E>::default()}; <()>::default()}

pub fn make_parser() -> ZCParser<RetTypeEnum,()>
{
 let mut parser1:ZCParser<RetTypeEnum,()> = ZCParser::new(10,18);
 let mut rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("T");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("T");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("T");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("F");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("F");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("F");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_8(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";

 for i in 0..94 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'t>(parser:&mut ZCParser<RetTypeEnum,()>, lexer:&mut simplecalclexer<'t>) -> Result<E,E>
{
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<E>::default())}
}//parse_with public function

pub fn parse_train_with<'t>(parser:&mut ZCParser<RetTypeEnum,()>, lexer:&mut simplecalclexer<'t>, parserpath:&str) -> Result<E,E>
{
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<E>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum {
  Enumvariant_2((usize,usize)),
  Enumvariant_3(i32),
  Enumvariant_0(E),
  Enumvariant_8(()),
}
impl Default for RetTypeEnum { fn default()->Self {RetTypeEnum::Enumvariant_0(<E>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct simplecalclexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
   shared_state: Rc<RefCell<()>>,
}
impl<'t> simplecalclexer<'t> 
{
  pub fn from_str(s:&'t str) -> simplecalclexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> simplecalclexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> simplecalclexer<'t> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    let shared_state = Rc::new(RefCell::new(<()>::default()));
    for kw in ["_WILDCARD_TOKEN_",] {keywords.insert(kw);}
    for c in ['+','*','-','/','(',')',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [] {lexnames.insert(k,v);}
    simplecalclexer {stk,keywords,lexnames,shared_state,}
  }
}
impl<'t> Tokenizer<'t,RetTypeEnum> for simplecalclexer<'t>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'t,RetTypeEnum>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum>::default()))
      },
      RawToken::Num(_tt) => Some(TerminalToken::from_raw(token,"INT",RetTypeEnum::Enumvariant_3(_tt as i32))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum>::default())),
      _ => { let _rrodb=token.0.to_staticstr(); Some(TerminalToken::from_raw(token,_rrodb,<RetTypeEnum>::default())) },
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
   fn get_slice(&self,s:usize,l:usize) -> &str {self.stk.get_slice(s,l)}
   fn transform_wildcard(&self,t:TerminalToken<'t,RetTypeEnum>) -> TerminalToken<'t,RetTypeEnum> { TerminalToken::new(t.sym,RetTypeEnum::Enumvariant_2((self.stk.previous_position(),self.stk.current_position())),t.line,t.column) }
}//impl Tokenizer

fn load_extras(parser:&mut ZCParser<RetTypeEnum,()>)
{
}//end of load_extras: don't change this line as it affects augmentation

//Parser generated by rustlr for grammar prop
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use fixedstr::str4;
use rustlr::LBox;
use crate::prop_ast;
use crate::prop_ast::*;

static SYMBOLS:[&'static str;11] = ["_WILDCARD_TOKEN_","Prop","OR","AND","IMPLIES","NOT","(",")","Var","START","EOF"];

static TABLE:[u64;62] = [34359934976,4295032833,25769934848,21475098624,281517926383619,281492157038592,281483567038464,281487861940224,562984313356288,562954248912897,562971428519936,562975723356160,844433520066562,844467879804930,844437815033858,844454994903042,844442110001154,1125921381941248,1125904202399745,1125934266777600,1125925676777472,1407400653488128,1407379179175937,1407409243488256,1407396358651904,1688875630198784,1688871335362560,1688854155952129,1688884220198912,1970346312073216,1970329132728321,1970350606909440,1970359196909568,2251808404013056,2251816994013184,2251812698914816,2251829879308288,2533287675559938,2533304855429122,2533317740331010,2533283380592642,2533291970527234,2814779831943170,2814766947041282,2814758357106690,2814762652073986,2814792716845058,3096241923817474,3096233333882882,3096267693621250,3096254808719362,3096237629046784,3377712605757440,3377716900593666,3377729785495554,3377742670397442,3377708310855680,3659217647239170,3659183287500802,3659204762337282,3659191877435394,3659187582468098,];


fn _semaction_rule_0_(parser:&mut ZCParser<RetTypeEnum,()>) -> Prop {
let mut _item0_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<str4>::default()}; Prop::Var(_item0_) }

fn _semaction_rule_1_(parser:&mut ZCParser<RetTypeEnum,()>) -> Prop {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; Prop::And(parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_2_(parser:&mut ZCParser<RetTypeEnum,()>) -> Prop {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; Prop::Or(parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_3_(parser:&mut ZCParser<RetTypeEnum,()>) -> Prop {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; Prop::Implies(parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_4_(parser:&mut ZCParser<RetTypeEnum,()>) -> Prop {
let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<()>::default()}; Prop::Not(parser.lbx(1,_item1_)) }

fn _semaction_rule_5_(parser:&mut ZCParser<RetTypeEnum,()>) -> Prop {
let mut _item2_ = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<()>::default()}; let mut p = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<()>::default()};  p }

fn _semaction_rule_6_(parser:&mut ZCParser<RetTypeEnum,()>) -> Prop {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Prop>::default()}; <Prop>::default()}

pub fn make_parser() -> ZCParser<RetTypeEnum,()>
{
 let mut parser1:ZCParser<RetTypeEnum,()> = ZCParser::new(7,14);
 let mut rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("Prop");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("Prop");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("Prop");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("Prop");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("Prop");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("Prop");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum,()>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";

 for i in 0..62 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'t>(parser:&mut ZCParser<RetTypeEnum,()>, lexer:&mut proplexer<'t>) -> Result<Prop,Prop>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Prop>::default())}
}//parse_with public function

pub fn parse_train_with<'t>(parser:&mut ZCParser<RetTypeEnum,()>, lexer:&mut proplexer<'t>, parserpath:&str) -> Result<Prop,Prop>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Prop>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum {
  Enumvariant_0(Prop),
  Enumvariant_3(str4),
  Enumvariant_1(()),
}
impl Default for RetTypeEnum { fn default()->Self {RetTypeEnum::Enumvariant_0(<Prop>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct proplexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
}
impl<'t> proplexer<'t> 
{
  pub fn from_str(s:&'t str) -> proplexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> proplexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> proplexer<'t> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    for kw in ["_WILDCARD_TOKEN_",] {keywords.insert(kw);}
    for c in ['(',')','&','|','~',] {stk.add_single(c);}
    for d in ["->",] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [(r"&","AND"),(r"|","OR"),(r"~","NOT"),(r"->","IMPLIES"),] {lexnames.insert(k,v);}
    proplexer {stk,keywords,lexnames}
  }
}
impl<'t> Tokenizer<'t,RetTypeEnum> for proplexer<'t>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'t,RetTypeEnum>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum>::default()))
      },
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"Var",RetTypeEnum::Enumvariant_3(str4::from(x)))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<RetTypeEnum>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
}//impl Tokenizer

fn load_extras(parser:&mut ZCParser<RetTypeEnum,()>)
{
}//end of load_extras: don't change this line as it affects augmentation

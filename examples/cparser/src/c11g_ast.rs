//Abstract syntax types generated by rustlr for grammar c11g
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(dead_code)]
extern crate rustlr;
use rustlr::LBox;

#[derive(Debug)]
pub enum type_qualifier {
  RESTRICT,
  ATOMIC,
  CONST,
  VOLATILE,
  type_qualifier_Nothing,
}
impl Default for type_qualifier { fn default()->Self { type_qualifier::type_qualifier_Nothing } }

#[derive(Debug)]
pub enum declaration_specifier<'lt> {
  funcspec(function_specifier),
  storage(storage_class_specifier),
  alignspec(LBox<alignment_specifier<'lt>>),
  typequal(type_qualifier),
  typespec(LBox<type_specifier<'lt>>),
  declaration_specifier_Nothing,
}
impl<'lt> Default for declaration_specifier<'lt> { fn default()->Self { declaration_specifier::declaration_specifier_Nothing } }

#[derive(Default,Debug)]
pub struct translation_unit<'lt>(pub Vec<LBox<external_declaration<'lt>>>,);

#[derive(Debug)]
pub enum external_declaration<'lt> {
  directive(&'lt str),
  external_declaration_269(function_definition<'lt>),
  external_declaration_270(declaration<'lt>),
  external_declaration_Nothing,
}
impl<'lt> Default for external_declaration<'lt> { fn default()->Self { external_declaration::external_declaration_Nothing } }

#[derive(Default,Debug)]
pub struct pointer {
  pub tql:Vec<LBox<type_qualifier>>,
  pub ptr:Option<LBox<pointer>>,
}

#[derive(Debug)]
pub enum block_item<'lt> {
  Statement(LBox<statement<'lt>>),
  Declaration(declaration<'lt>),
  block_item_Nothing,
}
impl<'lt> Default for block_item<'lt> { fn default()->Self { block_item::block_item_Nothing } }

#[derive(Default,Debug)]
pub struct designation<'lt>(pub Vec<LBox<designator<'lt>>>,);

#[derive(Default,Debug)]
pub struct type_name<'lt>(pub Vec<LBox<specifier_qualifier<'lt>>>,pub Option<LBox<abstract_declarator<'lt>>>,);

#[derive(Default,Debug)]
pub struct init_declarator<'lt> {
  pub decl:declarator<'lt>,
  pub initializer:Option<LBox<initializer<'lt>>>,
}

#[derive(Debug)]
pub enum designator<'lt> {
  dotid(&'lt str),
  brackexpr(LBox<expression<'lt>>),
  designator_Nothing,
}
impl<'lt> Default for designator<'lt> { fn default()->Self { designator::designator_Nothing } }

#[derive(Default,Debug)]
pub struct parameter_type_list<'lt> {
  pub parameters:Vec<LBox<parameter_declaration<'lt>>>,
  pub ellipsis:Option<LBox<NEWSEQNT_204_1>>,
}

#[derive(Debug)]
pub enum Constant<'lt> {
  F_CONSTANT(f64),
  I_CONSTANT(i32),
  ENUMERATION_CONSTANT(&'lt str),
  Constant_Nothing,
}
impl<'lt> Default for Constant<'lt> { fn default()->Self { Constant::Constant_Nothing } }

#[derive(Debug)]
pub enum alignment_specifier<'lt> {
  ALIGNAS_170(LBox<expression<'lt>>),
  ALIGNAS_169(LBox<type_name<'lt>>),
  alignment_specifier_Nothing,
}
impl<'lt> Default for alignment_specifier<'lt> { fn default()->Self { alignment_specifier::alignment_specifier_Nothing } }

#[derive(Debug)]
pub enum declaration_specifiers {
  declaration_specifiers_Nothing,
}
impl Default for declaration_specifiers { fn default()->Self { declaration_specifiers::declaration_specifiers_Nothing } }

#[derive(Debug)]
pub enum struct_or_union_specifier<'lt> {
  struct_or_union_specifier_135(struct_or_union,Option<LBox<&'lt str>>,Vec<LBox<struct_declaration<'lt>>>),
  struct_or_union_specifier_136(struct_or_union,&'lt str),
  struct_or_union_specifier_Nothing,
}
impl<'lt> Default for struct_or_union_specifier<'lt> { fn default()->Self { struct_or_union_specifier::struct_or_union_specifier_Nothing } }

#[derive(Default,Debug)]
pub struct initializer_designation<'lt>(pub Option<LBox<designation<'lt>>>,pub LBox<initializer<'lt>>,);

#[derive(Debug)]
pub enum initializer<'lt> {
  values(Vec<LBox<initializer_designation<'lt>>>),
  expr(LBox<expression<'lt>>),
  initializer_Nothing,
}
impl<'lt> Default for initializer<'lt> { fn default()->Self { initializer::initializer_Nothing } }

#[derive(Debug)]
pub enum statement<'lt> {
  Goto_oh_no(&'lt str),
  Breakstat,
  Continuestat,
  Returnstat(Vec<LBox<expression<'lt>>>),
  Labelstat(&'lt str,LBox<statement<'lt>>),
  Defaultcase(LBox<statement<'lt>>),
  Casestat(expression<'lt>,LBox<statement<'lt>>),
  Dowhileloop(LBox<statement<'lt>>,expressions<'lt>),
  Whileloop(expressions<'lt>,LBox<statement<'lt>>),
  Forloop(LBox<statement<'lt>>,LBox<statement<'lt>>,Option<LBox<expressions<'lt>>>,LBox<statement<'lt>>),
  ForDecloop(declaration<'lt>,LBox<statement<'lt>>,Option<LBox<expressions<'lt>>>,LBox<statement<'lt>>),
  Blockstat(Vec<LBox<block_item<'lt>>>),
  Ifelse(expressions<'lt>,LBox<statement<'lt>>,LBox<statement<'lt>>),
  Ifstat(expressions<'lt>,LBox<statement<'lt>>),
  Switchstat(expressions<'lt>,LBox<statement<'lt>>),
  Expr_list(Option<LBox<expressions<'lt>>>),
  statement_Nothing,
}
impl<'lt> Default for statement<'lt> { fn default()->Self { statement::statement_Nothing } }

#[derive(Debug)]
pub enum function_specifier {
  INLINE,
  NORETURN,
  function_specifier_Nothing,
}
impl Default for function_specifier { fn default()->Self { function_specifier::function_specifier_Nothing } }

#[derive(Default,Debug)]
pub struct direct_declarator<'lt>(pub LBox<direct_contents<'lt>>,pub Vec<LBox<direct_contents<'lt>>>,);

#[derive(Default,Debug)]
pub struct generic_selection<'lt>(pub LBox<expression<'lt>>,pub Vec<LBox<generic_association<'lt>>>,);

#[derive(Debug)]
pub enum expression<'lt> {
  expression_91(Vec<LBox<expression<'lt>>>),
  expr_list(LBox<expressions<'lt>>),
  And(LBox<expression<'lt>>,LBox<expression<'lt>>),
  BitOr(LBox<expression<'lt>>,LBox<expression<'lt>>),
  BitAnd(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Equals(LBox<expression<'lt>>,LBox<expression<'lt>>),
  NotEquals(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Dotaccess(LBox<expression<'lt>>,&'lt str),
  Indexing(LBox<expression<'lt>>,LBox<expression<'lt>>),
  MinusMinus(LBox<expression<'lt>>),
  Function_call(LBox<expression<'lt>>,Vec<LBox<expression<'lt>>>),
  dont_know_what_this_is(LBox<type_name<'lt>>,Vec<LBox<initializer_designation<'lt>>>),
  PlusPlus(LBox<expression<'lt>>),
  Ptraccess(LBox<expression<'lt>>,&'lt str),
  Assignment(LBox<expression<'lt>>,assignment_operator,LBox<expression<'lt>>),
  Lshift(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Rshift(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Plus(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Minus(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Typecast(LBox<type_name<'lt>>,LBox<expression<'lt>>),
  Times(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Mod(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Divide(LBox<expression<'lt>>,LBox<expression<'lt>>),
  const_expr(LBox<expression<'lt>>),
  ALIGNOF_37(LBox<type_name<'lt>>),
  Unaryop(unary_operator,LBox<expression<'lt>>),
  SIZEOF_36(LBox<type_name<'lt>>),
  BitXor(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Generic(LBox<generic_selection<'lt>>),
  IDENTIFIER(&'lt str),
  Stringlit(Stringlit<'lt>),
  primary_expression_1(LBox<expression<'lt>>),
  Constant(Constant<'lt>),
  Gt(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Lt(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Leq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Geq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Quest(LBox<expression<'lt>>,LBox<expression<'lt>>,LBox<expression<'lt>>),
  Or(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_Nothing,
}
impl<'lt> Default for expression<'lt> { fn default()->Self { expression::expression_Nothing } }

#[derive(Debug)]
pub enum assignment_operator {
  OR_ASSIGN,
  SUB_ASSIGN,
  MOD_ASSIGN,
  DIV_ASSIGN,
  RIGHT_ASSIGN,
  ASSIGN,
  ADD_ASSIGN,
  LEFT_ASSIGN,
  MUL_ASSIGN,
  AND_ASSIGN,
  XOR_ASSIGN,
  assignment_operator_Nothing,
}
impl Default for assignment_operator { fn default()->Self { assignment_operator::assignment_operator_Nothing } }

#[derive(Default,Debug)]
pub struct function_definition<'lt>(pub Vec<LBox<declaration_specifier<'lt>>>,pub declarator<'lt>,pub Vec<LBox<declaration<'lt>>>,pub statement<'lt>,);

#[derive(Debug)]
pub enum specifier_qualifier<'lt> {
  specifier_qualifier_147(LBox<type_specifier<'lt>>),
  specifier_qualifier_148(type_qualifier),
  specifier_qualifier_Nothing,
}
impl<'lt> Default for specifier_qualifier<'lt> { fn default()->Self { specifier_qualifier::specifier_qualifier_Nothing } }

#[derive(Debug)]
pub enum identifier_list {
  identifier_list_Nothing,
}
impl Default for identifier_list { fn default()->Self { identifier_list::identifier_list_Nothing } }

#[derive(Debug)]
pub enum direct_abstract_declarator {
  direct_abstract_declarator_Nothing,
}
impl Default for direct_abstract_declarator { fn default()->Self { direct_abstract_declarator::direct_abstract_declarator_Nothing } }

#[derive(Default,Debug)]
pub struct enumerator<'lt>(pub &'lt str,pub Option<LBox<expression<'lt>>>,);

#[derive(Debug)]
pub enum parameter_declaration<'lt> {
  parameter_declaration_209(Vec<LBox<declaration_specifier<'lt>>>,LBox<abstract_declarator<'lt>>),
  parameter_declaration_210(Vec<LBox<declaration_specifier<'lt>>>),
  parameter_declaration_208(Vec<LBox<declaration_specifier<'lt>>>,LBox<declarator<'lt>>),
  parameter_declaration_Nothing,
}
impl<'lt> Default for parameter_declaration<'lt> { fn default()->Self { parameter_declaration::parameter_declaration_Nothing } }

#[derive(Debug)]
pub enum type_qualifier_list {
  type_qualifier_list_Nothing,
}
impl Default for type_qualifier_list { fn default()->Self { type_qualifier_list::type_qualifier_list_Nothing } }

#[derive(Debug)]
pub enum abstract_declarator<'lt> {
  abstract_declarator_217(Option<LBox<pointer>>,LBox<abstract_declarator<'lt>>,Vec<LBox<da_base<'lt>>>),
  abstract_declarator_214(pointer),
  abstract_declarator_220(Option<LBox<pointer>>,Vec<LBox<da_base<'lt>>>),
  abstract_declarator_Nothing,
}
impl<'lt> Default for abstract_declarator<'lt> { fn default()->Self { abstract_declarator::abstract_declarator_Nothing } }

#[derive(Debug)]
pub enum direct_contents<'lt> {
  direct_contents_195(Vec<LBox<&'lt str>>),
  direct_contents_189(Vec<LBox<type_qualifier>>,Option<LBox<expression<'lt>>>),
  direct_contents_184(Vec<LBox<type_qualifier>>),
  direct_contents_181(Option<()>,LBox<expression<'lt>>),
  direct_contents_190(LBox<parameter_type_list<'lt>>),
  direct_contents_178(Option<()>),
  direct_contents_185(Option<()>,Vec<LBox<type_qualifier>>,LBox<expression<'lt>>),
  IDENTIFIER(&'lt str),
  DEC(LBox<declarator<'lt>>),
  direct_contents_Nothing,
}
impl<'lt> Default for direct_contents<'lt> { fn default()->Self { direct_contents::direct_contents_Nothing } }

#[derive(Default,Debug)]
pub struct static_assert_declaration<'lt>(pub LBox<expression<'lt>>,pub &'lt str,);

#[derive(Default,Debug)]
pub struct declarator<'lt>(pub Option<LBox<pointer>>,pub LBox<direct_declarator<'lt>>,);

#[derive(Default,Debug)]
pub struct enumerator_list<'lt>(pub Vec<LBox<enumerator<'lt>>>,);

#[derive(Debug)]
pub enum da_base<'lt> {
  da_base_222(LBox<parameter_type_list<'lt>>),
  da_base_226(Vec<LBox<type_qualifier>>),
  da_base_224(Vec<LBox<type_qualifier>>,LBox<expression<'lt>>),
  da_base_221(Option<()>),
  da_base_223(LBox<expression<'lt>>),
  da_base_225(Vec<LBox<type_qualifier>>,Option<()>,LBox<expression<'lt>>),
  da_base_Nothing,
}
impl<'lt> Default for da_base<'lt> { fn default()->Self { da_base::da_base_Nothing } }

#[derive(Debug)]
pub enum struct_declarator<'lt> {
  struct_declarator_151(LBox<declarator<'lt>>,LBox<expression<'lt>>),
  struct_declarator_149(LBox<declarator<'lt>>),
  Colon_150(LBox<expression<'lt>>),
  struct_declarator_Nothing,
}
impl<'lt> Default for struct_declarator<'lt> { fn default()->Self { struct_declarator::struct_declarator_Nothing } }

#[derive(Default,Debug)]
pub struct expressions<'lt>(pub Vec<LBox<expression<'lt>>>,);

#[derive(Default,Debug)]
pub struct atomic_type_specifier<'lt>(pub LBox<type_name<'lt>>,);

#[derive(Debug)]
pub enum struct_or_union {
  UNION,
  STRUCT,
  struct_or_union_Nothing,
}
impl Default for struct_or_union { fn default()->Self { struct_or_union::struct_or_union_Nothing } }

#[derive(Debug)]
pub enum Stringlit<'lt> {
  STRING_LITERAL(&'lt str),
  FUNC_NAME,
  Stringlit_Nothing,
}
impl<'lt> Default for Stringlit<'lt> { fn default()->Self { Stringlit::Stringlit_Nothing } }

#[derive(Default,Debug)]
pub struct NEWSEQNT_204_1();

#[derive(Debug)]
pub enum enum_specifier<'lt> {
  ENUM_152(LBox<enumerator_list<'lt>>),
  ENUM_153(&'lt str,LBox<enumerator_list<'lt>>),
  ENUM_154(&'lt str),
  enum_specifier_Nothing,
}
impl<'lt> Default for enum_specifier<'lt> { fn default()->Self { enum_specifier::enum_specifier_Nothing } }

#[derive(Debug)]
pub enum unary_operator {
  Star,
  Neg,
  BinComp,
  Amp,
  UniPlus,
  Not,
  unary_operator_Nothing,
}
impl Default for unary_operator { fn default()->Self { unary_operator::unary_operator_Nothing } }

#[derive(Debug)]
pub enum type_specifier<'lt> {
  LONG,
  COMPLEX,
  FLOAT,
  DOUBLE,
  BOOL,
  type_specifier_128(LBox<struct_or_union_specifier<'lt>>),
  CHAR,
  type_specifier_129(LBox<enum_specifier<'lt>>),
  IMAGINARY,
  UNSIGNED,
  VOID,
  type_specifier_130(LBox<atomic_type_specifier<'lt>>),
  INT,
  SIGNED,
  Typename(&'lt str),
  SHORT,
  type_specifier_Nothing,
}
impl<'lt> Default for type_specifier<'lt> { fn default()->Self { type_specifier::type_specifier_Nothing } }

#[derive(Debug)]
pub enum struct_declaration<'lt> {
  struct_declaration_146(LBox<static_assert_declaration<'lt>>),
  struct_declaration_145(Vec<LBox<specifier_qualifier<'lt>>>,Vec<LBox<struct_declarator<'lt>>>),
  struct_declaration_Nothing,
}
impl<'lt> Default for struct_declaration<'lt> { fn default()->Self { struct_declaration::struct_declaration_Nothing } }

#[derive(Debug)]
pub enum storage_class_specifier {
  TYPEDEF,
  STATIC,
  REGISTER,
  EXTERN,
  AUTO,
  THREAD_LOCAL,
  storage_class_specifier_Nothing,
}
impl Default for storage_class_specifier { fn default()->Self { storage_class_specifier::storage_class_specifier_Nothing } }

#[derive(Debug)]
pub enum generic_association<'lt> {
  by_default(LBox<expression<'lt>>),
  by_type(LBox<type_name<'lt>>,LBox<expression<'lt>>),
  generic_association_Nothing,
}
impl<'lt> Default for generic_association<'lt> { fn default()->Self { generic_association::generic_association_Nothing } }

#[derive(Debug)]
pub enum declaration<'lt> {
  DecSpec(Vec<LBox<declaration_specifier<'lt>>>),
  DecSpecList(Vec<LBox<declaration_specifier<'lt>>>,Vec<LBox<init_declarator<'lt>>>),
  Statassert(static_assert_declaration<'lt>),
  declaration_Nothing,
}
impl<'lt> Default for declaration<'lt> { fn default()->Self { declaration::declaration_Nothing } }


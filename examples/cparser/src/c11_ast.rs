//Abstract syntax types generated by rustlr for grammar c11
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(dead_code)]
extern crate rustlr;
pub use rustlr::LC;
use rustlr::LBox;

pub use std::collections::HashSet;
#[derive(Debug,Default)]
pub struct defined_id_table<'t> {
  pub typedefs: HashSet<&'t str>,
  pub enum_ids: HashSet<&'t str>,
  pub anticipate_typedef: bool,
  pub in_function:bool,
  pub warnings_issued:bool,
}


#[derive(Debug)]
pub enum alignment_specifier<'lt> {
  ALIGNAS_170(LBox<expression<'lt>>),
  ALIGNAS_169(LBox<type_name<'lt>>),
  alignment_specifier_Nothing,
}
impl<'lt> Default for alignment_specifier<'lt> { fn default()->Self { alignment_specifier::alignment_specifier_Nothing } }

#[derive(Debug)]
pub enum declaration_specifiers {
  declaration_specifiers_Nothing,
}
impl Default for declaration_specifiers { fn default()->Self { declaration_specifiers::declaration_specifiers_Nothing } }

#[derive(Debug)]
pub enum storage_class_specifier {
  AUTO,
  EXTERN,
  REGISTER,
  TYPEDEF,
  STATIC,
  THREAD_LOCAL,
  storage_class_specifier_Nothing,
}
impl Default for storage_class_specifier { fn default()->Self { storage_class_specifier::storage_class_specifier_Nothing } }

#[derive(Debug)]
pub enum struct_declarator<'lt> {
  declare(LBox<declarator<'lt>>,Option<LBox<expression<'lt>>>),
  nodeclare(LBox<expression<'lt>>),
  struct_declarator_Nothing,
}
impl<'lt> Default for struct_declarator<'lt> { fn default()->Self { struct_declarator::struct_declarator_Nothing } }

#[derive(Debug)]
pub enum abstract_declarator<'lt> {
  abstract_declarator_218(Option<LBox<pointer>>,LBox<Vec<LC<da_base<'lt>>>>),
  abstract_declarator_214(pointer),
  abstract_declarator_215(Option<LBox<pointer>>,LBox<abstract_declarator<'lt>>,LBox<Vec<LC<da_base<'lt>>>>),
  abstract_declarator_Nothing,
}
impl<'lt> Default for abstract_declarator<'lt> { fn default()->Self { abstract_declarator::abstract_declarator_Nothing } }

#[derive(Debug)]
pub enum function_specifier {
  INLINE,
  NORETURN,
  function_specifier_Nothing,
}
impl Default for function_specifier { fn default()->Self { function_specifier::function_specifier_Nothing } }

#[derive(Debug)]
pub enum struct_or_union {
  STRUCT,
  UNION,
  struct_or_union_Nothing,
}
impl Default for struct_or_union { fn default()->Self { struct_or_union::struct_or_union_Nothing } }

#[derive(Debug)]
pub enum Stringlit<'lt> {
  STRING_LITERAL(&'lt str),
  FUNC_NAME,
  Stringlit_Nothing,
}
impl<'lt> Default for Stringlit<'lt> { fn default()->Self { Stringlit::Stringlit_Nothing } }

#[derive(Debug)]
pub enum type_qualifier {
  VOLATILE,
  CONST,
  ATOMIC,
  RESTRICT,
  type_qualifier_Nothing,
}
impl Default for type_qualifier { fn default()->Self { type_qualifier::type_qualifier_Nothing } }

#[derive(Debug)]
pub enum assignment_operator {
  DIV_ASSIGN,
  SUB_ASSIGN,
  ASSIGN,
  AND_ASSIGN,
  OR_ASSIGN,
  XOR_ASSIGN,
  MUL_ASSIGN,
  RIGHT_ASSIGN,
  LEFT_ASSIGN,
  MOD_ASSIGN,
  ADD_ASSIGN,
  assignment_operator_Nothing,
}
impl Default for assignment_operator { fn default()->Self { assignment_operator::assignment_operator_Nothing } }

#[derive(Debug)]
pub enum enum_specifier<'lt> {
  ENUM_154(Option<LBox<&'lt str>>,LBox<Vec<LC<enumerator<'lt>>>>),
  ENUM_157(&'lt str),
  enum_specifier_Nothing,
}
impl<'lt> Default for enum_specifier<'lt> { fn default()->Self { enum_specifier::enum_specifier_Nothing } }

#[derive(Debug)]
pub enum struct_declaration<'lt> {
  struct_declaration_139(LBox<Vec<LC<specifier_qualifier<'lt>>>>,LBox<Vec<LC<struct_declarator<'lt>>>>),
  struct_declaration_146(LBox<static_assert_declaration<'lt>>),
  struct_declaration_Nothing,
}
impl<'lt> Default for struct_declaration<'lt> { fn default()->Self { struct_declaration::struct_declaration_Nothing } }

#[derive(Debug)]
pub enum specifier_qualifier<'lt> {
  specifier_qualifier_147(LBox<type_specifier<'lt>>),
  specifier_qualifier_148(type_qualifier),
  specifier_qualifier_Nothing,
}
impl<'lt> Default for specifier_qualifier<'lt> { fn default()->Self { specifier_qualifier::specifier_qualifier_Nothing } }

#[derive(Debug)]
pub enum designator<'lt> {
  dotid(&'lt str),
  brackexpr(LBox<expression<'lt>>),
  designator_Nothing,
}
impl<'lt> Default for designator<'lt> { fn default()->Self { designator::designator_Nothing } }

#[derive(Debug)]
pub enum direct_contents<'lt> {
  direct_contents_186(Vec<LC<type_qualifier>>,Option<LBox<expression<'lt>>>),
  direct_contents_179{is_static:Option<()>,_item2_:LBox<expression<'lt>>},
  direct_contents_176{star:Option<()>},
  direct_contents_182(Vec<LC<type_qualifier>>),
  direct_contents_190(LBox<parameter_type_list<'lt>>),
  direct_contents_185{is_static:Option<()>,_item2_:Vec<LC<type_qualifier>>,_item3_:LBox<expression<'lt>>},
  direct_contents_191(Vec<LC<&'lt str>>),
  direct_contents_Nothing,
}
impl<'lt> Default for direct_contents<'lt> { fn default()->Self { direct_contents::direct_contents_Nothing } }

#[derive(Debug)]
pub enum da_base<'lt> {
  da_base_224(Vec<LC<type_qualifier>>,LBox<expression<'lt>>),
  da_base_225{_item1_:Vec<LC<type_qualifier>>,is_static:Option<()>,_item3_:LBox<expression<'lt>>},
  da_base_221{star:Option<()>},
  da_base_223(LBox<expression<'lt>>),
  da_base_226(Vec<LC<type_qualifier>>),
  da_base_222(LBox<parameter_type_list<'lt>>),
  da_base_Nothing,
}
impl<'lt> Default for da_base<'lt> { fn default()->Self { da_base::da_base_Nothing } }

#[derive(Debug)]
pub enum type_specifier<'lt> {
  FLOAT,
  INT,
  SIGNED,
  Typename(&'lt str),
  CHAR,
  COMPLEX,
  type_specifier_130(LBox<atomic_type_specifier<'lt>>),
  type_specifier_129(LBox<enum_specifier<'lt>>),
  type_specifier_128(LBox<struct_or_union_specifier<'lt>>),
  SHORT,
  DOUBLE,
  UNSIGNED,
  LONG,
  VOID,
  IMAGINARY,
  BOOL,
  type_specifier_Nothing,
}
impl<'lt> Default for type_specifier<'lt> { fn default()->Self { type_specifier::type_specifier_Nothing } }

#[derive(Debug)]
pub enum direct_abstract_declarator {
  direct_abstract_declarator_Nothing,
}
impl Default for direct_abstract_declarator { fn default()->Self { direct_abstract_declarator::direct_abstract_declarator_Nothing } }

#[derive(Debug)]
pub enum unary_operator {
  Neg,
  Star,
  BinComp,
  Amp,
  UniPlus,
  Not,
  unary_operator_Nothing,
}
impl Default for unary_operator { fn default()->Self { unary_operator::unary_operator_Nothing } }

#[derive(Debug)]
pub enum Constant<'lt> {
  ENUMERATION_CONSTANT(&'lt str),
  I_CONSTANT(i32),
  F_CONSTANT(f64),
  Constant_Nothing,
}
impl<'lt> Default for Constant<'lt> { fn default()->Self { Constant::Constant_Nothing } }

#[derive(Debug)]
pub enum declaration<'lt> {
  Statassert(static_assert_declaration<'lt>),
  fundef(LBox<external_declaration<'lt>>),
  DecSpec(Vec<LC<declaration_specifier<'lt>>>),
  DecSpecList{dsl:Vec<LC<declaration_specifier<'lt>>>,initdc:Vec<LC<init_declarator<'lt>>>},
  declaration_Nothing,
}
impl<'lt> Default for declaration<'lt> { fn default()->Self { declaration::declaration_Nothing } }

#[derive(Debug)]
pub enum struct_or_union_specifier<'lt> {
  struct_or_union_specifier_136(struct_or_union,&'lt str),
  struct_or_union_specifier_131(struct_or_union,Option<LBox<&'lt str>>,LBox<Vec<LC<struct_declaration<'lt>>>>),
  struct_or_union_specifier_Nothing,
}
impl<'lt> Default for struct_or_union_specifier<'lt> { fn default()->Self { struct_or_union_specifier::struct_or_union_specifier_Nothing } }

#[derive(Debug)]
pub enum parameter_declaration<'lt> {
  parameter_declaration_209(LBox<Vec<LC<declaration_specifier<'lt>>>>,LBox<abstract_declarator<'lt>>),
  parameter_declaration_210(LBox<Vec<LC<declaration_specifier<'lt>>>>),
  parameter_declaration_208(LBox<Vec<LC<declaration_specifier<'lt>>>>,LBox<declarator<'lt>>),
  parameter_declaration_Nothing,
}
impl<'lt> Default for parameter_declaration<'lt> { fn default()->Self { parameter_declaration::parameter_declaration_Nothing } }

#[derive(Debug)]
pub enum block_item<'lt> {
  Declaration(LBox<declaration<'lt>>),
  Statement(LBox<statement<'lt>>),
  block_item_Nothing,
}
impl<'lt> Default for block_item<'lt> { fn default()->Self { block_item::block_item_Nothing } }

#[derive(Debug)]
pub enum elseopt {
  elseopt_Nothing,
}
impl Default for elseopt { fn default()->Self { elseopt::elseopt_Nothing } }

#[derive(Debug)]
pub enum declaration_specifier<'lt> {
  typespec(LBox<type_specifier<'lt>>),
  typequal(type_qualifier),
  storage(storage_class_specifier),
  funcspec(function_specifier),
  alignspec(LBox<alignment_specifier<'lt>>),
  declaration_specifier_Nothing,
}
impl<'lt> Default for declaration_specifier<'lt> { fn default()->Self { declaration_specifier::declaration_specifier_Nothing } }

#[derive(Debug)]
pub enum direct_base<'lt> {
  DEC(LBox<declarator<'lt>>),
  IDENTIFIER{id:&'lt str},
  direct_base_Nothing,
}
impl<'lt> Default for direct_base<'lt> { fn default()->Self { direct_base::direct_base_Nothing } }

#[derive(Debug)]
pub enum expression<'lt> {
  expr_list(LBox<expressions<'lt>>),
  const_expr(LBox<expression<'lt>>),
  Plus(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Minus(LBox<expression<'lt>>,LBox<expression<'lt>>),
  BitOr(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Typecast(LBox<type_name<'lt>>,LBox<expression<'lt>>),
  MinusMinus(LBox<expression<'lt>>),
  Dotaccess(LBox<expression<'lt>>,&'lt str),
  PlusPlus(LBox<expression<'lt>>),
  Indexing(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Function_call(LBox<expression<'lt>>,LBox<Vec<LC<expression<'lt>>>>),
  Ptraccess(LBox<expression<'lt>>,&'lt str),
  dont_know_what_this_is(LBox<type_name<'lt>>,LBox<Vec<LC<initializer_designation<'lt>>>>),
  Or(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Quest(LBox<expression<'lt>>,LBox<expression<'lt>>,LBox<expression<'lt>>),
  ALIGNOF_37(LBox<type_name<'lt>>),
  Unaryop(unary_operator,LBox<expression<'lt>>),
  SIZEOF_36(LBox<type_name<'lt>>),
  Mod(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Divide(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Times(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Leq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Gt(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Geq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Lt(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Assignment(LBox<expression<'lt>>,assignment_operator,LBox<expression<'lt>>),
  BitXor(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Rshift(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Lshift(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Generic(LBox<generic_selection<'lt>>),
  Stringlit(Stringlit<'lt>),
  Var(&'lt str),
  primary_expression_1(LBox<expression<'lt>>),
  Constant(Constant<'lt>),
  And(LBox<expression<'lt>>,LBox<expression<'lt>>),
  NotEquals(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Equals(LBox<expression<'lt>>,LBox<expression<'lt>>),
  BitAnd(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_Nothing,
}
impl<'lt> Default for expression<'lt> { fn default()->Self { expression::expression_Nothing } }

#[derive(Debug)]
pub enum statement<'lt> {
  Expr_list(Option<LBox<expression<'lt>>>),
  Labelstat(&'lt str,LBox<statement<'lt>>),
  Casestat(expression<'lt>,LBox<statement<'lt>>),
  Defaultcase(LBox<statement<'lt>>),
  Continuestat,
  Breakstat,
  Returnstat(Vec<LC<expression<'lt>>>),
  Goto_oh_no(&'lt str),
  Blockstat(LBox<Vec<LC<block_item<'lt>>>>),
  Switchstat(expression<'lt>,LBox<statement<'lt>>),
  Ifstat(expression<'lt>,LBox<statement<'lt>>),
  Ifelse(expression<'lt>,LBox<statement<'lt>>,LBox<statement<'lt>>),
  Forloop(LBox<statement<'lt>>,LBox<statement<'lt>>,Option<LBox<expression<'lt>>>,LBox<statement<'lt>>),
  Whileloop(expression<'lt>,LBox<statement<'lt>>),
  ForDecloop(LBox<declaration<'lt>>,LBox<statement<'lt>>,Option<LBox<expression<'lt>>>,LBox<statement<'lt>>),
  Dowhileloop(LBox<statement<'lt>>,expression<'lt>),
  statement_Nothing,
}
impl<'lt> Default for statement<'lt> { fn default()->Self { statement::statement_Nothing } }

#[derive(Debug)]
pub enum initializer<'lt> {
  values(LBox<Vec<LC<initializer_designation<'lt>>>>),
  expr(LBox<expression<'lt>>),
  initializer_Nothing,
}
impl<'lt> Default for initializer<'lt> { fn default()->Self { initializer::initializer_Nothing } }

#[derive(Debug)]
pub enum external_declaration<'lt> {
  declaration(LBox<declaration<'lt>>),
  directive(&'lt str),
  functiondef(LBox<function_header<'lt>>,LBox<statement<'lt>>),
  external_declaration_Nothing,
}
impl<'lt> Default for external_declaration<'lt> { fn default()->Self { external_declaration::external_declaration_Nothing } }

#[derive(Debug)]
pub enum generic_association<'lt> {
  by_default(LBox<expression<'lt>>),
  by_type(LBox<type_name<'lt>>,LBox<expression<'lt>>),
  generic_association_Nothing,
}
impl<'lt> Default for generic_association<'lt> { fn default()->Self { generic_association::generic_association_Nothing } }

#[derive(Default,Debug)]
pub struct init_declarator<'lt> {
  pub decl:declarator<'lt>,
  pub initializer:Option<LBox<initializer<'lt>>>,
}

#[derive(Default,Debug)]
pub struct type_name<'lt>(pub LBox<Vec<LC<specifier_qualifier<'lt>>>>,pub Option<LBox<abstract_declarator<'lt>>>,);

#[derive(Default,Debug)]
pub struct NEWSEQNT_205_1();

#[derive(Default,Debug)]
pub struct function_header<'lt> {
  pub ds:LBox<Vec<LC<declaration_specifier<'lt>>>>,
  pub _item1_:declarator<'lt>,
  pub _item2_:LBox<Vec<LC<declaration<'lt>>>>,
}

#[derive(Default,Debug)]
pub struct enumerator<'lt> {
  pub id:&'lt str,
  pub _item1_:Option<LBox<expression<'lt>>>,
}

#[derive(Default,Debug)]
pub struct translation_unit<'lt>(pub Vec<LC<external_declaration<'lt>>>,);

#[derive(Default,Debug)]
pub struct designation<'lt>(pub LBox<Vec<LC<designator<'lt>>>>,);

#[derive(Default,Debug)]
pub struct pointer {
  pub tql:Vec<LC<type_qualifier>>,
  pub ptr:Option<LBox<pointer>>,
}

#[derive(Default,Debug)]
pub struct initializer_designation<'lt>(pub Option<LBox<designation<'lt>>>,pub LBox<initializer<'lt>>,);

#[derive(Default,Debug)]
pub struct parameter_type_list<'lt> {
  pub parameters:LBox<Vec<LC<parameter_declaration<'lt>>>>,
  pub ellipsis:Option<LBox<NEWSEQNT_205_1>>,
}

#[derive(Default,Debug)]
pub struct atomic_type_specifier<'lt>(pub LBox<type_name<'lt>>,);

#[derive(Default,Debug)]
pub struct generic_selection<'lt>(pub LBox<expression<'lt>>,pub LBox<Vec<LC<generic_association<'lt>>>>,);

#[derive(Default,Debug)]
pub struct expressions<'lt>(pub LBox<Vec<LC<expression<'lt>>>>,);

#[derive(Default,Debug)]
pub struct direct_declarator<'lt>(pub LBox<direct_base<'lt>>,pub LBox<Vec<LC<direct_contents<'lt>>>>,);

#[derive(Default,Debug)]
pub struct static_assert_declaration<'lt>(pub LBox<expression<'lt>>,pub &'lt str,);

#[derive(Default,Debug)]
pub struct declarator<'lt>(pub Option<LBox<pointer>>,pub LBox<direct_base<'lt>>,pub LBox<Vec<LC<direct_contents<'lt>>>>,);


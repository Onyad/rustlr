//Abstract syntax types generated by rustlr for grammar c11f
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(dead_code)]
extern crate rustlr;
use rustlr::LBox;
use crate::c11_ast::declaration::*;
use crate::c11_ast::direct_declarator::*;
use crate::c11_ast::declaration_specifier::*;
use crate::c11_ast::storage_class_specifier::*;

#[derive(Default,Debug)]
pub struct static_assert_declaration<'lt>(pub LBox<expression<'lt>>,pub &'lt str,);

#[derive(Debug)]
pub enum selection_statement<'lt> {
  IF_258(expressionS<'lt>,LBox<statement<'lt>>,LBox<statement<'lt>>),
  IF_257(expressionS<'lt>,LBox<statement<'lt>>),
  SWITCH_259(expressionS<'lt>,LBox<statement<'lt>>),
  selection_statement_Nothing,
}
impl<'lt> Default for selection_statement<'lt> { fn default()->Self { selection_statement::selection_statement_Nothing } }

#[derive(Debug)]
pub enum type_specifier<'lt> {
  IMAGINARY,
  COMPLEX,
  Typename(&'lt str),
  type_specifier_107(LBox<struct_or_union_specifier<'lt>>),
  DOUBLE,
  SIGNED,
  INT,
  BOOL,
  type_specifier_108(LBox<enum_specifier<'lt>>),
  CHAR,
  VOID,
  FLOAT,
  SHORT,
  LONG,
  type_specifier_109(LBox<atomic_type_specifier<'lt>>),
  UNSIGNED,
  type_specifier_Nothing,
}
impl<'lt> Default for type_specifier<'lt> { fn default()->Self { type_specifier::type_specifier_Nothing } }

#[derive(Debug)]
pub enum declaration<'lt> {
  Statassert(static_assert_declaration<'lt>),
  DecSpec(declaration_specifiers<'lt>),
  DecSpecList(declaration_specifiers<'lt>,Vec<LBox<init_declarator<'lt>>>),
  declaration_Nothing,
}
impl<'lt> Default for declaration<'lt> { fn default()->Self { declaration::declaration_Nothing } }

#[derive(Default,Debug)]
pub struct expressionS<'lt>(pub expression_list<'lt>,);

#[derive(Default,Debug)]
pub struct pointer {
  pub tql:Vec<LBox<type_qualifier>>,
  pub ptr:Option<LBox<pointer>>,
}
#[derive(Default,Debug)]
pub struct parameter_type_list<'lt> {
  pub parameters:Vec<LBox<parameter_declaration<'lt>>>,
  pub ellipsis:Option<LBox<NEWSEQNT_183_1>>,
}
#[derive(Default,Debug)]
pub struct type_qualifier_list(pub Vec<LBox<type_qualifier>>,);

#[derive(Default,Debug)]
pub struct enumerator<'lt>(pub &'lt str,pub Option<LBox<expression<'lt>>>,);

#[derive(Debug)]
pub enum declaration_specifier<'lt> {
  typespec(LBox<type_specifier<'lt>>),
  funcspec(function_specifier),
  alignspec(LBox<alignment_specifier<'lt>>),
  storage(storage_class_specifier),
  typequal(type_qualifier),
  declaration_specifier_Nothing,
}
impl<'lt> Default for declaration_specifier<'lt> { fn default()->Self { declaration_specifier::declaration_specifier_Nothing } }

#[derive(Default,Debug)]
pub struct NEWSEQNT_183_1();

#[derive(Debug)]
pub enum iteration_statement<'lt> {
  FOR_267(declaration<'lt>,expression_statement<'lt>,Option<LBox<expressionS<'lt>>>,LBox<statement<'lt>>),
  WHILE_260(expressionS<'lt>,LBox<statement<'lt>>),
  FOR_264(expression_statement<'lt>,expression_statement<'lt>,Option<LBox<expressionS<'lt>>>,LBox<statement<'lt>>),
  DO_261(LBox<statement<'lt>>,expressionS<'lt>),
  iteration_statement_Nothing,
}
impl<'lt> Default for iteration_statement<'lt> { fn default()->Self { iteration_statement::iteration_statement_Nothing } }

#[derive(Default,Debug)]
pub struct translation_unit<'lt>(pub Vec<LBox<external_declaration<'lt>>>,);

#[derive(Debug)]
pub enum statement<'lt> {
  statement_241(LBox<compound_statement<'lt>>),
  statement_243(LBox<selection_statement<'lt>>),
  statement_245(jump_statement<'lt>),
  statement_242(expression_statement<'lt>),
  statement_240(LBox<labeled_statement<'lt>>),
  statement_244(LBox<iteration_statement<'lt>>),
  statement_Nothing,
}
impl<'lt> Default for statement<'lt> { fn default()->Self { statement::statement_Nothing } }

#[derive(Default,Debug)]
pub struct declaration_specifiers<'lt>(pub Vec<LBox<declaration_specifier<'lt>>>,);

#[derive(Debug)]
pub enum parameter_declaration<'lt> {
  parameter_declaration_189(LBox<declaration_specifiers<'lt>>),
  parameter_declaration_188(LBox<declaration_specifiers<'lt>>,LBox<abstract_declarator<'lt>>),
  parameter_declaration_187(LBox<declaration_specifiers<'lt>>,LBox<declarator<'lt>>),
  parameter_declaration_Nothing,
}
impl<'lt> Default for parameter_declaration<'lt> { fn default()->Self { parameter_declaration::parameter_declaration_Nothing } }

#[derive(Debug)]
pub enum type_qualifier {
  CONST,
  RESTRICT,
  ATOMIC,
  VOLATILE,
  type_qualifier_Nothing,
}
impl Default for type_qualifier { fn default()->Self { type_qualifier::type_qualifier_Nothing } }

#[derive(Default,Debug)]
pub struct compound_statement<'lt> {
  pub statements:Vec<LBox<block_item<'lt>>>,
}
#[derive(Default,Debug)]
pub struct enumerator_list<'lt>(pub Vec<LBox<enumerator<'lt>>>,);

#[derive(Debug)]
pub enum labeled_statement<'lt> {
  IDENTIFIER_246(&'lt str,LBox<statement<'lt>>),
  DEFAULT_248(LBox<statement<'lt>>),
  CASE_247(expression<'lt>,LBox<statement<'lt>>),
  labeled_statement_Nothing,
}
impl<'lt> Default for labeled_statement<'lt> { fn default()->Self { labeled_statement::labeled_statement_Nothing } }

#[derive(Debug)]
pub enum specifier_qualifier<'lt> {
  specifier_qualifier_126(type_qualifier),
  specifier_qualifier_125(LBox<type_specifier<'lt>>),
  specifier_qualifier_Nothing,
}
impl<'lt> Default for specifier_qualifier<'lt> { fn default()->Self { specifier_qualifier::specifier_qualifier_Nothing } }

#[derive(Debug)]
pub enum struct_or_union_specifier<'lt> {
  struct_or_union_specifier_112(struct_or_union,Option<LBox<&'lt str>>,LBox<struct_declaration_list<'lt>>),
  struct_or_union_specifier_113(struct_or_union,&'lt str),
  struct_or_union_specifier_Nothing,
}
impl<'lt> Default for struct_or_union_specifier<'lt> { fn default()->Self { struct_or_union_specifier::struct_or_union_specifier_Nothing } }

#[derive(Debug)]
pub enum function_specifier {
  INLINE,
  NORETURN,
  function_specifier_Nothing,
}
impl Default for function_specifier { fn default()->Self { function_specifier::function_specifier_Nothing } }

#[derive(Debug)]
pub enum struct_or_union {
  STRUCT(()),
  UNION(()),
  struct_or_union_Nothing,
}
impl Default for struct_or_union { fn default()->Self { struct_or_union::struct_or_union_Nothing } }

#[derive(Default,Debug)]
pub struct initializer_designation<'lt>(pub Option<LBox<designation<'lt>>>,pub LBox<initializer<'lt>>,);

#[derive(Default,Debug)]
pub struct expression_list<'lt>(pub Vec<LBox<expression<'lt>>>,);

#[derive(Debug)]
pub enum struct_declarator<'lt> {
  Colon_131(LBox<expression<'lt>>),
  struct_declarator_130(LBox<declarator<'lt>>),
  struct_declarator_132(LBox<declarator<'lt>>,LBox<expression<'lt>>),
  struct_declarator_Nothing,
}
impl<'lt> Default for struct_declarator<'lt> { fn default()->Self { struct_declarator::struct_declarator_Nothing } }

#[derive(Default,Debug)]
pub struct type_name<'lt>(pub LBox<specifier_qualifier_list<'lt>>,pub Option<LBox<abstract_declarator<'lt>>>,);

#[derive(Debug)]
pub enum designator<'lt> {
  designator_237(LBox<expression<'lt>>),
  Dot_238(&'lt str),
  designator_Nothing,
}
impl<'lt> Default for designator<'lt> { fn default()->Self { designator::designator_Nothing } }

#[derive(Default,Debug)]
pub struct init_declarator<'lt> {
  pub decl:declarator<'lt>,
  pub initializer:Option<LBox<initializer<'lt>>>,
}
#[derive(Default,Debug)]
pub struct declarator<'lt>(pub Option<LBox<pointer>>,pub LBox<direct_declarator<'lt>>,);

#[derive(Default,Debug)]
pub struct specifier_qualifier_list<'lt>(pub Vec<LBox<specifier_qualifier<'lt>>>,);

#[derive(Debug)]
pub enum abstract_declarator<'lt> {
  abstract_declarator_197(LBox<direct_abstract_declarator<'lt>>),
  abstract_declarator_196(pointer),
  abstract_declarator_198(pointer,LBox<direct_abstract_declarator<'lt>>),
  abstract_declarator_Nothing,
}
impl<'lt> Default for abstract_declarator<'lt> { fn default()->Self { abstract_declarator::abstract_declarator_Nothing } }

#[derive(Debug)]
pub enum direct_declarator<'lt> {
  direct_declarator_168(LBox<direct_declarator<'lt>>,type_qualifier_list),
  direct_declarator_167(LBox<direct_declarator<'lt>>,type_qualifier_list,LBox<expression<'lt>>),
  direct_declarator_169(LBox<direct_declarator<'lt>>,LBox<expression<'lt>>),
  direct_declarator_170(LBox<direct_declarator<'lt>>,LBox<parameter_type_list<'lt>>),
  direct_declarator_171(LBox<direct_declarator<'lt>>,identifier_list<'lt>),
  direct_declarator_172(LBox<direct_declarator<'lt>>),
  direct_declarator_163(LBox<direct_declarator<'lt>>,type_qualifier_list,LBox<expression<'lt>>),
  IDENTIFIER(&'lt str),
  direct_declarator_161(LBox<direct_declarator<'lt>>),
  direct_declarator_160(LBox<declarator<'lt>>),
  direct_declarator_162(LBox<direct_declarator<'lt>>),
  direct_declarator_165(LBox<direct_declarator<'lt>>,type_qualifier_list),
  direct_declarator_164(LBox<direct_declarator<'lt>>,LBox<expression<'lt>>),
  direct_declarator_166(LBox<direct_declarator<'lt>>,type_qualifier_list,LBox<expression<'lt>>),
  direct_declarator_Nothing,
}
impl<'lt> Default for direct_declarator<'lt> { fn default()->Self { direct_declarator::direct_declarator_Nothing } }

#[derive(Default,Debug)]
pub struct identifier_list<'lt>(pub Vec<LBox<&'lt str>>,);

#[derive(Debug)]
pub enum expression<'lt> {
  Meq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_46(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_43(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Ustar(LBox<expression<'lt>>),
  DEC_OP_29(LBox<expression<'lt>>),
  expression_13(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_24(LBox<type_name<'lt>>,Vec<LBox<initializer_designation<'lt>>>),
  Leq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Ref(LBox<expression<'lt>>),
  Band(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_44(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_52(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Deq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_18(LBox<expression<'lt>>),
  expression_16(LBox<expression<'lt>>,&'lt str),
  expression_48(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Or(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_14(LBox<expression<'lt>>),
  Xeq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  SIZEOF_31(LBox<type_name<'lt>>),
  Fconst(f64),
  expression_42(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_47(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Uminus(LBox<expression<'lt>>),
  Not(LBox<expression<'lt>>),
  expression_50(LBox<expression<'lt>>,LBox<expression<'lt>>),
  ALIGNOF_32(LBox<type_name<'lt>>),
  Bor(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Subeq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Andeq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  SIZEOF_30(LBox<expression<'lt>>),
  Comp(LBox<expression<'lt>>),
  expression_40(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Xor(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_19(LBox<expression<'lt>>),
  ID(&'lt str),
  INC_OP_28(LBox<expression<'lt>>),
  Econst(&'lt str),
  expression_17(LBox<expression<'lt>>,&'lt str),
  Assign(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_6(LBox<expression<'lt>>),
  expression_58(LBox<expression<'lt>>,LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_39(LBox<type_name<'lt>>,LBox<expression<'lt>>),
  Iconst(i32),
  Aeq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_15(LBox<expression<'lt>>,LBox<expression_list<'lt>>),
  expression_41(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_51(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_7(LBox<generic_selection<'lt>>),
  Stringlit(&'lt str),
  Oreq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_49(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_45(LBox<expression<'lt>>,LBox<expression<'lt>>),
  Teq(LBox<expression<'lt>>,LBox<expression<'lt>>),
  funcname,
  Uplus(LBox<expression<'lt>>),
  Req(LBox<expression<'lt>>,LBox<expression<'lt>>),
  And(LBox<expression<'lt>>,LBox<expression<'lt>>),
  expression_Nothing,
}
impl<'lt> Default for expression<'lt> { fn default()->Self { expression::expression_Nothing } }

#[derive(Default,Debug)]
pub struct atomic_type_specifier<'lt>(pub LBox<type_name<'lt>>,);

#[derive(Default,Debug)]
pub struct designation<'lt>(pub Vec<LBox<designator<'lt>>>,);

#[derive(Debug)]
pub enum struct_declaration<'lt> {
  struct_declaration_120(LBox<specifier_qualifier_list<'lt>>,Vec<LBox<struct_declarator<'lt>>>),
  struct_declaration_121(LBox<static_assert_declaration<'lt>>),
  struct_declaration_Nothing,
}
impl<'lt> Default for struct_declaration<'lt> { fn default()->Self { struct_declaration::struct_declaration_Nothing } }

#[derive(Debug)]
pub enum block_item<'lt> {
  Declaration(declaration<'lt>),
  Statement(LBox<statement<'lt>>),
  block_item_Nothing,
}
impl<'lt> Default for block_item<'lt> { fn default()->Self { block_item::block_item_Nothing } }

#[derive(Debug)]
pub enum storage_class_specifier {
  THREAD_LOCAL,
  STATIC,
  TYPEDEF,
  AUTO,
  REGISTER,
  EXTERN,
  storage_class_specifier_Nothing,
}
impl Default for storage_class_specifier { fn default()->Self { storage_class_specifier::storage_class_specifier_Nothing } }

#[derive(Debug)]
pub enum direct_abstract_declarator<'lt> {
  direct_abstract_declarator_210(LBox<expression<'lt>>),
  direct_abstract_declarator_199(LBox<abstract_declarator<'lt>>),
  direct_abstract_declarator_218(LBox<direct_abstract_declarator<'lt>>,type_qualifier_list,Option<()>,LBox<expression<'lt>>),
  direct_abstract_declarator_201,
  direct_abstract_declarator_212(LBox<direct_abstract_declarator<'lt>>),
  direct_abstract_declarator_223(LBox<direct_abstract_declarator<'lt>>),
  direct_abstract_declarator_221,
  direct_abstract_declarator_219(LBox<direct_abstract_declarator<'lt>>,type_qualifier_list),
  direct_abstract_declarator_211(LBox<direct_abstract_declarator<'lt>>),
  direct_abstract_declarator_222(LBox<parameter_type_list<'lt>>),
  direct_abstract_declarator_224(LBox<direct_abstract_declarator<'lt>>,LBox<parameter_type_list<'lt>>),
  direct_abstract_declarator_204(Vec<LBox<type_qualifier>>,LBox<expression<'lt>>),
  direct_abstract_declarator_200,
  direct_abstract_declarator_215(LBox<direct_abstract_declarator<'lt>>,Vec<LBox<type_qualifier>>,LBox<expression<'lt>>),
  direct_abstract_declarator_220(LBox<direct_abstract_declarator<'lt>>,LBox<expression<'lt>>),
  direct_abstract_declarator_209(type_qualifier_list,Option<()>,Option<LBox<expression<'lt>>>),
  direct_abstract_declarator_Nothing,
}
impl<'lt> Default for direct_abstract_declarator<'lt> { fn default()->Self { direct_abstract_declarator::direct_abstract_declarator_Nothing } }

#[derive(Debug)]
pub enum external_declaration<'lt> {
  external_declaration_277(declaration<'lt>),
  external_declaration_276(function_definition<'lt>),
  directive(&'lt str),
  external_declaration_Nothing,
}
impl<'lt> Default for external_declaration<'lt> { fn default()->Self { external_declaration::external_declaration_Nothing } }

#[derive(Debug)]
pub enum jump_statement<'lt> {
  CONTINUE_269,
  BREAK_270,
  GOTO_268(&'lt str),
  RETURN_271,
  RETURN_272(expressionS<'lt>),
  jump_statement_Nothing,
}
impl<'lt> Default for jump_statement<'lt> { fn default()->Self { jump_statement::jump_statement_Nothing } }

#[derive(Debug)]
pub enum enum_specifier<'lt> {
  ENUM_135(LBox<enumerator_list<'lt>>),
  ENUM_138(&'lt str,LBox<enumerator_list<'lt>>),
  ENUM_139(&'lt str),
  enum_specifier_Nothing,
}
impl<'lt> Default for enum_specifier<'lt> { fn default()->Self { enum_specifier::enum_specifier_Nothing } }

#[derive(Default,Debug)]
pub struct struct_declaration_list<'lt>(pub Vec<LBox<struct_declaration<'lt>>>,);

#[derive(Debug)]
pub enum initializer<'lt> {
  Lbrace_230(Vec<LBox<initializer_designation<'lt>>>),
  initializer_225(LBox<expression<'lt>>),
  initializer_Nothing,
}
impl<'lt> Default for initializer<'lt> { fn default()->Self { initializer::initializer_Nothing } }

#[derive(Default,Debug)]
pub struct expression_statement<'lt>(pub Option<LBox<expressionS<'lt>>>,);

#[derive(Debug)]
pub enum generic_association<'lt> {
  generic_association_11(LBox<type_name<'lt>>,LBox<expression<'lt>>),
  DEFAULT_12(LBox<expression<'lt>>),
  generic_association_Nothing,
}
impl<'lt> Default for generic_association<'lt> { fn default()->Self { generic_association::generic_association_Nothing } }

#[derive(Default,Debug)]
pub struct function_definition<'lt>(pub declaration_specifiers<'lt>,pub declarator<'lt>,pub Vec<LBox<declaration<'lt>>>,pub compound_statement<'lt>,);

#[derive(Default,Debug)]
pub struct generic_selection<'lt>(pub LBox<expression<'lt>>,pub Vec<LBox<generic_association<'lt>>>,);

#[derive(Debug)]
pub enum alignment_specifier<'lt> {
  ALIGNAS_155(LBox<expression<'lt>>),
  ALIGNAS_154(LBox<type_name<'lt>>),
  alignment_specifier_Nothing,
}
impl<'lt> Default for alignment_specifier<'lt> { fn default()->Self { alignment_specifier::alignment_specifier_Nothing } }


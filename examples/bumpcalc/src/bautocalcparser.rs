//Parser generated by rustlr for grammar bautocalc
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
use std::rc::Rc;
use std::cell::RefCell;
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use rustlr::{LC,Bumper};
use crate::bautocalc_ast::*;

static SYMBOLS:[&'static str;24] = ["_WILDCARD_TOKEN_","E","ES","A1","B1","C1","A2","C2","+","-","*","/","(",")","=",";","let","in","int","var","NEWSEPNT_10_0","NEWRENT_12_1","START","EOF"];

static TABLE:[u64;164] = [85899411457,4295163905,51539869696,68719804416,8590065665,77309870080,38655098880,81604902912,281565171679233,281539401809920,281573761744898,563048737669123,844459290591232,844463585755136,844489355296770,844523715035138,844467880591360,844472175624192,1125968626647040,1125951446712320,1125938561941504,1125977216712704,1125904202792961,1125981511745536,1407456488980480,1688854156345345,1688927170134016,1688901400133632,1688918580068352,1688888515362816,1688931465166848,1970389261484034,1970372081614850,1970363491680258,1970397851418626,1970423621222402,1970367786647554,1970380671549442,1970359196712962,2251855648325634,2251898597998594,2251842763423746,2251834173489154,2251847058391042,2251864238260226,2251838468456450,2251872828194818,2533313445494784,2533352100265984,2533279086542849,2533373575495682,2533343510200320,2533356395298816,2533326330265600,2814848551944194,3096229040029697,3096276283686912,3096293463621632,3096302053687296,3096263398916096,3096306348720128,3377777030397952,3377751260397568,3377704016805889,3377768440332288,3377781325430784,3377738375626752,3659256302141440,3659226237108224,3659178993582081,3659213352337408,3659252007108608,3659243417042944,3940688329048064,3940726983819264,3940718393753600,3940731278852096,3940653970358273,3940701213818880,4222159011119104,4222171896152064,4222163306283008,4222180486742016,4222167601119232,4503659758485504,4785130439049218,4785121849114626,4785147618918402,4785139028983810,4785117554147330,4785108964212738,4785173388722178,4785113259180034,5066583941251072,5066592531251200,5066648365760514,5066588236414976,5066596826284032,5066614006022146,5348123341881346,5348067507961856,5348063212339202,5348071802994688,5348058917371906,5348080392208386,5348097572077570,5348088982142978,5629598318723074,5629572548919298,5629546779115522,5629563958984706,5629538189180930,5629533894213634,5629542484148226,5629555369050114,5911030345826306,5911021755891714,5911017460924418,5911073295499266,5911013165957122,5911008870989826,5911047525695490,5911038935760898,6192496733126656,6192492438093824,6192488142536706,6192522502275074,6192513912340482,6192483847569410,6192548272078850,6192505322405890,6474023249117186,6473971709509634,6473963119575042,6473988889378818,6473958824607746,6473997479313410,6473967414542338,6473980299444226,6755481045958656,6755468160860160,6755450980925440,6755438096154624,6755476750925824,6755403737661441,7036947433914368,7036917368225792,7036908778225664,7036913073389568,7036921663258624,7318418114281472,7318353691213825,7318400934346752,7318388049575936,7318430999379968,7318426704347136,7599871616679936,7599867321647104,7599888796155906,7599897386090498,7599880206221314,7599923155894274,7599858731646976,7599863026810880,];


fn _semaction_rule_0_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_10(_x_10)=parser.popstack().value { _x_10 } else {<i64>::default()};  E::Val(_item0_) }

fn _semaction_rule_1_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_11(_x_11)=parser.popstack().value { _x_11 } else {<&'lt str>::default()};  E::Var(_item0_) }

fn _semaction_rule_2_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  E::BinaryOp("+",parser.exstate.make(_item0_),parser.exstate.make(_item2_)) }

fn _semaction_rule_3_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  E::BinaryOp("-",parser.exstate.make(_item0_),parser.exstate.make(_item2_)) }

fn _semaction_rule_4_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut __item2__ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  let mut _item2_ = parser.exstate.make(parser.lc(2,__item2__));  let mut _item1_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  E::Times(parser.exstate.make(_item0_),_item2_) }

fn _semaction_rule_5_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  let mut e2 = parser.exstate.make(parser.lc(2,_e2_));  let mut _item1_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  let mut e1 = parser.exstate.make(parser.lc(0,_e1_));   E::Div{e1:e1,e2:e2} }

fn _semaction_rule_6_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _e_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  let mut e = parser.exstate.make(parser.lc(1,_e_));  let mut _item0_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()};  E::Neg{e:e} }

fn _semaction_rule_7_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item5_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()}; let mut _item4_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item3_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_11(_x_11)=parser.popstack().value { _x_11 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()};  E::Let(_item1_,parser.exstate.make(_item3_),parser.exstate.make(_item5_)) }

fn _semaction_rule_8_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> E<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()};  _item1_ }

fn _semaction_rule_9_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> ES<'lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_29(_x_29)=parser.popstack().value { _x_29 } else {<Vec<&'lt LC<E<'lt>>>>::default()};  ES(_item0_,) }

fn _semaction_rule_10_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Vec<&'lt LC<E<'lt>>> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()};  vec![parser.exstate.make(parser.lc(0,_item0_))] }

fn _semaction_rule_11_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Vec<&'lt LC<E<'lt>>> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_29(_x_29)=parser.popstack().value { _x_29 } else {<Vec<&'lt LC<E<'lt>>>>::default()};  _item0_.push(parser.exstate.make(parser.lc(2,_item2_))); _item0_ }

fn _semaction_rule_12_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> () {
<()>::default()}

fn _semaction_rule_13_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> () {
let mut _item0_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; <()>::default()}

fn _semaction_rule_14_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> A1<'lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_10(_x_10)=parser.popstack().value { _x_10 } else {<i64>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_23(_x_23)=parser.popstack().value { _x_23 } else {<B1<'lt>>::default()};  A1(_item0_.0,_item0_.1,_item0_.2,_item1_,) }

fn _semaction_rule_15_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> B1<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_27(_x_27)=parser.popstack().value { _x_27 } else {<A1<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_11(_x_11)=parser.popstack().value { _x_11 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_11(_x_11)=parser.popstack().value { _x_11 } else {<&'lt str>::default()};  B1(_item0_,_item1_,parser.exstate.make(_item2_),) }

fn _semaction_rule_16_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> C1<'lt> {
let mut _item4_ = if let RetTypeEnum::Enumvariant_21(_x_21)=parser.popstack().value { _x_21 } else {<E<'lt>>::default()}; let mut _item3_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_23(_x_23)=parser.popstack().value { _x_23 } else {<B1<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_27(_x_27)=parser.popstack().value { _x_27 } else {<A1<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_24(_x_24)=parser.popstack().value { _x_24 } else {<A2>::default()};  C1(_item1_,_item2_.0,_item2_.1,_item2_.2,_item4_,) }

fn _semaction_rule_17_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> A2 {
let mut _item1_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_28(_x_28)=parser.popstack().value { _x_28 } else {<()>::default()};  A2() }

fn _semaction_rule_18_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> C2<'lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_27(_x_27)=parser.popstack().value { _x_27 } else {<A1<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_10(_x_10)=parser.popstack().value { _x_10 } else {<i64>::default()};  C2::Ctwo(_item0_,_item1_) }

fn _semaction_rule_19_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> () {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<ES<'lt>>::default()}; <()>::default()}

pub fn make_parser<'lt>() -> ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>
{
 let mut parser1:ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>> = ZCParser::new(20,28);
 let mut rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_21(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWSEPNT_10_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_29(_semaction_rule_10_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWSEPNT_10_0");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_29(_semaction_rule_11_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWRENT_12_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_28(_semaction_rule_12_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("NEWRENT_12_1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_28(_semaction_rule_13_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("A1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_27(_semaction_rule_14_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("B1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_23(_semaction_rule_15_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("C1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_20(_semaction_rule_16_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("A2");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_24(_semaction_rule_17_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("C2");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_26(_semaction_rule_18_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_28(_semaction_rule_19_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..164 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>, lexer:&mut bautocalclexer<'lt>) -> Result<ES<'lt>,ES<'lt>>
{
  if lexer.bump.is_some() {parser.exstate.set(lexer.bump.unwrap());}
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<ES<'lt>>::default())}
}//parse_with public function

pub fn parse_train_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>, lexer:&mut bautocalclexer<'lt>, parserpath:&str) -> Result<ES<'lt>,ES<'lt>>
{
  if lexer.bump.is_some() {parser.exstate.set(lexer.bump.unwrap());}
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<ES<'lt>>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum<'lt> {
  Enumvariant_24(A2),
  Enumvariant_11(&'lt str),
  Enumvariant_10(i64),
  Enumvariant_0(ES<'lt>),
  Enumvariant_27(A1<'lt>),
  Enumvariant_29(Vec<&'lt LC<E<'lt>>>),
  Enumvariant_20(C1<'lt>),
  Enumvariant_26(C2<'lt>),
  Enumvariant_23(B1<'lt>),
  Enumvariant_28(()),
  Enumvariant_21(E<'lt>),
  Enumvariant_2((usize,usize)),
}
impl<'lt> Default for RetTypeEnum<'lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<ES<'lt>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct bautocalclexer<'lt> {
   stk: StrTokenizer<'lt>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
   shared_state: Rc<RefCell<Bumper<'lt,()>>>,
   bump: Option<&'lt bumpalo::Bump>,
}
impl<'lt> bautocalclexer<'lt> 
{
  pub fn from_str(s:&'lt str) -> bautocalclexer<'lt>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'lt LexSource<'lt>) -> bautocalclexer<'lt>  {
    let mut st = Self::new(StrTokenizer::from_source(s));
    st.bump = s.get_bump();
    st
  }
  pub fn new(mut stk:StrTokenizer<'lt>) -> bautocalclexer<'lt> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    let shared_state = Rc::new(RefCell::new(<Bumper<'lt,()>>::default()));
    for kw in ["_WILDCARD_TOKEN_","in","let",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [] {lexnames.insert(k,v);}
    stk.set_line_comment("#");
    let bump:Option<&'lt bumpalo::Bump> = None;
    bautocalclexer {stk,keywords,lexnames,shared_state,bump,}
  }
}
impl<'lt> Tokenizer<'lt,RetTypeEnum<'lt>> for bautocalclexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,RetTypeEnum<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum<'lt>>::default()))
      },
      RawToken:: Num(n)  => Some(TerminalToken::from_raw(token,"int",RetTypeEnum::Enumvariant_10( n
))),
      RawToken:: Alphanum(x)  => Some(TerminalToken::from_raw(token,"var",RetTypeEnum::Enumvariant_11( x
))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum<'lt>>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      _ => { let _rrodb=token.0.to_staticstr(); Some(TerminalToken::from_raw(token,_rrodb,<RetTypeEnum<'lt>>::default())) },
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
   fn get_slice(&self,s:usize,l:usize) -> &str {self.stk.get_slice(s,l)}
   fn transform_wildcard(&self,t:TerminalToken<'lt,RetTypeEnum<'lt>>) -> TerminalToken<'lt,RetTypeEnum<'lt>> { TerminalToken::new(t.sym,RetTypeEnum::Enumvariant_2((self.stk.previous_position(),self.stk.current_position())),t.line,t.column) }
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>)
{
}//end of load_extras: don't change this line as it affects augmentation

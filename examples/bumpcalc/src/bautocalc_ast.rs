//Bump-allocated AST types generated by rustlr for grammar bautocalc
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_imports)]
#![allow(dead_code)]
use rustlr::{LC,Bumper};

static A1DEFAULT:A1<'static> = A1("","",&A1DEFAULT,0);
static B1DEFAULT:B1<'static> = B1("","",&A1DEFAULT);
impl<'t> Default for &'t A1<'t> { fn default() -> Self { &A1DEFAULT } }
impl<'t> Default for &'t B1<'t> { fn default() -> Self { &B1DEFAULT } }


#[derive(Debug)]
pub enum E<'lt> {
  BinaryOp(&'static str,&'lt E<'lt>,&'lt E<'lt>),
  Let(&'lt str,&'lt E<'lt>,&'lt E<'lt>),
  Neg{e:&'lt LC<E<'lt>>},
  Val(i64),
  Div{e1:&'lt LC<E<'lt>>,e2:&'lt LC<E<'lt>>},
  Var(&'lt str),
  Times(&'lt E<'lt>,&'lt LC<E<'lt>>),
  E_Nothing,
}
impl<'lt> Default for E<'lt> { fn default()->Self { E::E_Nothing } }

#[derive(Debug)]
pub enum C2<'lt> {
  Ctwo(i64,A1<'lt>),
  C2_Nothing,
}
impl<'lt> Default for C2<'lt> { fn default()->Self { C2::C2_Nothing } }

#[derive(Default,Debug)]
pub struct A2();

#[derive(Default,Debug)]
pub struct ES<'lt>(pub Vec<&'lt LC<E<'lt>>>,);

#[derive(Default,Debug)]
pub struct A1<'lt>(pub &'lt str,pub &'lt str,pub &'lt A1<'lt>,pub i64,);

#[derive(Default,Debug)]
pub struct C1<'lt>(pub A1<'lt>,pub &'lt str,pub &'lt str,pub &'lt A1<'lt>,pub E<'lt>,);

#[derive(Default,Debug)]
pub struct B1<'lt>(pub &'lt str,pub &'lt str,pub &'lt A1<'lt>,);


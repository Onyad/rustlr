//Parser generated by rustlr for grammar bcalc
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
use std::rc::Rc;
use std::cell::RefCell;
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use bumpalo::Bump;
use crate::bxprtrees::*; /* ! lines are injected verbatim into parser */
use crate::bxprtrees::Expr::*;
use rustlr::{LC,Bumper};

static SYMBOLS:[&'static str;17] = ["_WILDCARD_TOKEN_","E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

static TABLE:[u64;159] = [17180196864,60129804288,4295098369,30064836608,47244836864,8590327809,55835033600,281530811744256,281492156907520,281505041547264,281479272202241,281522221547520,281535106514944,562971428978688,562962839109632,562975724077056,562967133880320,562992903749632,844485060591616,1125921381744642,1125951446515714,1125942856581122,1125917086777346,1125925676711938,1125912791810050,1125934266646530,1407404948389888,1407392063750144,1407379179503617,1407422128390144,1407435013357568,1407430718586880,1688909990068224,1688897105100800,1688867040460800,1688879925100544,1688854156279809,1688905695297536,1688918579740675,1970350606778370,1970342016843778,1970346311811074,1970367786647554,1970337721876482,1970359196712962,1970376376582146,2251825584340992,2251834174537728,2251816994144256,2251812699373568,2251821289242624,2533279086542849,2533334920200192,2533291970592768,2533304855232512,2533322035232768,2533330625429504,2814766947565570,2814818487173122,2814797012336642,2814779832467458,2814805602271234,2814809897238530,3096284873621504,3096271988654080,3096280578850816,3096254808653824,3096229040029697,3096241924014080,3377755555561472,3377716900724736,3377729785364480,3377759850332160,3377704016805889,3377746965364736,3659178993582081,3659204762075136,3659230532272128,3659221942075392,3659191877435392,3659234827042816,3940688330096640,4222146125889538,4222159010791426,4222137535954946,4222141830922242,4222150420856834,4222167600726018,4222176190660610,4503612513058816,4503616807829504,4503642578550784,4503621102927872,4503625398026240,4785117554278402,4785087489507330,4785096079441922,4785100374409218,4785091784474626,4785126144212994,4785108964343810,5066566760857602,5066601120595970,5066592530661378,5066562465890306,5066571056349184,5066583940726786,5066575351447552,5348046032601090,5348041737633794,5348067507437570,5348037442666498,5348076097372162,5348058917502978,5348050327568386,5629525304868864,5629516714213378,5629521009770496,5629512419246082,5629533894082562,5629542484017154,5629551073951746,5911017460924418,5911026050859010,5910995986087938,5911008870989826,5911000281055234,5910991691120642,5910987396153346,6192466667831296,6192505322668032,6192496732471296,6192453784174593,6192479552471040,6192509617438720,6473971709640706,6473984594542594,6473941644869634,6473993184477186,6473980299575298,6473954529771522,6755416621514752,6755420916613120,6755412326744064,6755450982301696,6755425211711488,7036891597963264,7036921662603264,7036878714437633,7036904482603008,7036930252800000,7036934547570688,7318366574936064,7318392344608770,7318375165132800,7318370870034432,7318362280165376,7318383754674178,7318400934543362,];


fn _semaction_rule_0_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut m = if let RetTypeEnum::Enumvariant_5(_x_5)=parser.popstack().value { _x_5 } else {<i64>::default()};  Val(m) }

fn _semaction_rule_1_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut s = if let RetTypeEnum::Enumvariant_6(_x_6)=parser.popstack().value { _x_6 } else {<&'lt str>::default()};  Var(s) }

fn _semaction_rule_2_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut e2 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut e1 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()};  Plus(e1.make(parser.exstate.get()),e2.make(parser.exstate.get())) }

fn _semaction_rule_3_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut e2 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut e1 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()};  Minus(e1.make(parser.exstate.get()),e2.make(parser.exstate.get())) }

fn _semaction_rule_4_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut e2 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut e1 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()};  Times(e1.make(parser.exstate.get()),e2.make(parser.exstate.get())) }

fn _semaction_rule_5_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut e2 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut e1 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()};  Divide(e1.make(parser.exstate.get()),parser.exstate.make(parser.lc(2,e2))) }

fn _semaction_rule_6_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()};  Negative(parser.exstate.make(parser.lc(1,e))) }

fn _semaction_rule_7_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut b = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item4_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut x = if let RetTypeEnum::Enumvariant_6(_x_6)=parser.popstack().value { _x_6 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; Letexp(x,e.make(parser.exstate.get()),b.make(parser.exstate.get()))}

fn _semaction_rule_8_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()};  e }

fn _semaction_rule_9_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut n = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; 
  let bump = &parser.exstate;
  let mut v1 = Vec::new(); /* not bump-allocated */
  v1.push(bump.make(parser.lc(0,n)));
  Seq(v1)
  }

fn _semaction_rule_10_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> Expr<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; 
  if let (Seq(mut v),)=(_item0_,) { 
   v.push(parser.exstate.make(parser.lc(1,e)));
   Seq(v)
   }  else {parser.report("(Seq(mut v),)"); <Expr<'lt>>::default()} }

fn _semaction_rule_11_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>) -> () {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'lt>>::default()}; <()>::default()}

pub fn make_parser<'lt>() -> ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>
{
 let mut parser1:ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_10_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,Bumper<'lt,()>>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_1(_semaction_rule_11_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..159 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>, lexer:&mut bcalclexer<'lt>) -> Result<Expr<'lt>,Expr<'lt>>
{
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Expr<'lt>>::default())}
}//parse_with public function

pub fn parse_train_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>, lexer:&mut bcalclexer<'lt>, parserpath:&str) -> Result<Expr<'lt>,Expr<'lt>>
{
  lexer.shared_state = Rc::clone(&parser.shared_state);
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Expr<'lt>>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum<'lt> {
  Enumvariant_1(()),
  Enumvariant_2((usize,usize)),
  Enumvariant_0(Expr<'lt>),
  Enumvariant_5(i64),
  Enumvariant_6(&'lt str),
}
impl<'lt> Default for RetTypeEnum<'lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<Expr<'lt>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct bcalclexer<'lt> {
   stk: StrTokenizer<'lt>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
   shared_state: Rc<RefCell<Bumper<'lt,()>>>,
}
impl<'lt> bcalclexer<'lt> 
{
  pub fn from_str(s:&'lt str) -> bcalclexer<'lt>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'lt LexSource<'lt>) -> bcalclexer<'lt>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'lt>) -> bcalclexer<'lt> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    let shared_state = Rc::new(RefCell::new(<Bumper<'lt,()>>::default()));
    for kw in ["_WILDCARD_TOKEN_","in","let",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [] {lexnames.insert(k,v);}
    stk.set_line_comment("#");
    bcalclexer {stk,keywords,lexnames,shared_state,}
  }
}
impl<'lt> Tokenizer<'lt,RetTypeEnum<'lt>> for bcalclexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,RetTypeEnum<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum<'lt>>::default()))
      },
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"int",RetTypeEnum::Enumvariant_5(n))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"var",RetTypeEnum::Enumvariant_6(x))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum<'lt>>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<RetTypeEnum<'lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
   fn get_slice(&self,s:usize,l:usize) -> &str {self.stk.get_slice(s,l)}
   fn transform_wildcard(&self,t:TerminalToken<'lt,RetTypeEnum<'lt>>) -> TerminalToken<'lt,RetTypeEnum<'lt>> { TerminalToken::new(t.sym,RetTypeEnum::Enumvariant_2((self.stk.previous_position(),self.stk.current_position())),t.line,t.column) }
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,Bumper<'lt,()>>)
{
}//end of load_extras: don't change this line as it affects augmentation

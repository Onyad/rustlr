# Rustlr Grammar for parsing .y source files, converts grammar to Rust form

auto
lifetime 'lt

# symbol table keeps trackof terminals and nonterminals not
# defined in the yacc_decl section.
$pub use std::collections::HashSet;
$#[derive(Default,Debug)]
$pub struct symbol_table<'t> {
$  pub lexterminals : HashSet<&'t str>,
$  pub nonterminals : HashSet<&'t str>,
$  pub skip: bool,
$}

externtype symbol_table<'lt>

#lexattribute skip_set("%%","EOF")
lexconditional self.shared_state.borrow().skip ~ self.stk.skip_set("","$_RREOF_$");
lexattribute add_custom("literal",r"^'.'")
#lexattribute add_custom("decls",r"^(?m)^%\{(?s).*%\}$")
lexattribute add_custom("decls",r"^(?m)^%\{(?s)[^%\}]*%\}")
lexattribute add_custom("action",r"^\{[^\}]*\}")
valueterminal ACTION ~ &'lt str ~ Custom("action",d) ~ d
valueterminal ADDITIONALS~ &'lt str~ Skipto(d) ~ d
valueterminal RAWDECL ~ &'lt str ~ Custom("decls",d) ~ &d.trim()[2..d.len()-2]
valueterminal ID ~ &'lt str ~ Alphanum(n) ~ n
valueterminal LEXCHAR ~ &'lt str ~ Custom("literal",d)~ d[1..d.len()-1].trim()
valueterminal LEXSTR ~ &'lt str ~ Strlit(d)~ d[1..d.len()-1].trim()

lexterminal PERPERCENT %%
#lexterminal LBRACE {
#lexterminal RBRACE }
lexterminal LPAREN (
lexterminal RPAREN )
lexterminal LBRACK [
lexterminal RBRACK ]
lexterminal LANGLE <
lexterminal RANGLE >
lexterminal PERCENT %
lexterminal COLON :
lexterminal SEMICOLON ;
lexterminal COMMA ,
lexterminal BAR |
lexterminal STAR *
lexterminal PLUS +
lexterminal QUEST ?
lexterminal PERLBRACK %{
lexterminal PERRBRACK %}
lexterminal AT @
lexterminal DOLLAR $
lexterminal TWODOLLAR $$
lexterminal TYPE typeof
terminals start token
nonterminals yacc_decl Yacc grammar_rules rhs_symbol rhs label tag
nonterminal primary
nonterminal rhsunit
resynch SEMICOLON BAR
topsym Yacc

primary ==> RAWDECL?:raw_declarations
         yacc_decl+:yacc_declarations
         PERPERCENT
         grammar_rules+:rules
         { parser.shared_state.borrow_mut().skip = true; ... }
        <==
Yacc --> primary (PERPERCENT ADDITIONALS)?

#rawdecls --> RAWDECL
yacc_decl:terminals --> PERCENT token ID+
yacc_decl:lexterminal --> PERCENT token ID LEXSTR
yacc_decl:topsym --> PERCENT start ID
yacc_decl:nonterminal --> PERCENT TYPE tag? ID+
tag --> LANGLE ID RANGLE

rhs_symbol:ID --> ID (COLON label)?
rhs_symbol:LEXCHAR ==> LEXCHAR:t {
  parser.shared_state.borrow_mut().lexterminals.insert(t);
  ... } <==
rhs_symbol:LEXSTR ==> LEXSTR:t {
  parser.shared_state.borrow_mut().lexterminals.insert(t);
  ... } <==

label:simple --> ID
label:boxed --> LBRACK ID RBRACK
label:parened --> LPAREN ID<COMMA+> COMMA? RPAREN

rhsunit --> rhs_symbol ACTION?
rhs --> ACTION? rhsunit*

grammar_rules ==> ID:lhs COLON rhs<BAR+>:rhsides SEMICOLON {
  parser.shared_state.borrow_mut().nonterminals.insert(lhs);
  ... } <==

EOF

#valueterminal declarations~ &'lt str~ Custom("decls",d) &d[2..d.len()-2]

println!("SHARED STATE: {}",*self.shared_state.borrow());
println!("GOT TOKEN: {:?}",&token);

//Parser generated by rustlr for grammar lbacalc

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use crate::exprtrees::*;
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

const SYMBOLS:[&'static str;16] = ["E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

const TABLE:[u64;177] = [131073,42949935104,25770131456,12884967424,4295360513,51540066304,55834771456,281526516776960,281500746842112,281517926645760,281487861678080,281530811482112,281474977234945,562988608782336,562967133880320,562962839044096,562971429044224,562958544207872,844433520132098,844472174837762,844442110066690,844446405033986,844437815099394,844459289935874,844454994968578,844463584903170,1125899907760129,1125912791810048,1125951446908928,1125925676974080,1125942856777728,1125955741614080,1407387768520704,1407430718324736,1407374884536321,1407426423619584,1407417833488384,1407400653684736,1688849861312513,1688914284773379,1688901400330240,1688905695035392,1688892810199040,1688862745231360,1688875630395392,1970372081614850,1970354901745666,1970363491680258,1970333426909186,1970359196712962,1970337721876482,1970346311811074,1970342016843778,2251829878915074,2251812699045890,2251821289308160,2251808404078594,2251838468849666,2251816994144256,2251847058784258,2251834173882370,2533274791510017,2533317740331008,2533300560527360,2533287675363328,2533326330462208,2533330625167360,2814762652598274,2814814192205826,2814775537500162,2814801307303938,2814805602271234,2814792717369346,3096276283883520,3096250513948672,3096280578588672,3096267693752320,3096237628784640,3096224744996865,3377712605495296,3377725490659328,3377755555299328,3377699721773057,3377751260594176,3377742670462976,3659174698549249,3659226237304832,3659217647173632,3659200467369984,3659230532009984,3659187582205952,3940684035063808,3940666854408192,3940662559571968,3940658264735744,3940671149572096,4222133241446400,4222141831118848,4222154716872704,4222137536282624,4222146126282752,4503616807829504,4503638283583488,4503612512993280,4503621102993408,4503608218157056,4785091784343554,4785113259180034,4785096079310850,4785087489376258,4785108964212738,4785083194408962,4785104669245442,4785121849114626,5066558170988546,5066579645825026,5066562465955842,5066583940792322,5066596825694210,5066571056414720,5066588235759618,5066566761250816,5348058917568514,5348054622601218,5348046032666626,5348063212535810,5348071802470402,5348033147764738,5348041737699330,5348037442732034,5629516714672128,5629533894148098,5629546779049986,5629512419311618,5629508124344322,5629529599180802,5629521009836032,5629538189115394,5911000281055232,5910987395891200,5910974512496641,5911026050990080,5911017460858880,5911030345695232,6192496732798978,6192483847897090,6192462373060610,6192458078093314,6192488142864386,6192466668027906,6192479552929794,6192470962995202,6473976004608002,6473967414673410,6473950234804226,6473988889509890,6473980299575298,6473937349902338,6755408031842304,6755412326678528,6755446687334400,6755416621514752,6755420916678656,7036930252537856,7036917367701504,7036874419470337,7036925957832704,7036900187897856,7036887302733824,7318362280099840,7318366574936064,7318388049313794,7318379459379202,7318370870099968,7318396639248386,7318383754346498,7318357985263616,];

pub fn make_parser<'src_lt>() -> ZCParser<Expr<'src_lt>,i64>
{
 let mut parser1:ZCParser<Expr<'src_lt>,i64> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack();  m.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack(); 
  if let (Var(v),)=(&mut s.value,) {  s.value }  else {parser.bad_pattern("(Var(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut e = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { Letexp(x,e.lbox(),b.lbox())}  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Plus(e1.lbox(), e2.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Minus(e1.lbox(), parser.lbx(2,e2.value))};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Divide(e1.lbox(), e2.lbox())};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Times(e1.lbox(), e2.lbox())};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  Negative(e.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut n = parser.popstack();  Seq(vec![n.lbox()]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut v),)=(_item0_.value,) { 
   v.push(e.lbox());
   Seq(v)
   }  else {parser.bad_pattern("(Seq(mut v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Expr<'src_lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..177 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras<'src_lt>(parser:&mut ZCParser<Expr<'src_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

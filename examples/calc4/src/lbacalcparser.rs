//Parser generated by rustlr for grammar lbacalc
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
use std::any::Any;
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action,LBox,lbdown,lbup,lbget,unbox};
use crate::exprtrees::*;
use crate::exprtrees::Expr::*;

const SYMBOLS:[&'static str;13] = ["E","ES","+","-","*","/","(",")",";","int","var","START","EOF"];

const TABLE:[u64;115] = [12885032960,65537,42949935104,25770000384,4295360513,38655033344,281487862202368,281496452071424,281483567366144,281492157235200,281509336907776,562949954207745,562992903356416,562962838454272,562975723421696,562988608454656,844450700132352,844463585165312,844467880067072,844424930983937,844437815164928,1125917086777346,1125912791810050,1125921381744642,1125908496842754,1125934266646530,1125929971679234,1407392063422466,1407396358389762,1407387768455170,1407383473487874,1407409243291650,1407404948324354,1688862745296896,1688901399871491,1688849861181441,1688875630264320,1688892810199040,1688888515297280,1970367787171842,1970337722400770,1970363492204546,1970376377106434,1970350607302658,2251838468718592,2251799814668289,2251812698718208,2251842763620352,2251825583685632,2533317740331008,2533313445429248,2533287675428864,2533274791444481,2533300560396288,2814775537106944,2814788422139904,2814762652139520,2814792717041664,2814749768220673,3096224744996865,3096267693752320,3096250513817600,3096237628850176,3096263398850560,3377734080659458,3377729785692162,3377708310855682,3377712605822978,3377721195888640,3377716901052416,3659191877763072,3659204763254784,3659183287894016,3659196172599296,3659187582730240,3940658264604672,3940666854473728,3940662559440896,3940671149309952,3940684034998272,4222154715693058,4222141830791170,4222146125758466,4222133240856578,4222137535823874,4222159010660354,4503633987305474,4503612512468994,4503608217501698,4503629692338178,4503616807895040,4503621102731264,4785096079245314,4785108964147202,4785087489310722,4785091784278018,4785083194343426,4785104669179906,5066571056152576,5066558170857474,5066579645693954,5066566761316352,5066583940661250,5066562465824770,5348058917699586,5348046032797698,5348037442863106,5348033147895810,5348041737830402,5348054622732290,5629512419704834,5629525304606722,5629542484475906,5629551074410498,5629538189508610,];

fn _semaction_for_0_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut m = lbdown!(parser.popstack().value,i64);  Val(unbox!(m)) }
fn _semaction_for_1_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut v = lbdown!(parser.popstack().value,&'parser_lt str);  Var(unbox!(v)) }
fn _semaction_for_2_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut e2 = lbdown!(parser.popstack().value,Expr<'parser_lt>); let mut _item1_ = parser.popstack().value; let mut e1 = lbdown!(parser.popstack().value,Expr<'parser_lt>);  Plus(e1,e2) }
fn _semaction_for_3_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut e2 = lbdown!(parser.popstack().value,Expr<'parser_lt>); let mut _item1_ = parser.popstack().value; let mut e1 = lbdown!(parser.popstack().value,Expr<'parser_lt>);  Minus(e1,e2) }
fn _semaction_for_4_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut e2 = lbdown!(parser.popstack().value,Expr<'parser_lt>); let mut _item1_ = parser.popstack().value; let mut e1 = lbdown!(parser.popstack().value,Expr<'parser_lt>);  Divide(e1,e2) }
fn _semaction_for_5_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut e2 = lbdown!(parser.popstack().value,Expr<'parser_lt>); let mut _item1_ = parser.popstack().value; let mut e1 = lbdown!(parser.popstack().value,Expr<'parser_lt>);  Times(e1,e2) }
fn _semaction_for_6_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut e = lbdown!(parser.popstack().value,Expr<'parser_lt>); let mut _item0_ = parser.popstack().value;  Negative(e) }
fn _semaction_for_7_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Expr<'parser_lt> {
let mut _item2_ = parser.popstack().value; let mut e = lbdown!(parser.popstack().value,Expr<'parser_lt>); let mut _item0_ = parser.popstack().value;  *e.exp }
fn _semaction_for_8_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Vec<LBox<Expr<'parser_lt>>> {
let mut _item1_ = parser.popstack().value; let mut n = lbdown!(parser.popstack().value,Expr<'parser_lt>);  vec![n] }
fn _semaction_for_9_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> Vec<LBox<Expr<'parser_lt>>> {
let mut _item2_ = parser.popstack().value; let mut e = lbdown!(parser.popstack().value,Expr<'parser_lt>); let mut v = lbdown!(parser.popstack().value,Vec<LBox<Expr<'parser_lt>>>); 
   v.push(e);
   unbox!(v)
   }
fn _semaction_for_10_<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>) -> LBox<dyn Any+'parser_lt> {
let mut _item0_ = lbdown!(parser.popstack().value,Vec<LBox<Expr<'parser_lt>>>); <LBox<dyn Any+'parser_lt>>::default()}

pub fn create_parser<'parser_lt>() -> ZCParser<LBox<dyn Any+'parser_lt>,i64>
{
 let mut parser1:ZCParser<LBox<dyn Any+'parser_lt>,i64> = ZCParser::new(11,21);
 let mut rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_0_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_1_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_2_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_3_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_4_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_5_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_6_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_7_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_8_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  lbup!( LBox::new(_semaction_for_9_(parser),parser.linenum,parser.column)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<LBox<dyn Any+'parser_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{  _semaction_for_10_(parser) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..115 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras<'parser_lt>(parser:&mut ZCParser<LBox<dyn Any+'parser_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

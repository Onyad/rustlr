//Parser generated by rustlr for grammar calc4

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use crate::exprtrees::*; /* ! lines are injected verbatim into parser */
use crate::exprtrees::Expr::*;
use rustlr::{LBox};

static SYMBOLS:[&'static str;16] = ["E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

static TABLE:[u64;177] = [51540066304,4295163905,55834705920,327681,42949935104,25769869312,12885295104,281526516776960,281517926645760,281474977234945,281530811416576,281487862005760,281500746579968,562988608192514,562962838388738,562984313225218,562967133356034,562980018257922,562958543421442,562971428323330,562997198127106,844476470198272,844424930721793,844437815427072,844480764837888,844489354641411,844450700001280,844467880067072,1125951446908928,1125925676711936,1125942856777728,1125899907497985,1125955741548544,1125912792137728,1407396359110656,1407392064274432,1407387769438208,1407383474274304,1407413539176448,1688875630133248,1688892810199040,1688862745559040,1688901400330240,1688905694969856,1688849861312513,1970354901745666,1970342016843778,1970346311811074,1970337721876482,1970363491680258,1970372081614850,1970333426909186,1970359196712962,2251829879570432,2251812699570176,2251821289242624,2251816994406400,2251808404406272,2533291971117056,2533287676280832,2533313446281216,2533283381116928,2533296265953280,2814771242663936,2814784128090112,2814766947827712,2814762652991488,2814758357827584,3096280578523136,3096250513686528,3096276283883520,3096267693752320,3096237629112320,3096224745127937,3377725490397184,3377712605822976,3377751260594176,3377755555233792,3377699721904129,3377742670462976,3659230531944448,3659187582533632,3659174698680321,3659226237304832,3659200467107840,3659217647173632,3940705509113858,3940701214146562,3940692624211970,3940714099048450,3940675444342786,3940662559440898,4222150420529152,4222124652167169,4222167600594944,4222137535954944,4222180485365760,4222176190726144,4503612512665602,4503629692534786,4503638282469378,4503633987502082,4503616808091648,4503621102927872,4503608217698306,4503646872403970,4785108964278274,4785083194474498,4785087489441794,4785096079376386,4785091784409090,4785113259245570,4785104669310978,4785121849180162,5066601121054722,5066592531120130,5066614005956610,5066562466349058,5066575351250946,5066605416022018,5348080392208384,5348037442797568,5348076097568768,5348024559075329,5348050327371776,5348067507437568,5629521009311746,5629538189180930,5629546779115522,5629529599246338,5629508124409858,5629516714344450,5629533894213634,5629512419377154,5910983100989442,5911021755695106,5911013165760514,5911008870793218,5910987395956738,5910991691644928,5910995986481152,5911004575825922,6192470962798594,6192483847700482,6192466667831298,6192458077896706,6192462372864002,6192479552733186,6192488142667778,6192496732602370,6473937349443586,6473954529312770,6473941645066240,6473963119247362,6473945939902464,6473933054476290,6473971709181954,6473958824280066,6755408031776768,6755446687334400,6755420916613120,6755412326940672,6755416621776896,7036887303061504,7036925957832704,7036874419470337,7036917367701504,7036900187635712,7036930252472320,7318366575198208,7318383754739714,7318370870034432,7318388049707010,7318396639641602,7318362280361984,7318357985198080,7318379459772418,];

pub fn make_parser<'src_lt>() -> ZCParser<Expr<'src_lt>,i64>
{
 let mut parser1:ZCParser<Expr<'src_lt>,i64> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack();  m.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack();  s.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Plus(e1.lbox(),parser.lbx(2,e2.value)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack().lbox(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack().lbox();  Minus(e1,e2)};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack().lbox(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack().lbox();  Divide(e1,e2) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack().lbox(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack().lbox();  Times(e1,e2) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e = parser.popstack().lbox(); let mut _item0_ = parser.popstack();  Negative(e) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack().lbox(); let mut _item4_ = parser.popstack(); let mut e = parser.popstack().lbox(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { Letexp(x,e,b)}  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut n = parser.popstack().lbox();  Seq(vec![n]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack().lbox(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut v),)=(_item0_.value,) { 
   v.push(e);
   Seq(v)
   }  else {parser.bad_pattern("(Seq(mut v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Expr<'src_lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..177 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser


// Lexical Scanner using RawToken and StrTokenizer
pub struct calc4lexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> calc4lexer<'t> 
{
  pub fn from_str(s:&'t str) -> calc4lexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> calc4lexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> calc4lexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["let","in",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    stk.set_line_comment("#");
    calc4lexer {stk,keywords}
  }
}
impl<'src_lt> Tokenizer<'src_lt,Expr<'src_lt>> for calc4lexer<'src_lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'src_lt,Expr<'src_lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<Expr<'src_lt>>::default())),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"int",Val(n))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"var",Var(x))),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<Expr<'src_lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<Expr<'src_lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<Expr<'src_lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
}//impl Tokenizer

fn load_extras<'src_lt>(parser:&mut ZCParser<Expr<'src_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

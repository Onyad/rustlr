//Parser generated by rustlr for grammar calc4

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use crate::exprtrees::*; /* ! lines are injected verbatim into parser */
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

const SYMBOLS:[&'static str;16] = ["E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

const TABLE:[u64;177] = [55834836992,51539673088,42950131712,4295163905,327681,25769934848,12885295104,281496451547138,281522221350914,281487861612546,281483566645250,281505041481730,281509336449026,281492156579842,281513631416322,563005788258304,563001493094400,562962838716416,562975723356160,562949953945601,562992903553024,844450700066816,844437815427072,844489354641411,844424930721793,844467880263680,844480764968960,844476469805056,1125947151548418,1125938561613826,1125929971679234,1125934266646530,1125912791810050,1125908496842754,1125921381744642,1125917086777346,1407383474339840,1407392064143360,1407387769241600,1407413538914304,1407396359307264,1688862745559040,1688892810395648,1688905695100928,1688875630198784,1688901399937024,1688849861246977,1970324838023169,1970350606909440,1970367787106304,1970376376647680,1970337722269696,1970380671811584,2251821289439232,2251829879570432,2251808404471808,2251812699373568,2251816994275328,2533283381182464,2533287676084224,2533296266149888,2533291970985984,2533313446281216,2814775537500162,2814814192205826,2814762652598274,2814792717369346,2814805602271234,2814801307303938,3096267693948928,3096237629112320,3096250513752064,3096280578654208,3096224745062401,3096276283490304,3377699721838593,3377751260200960,3377742670659584,3377725490462720,3377712605822976,3377755555364864,3659217647370240,3659230532075520,3659187582533632,3659174698614785,3659200467173376,3659226236911616,3940649675390977,3940705508786176,3940662559244288,3940675443884032,3940701213622272,3940692624080896,4222137536020482,4222141831249920,4222159010856962,4222163305824258,4222154715889666,4222171895758850,4222146126413824,4222133241053186,4503608218157056,4503633988616192,4503621103124480,4503612513058816,4503616807960576,4785087489507330,4785091784474626,4785083194540034,4785096079441922,4785121849245698,4785104669376514,4785113259311106,4785108964343810,5066592531120130,5066614005956610,5066562466349058,5066575351250946,5066601121054722,5066605416022018,5348071802535938,5348054622666754,5348033147830274,5348046032732162,5348063212601346,5348041737764866,5348037442797570,5348058917634050,5629521009967104,5629529599246338,5629538189180930,5629533894213634,5629508124409858,5629512419377154,5629516714803200,5629546779115522,5910991691513856,5911004575891458,5911008870858754,5910995986677760,5911013165826050,5910983101054978,5910987396022274,5911021755760642,6192488142667778,6192483847700482,6192466667831298,6192462372864002,6192479552733186,6192470962798594,6192458077896706,6192496732602370,6473924465917953,6473980299182080,6473967414476800,6473937349640192,6473976004018176,6473950234279936,6755446687334400,6755416621645824,6755412326744064,6755408031842304,6755420916809728,7036887303061504,7036925957439488,7036874419470337,7036930252603392,7036900187701248,7036917367898112,7318370870231040,7318366575067136,7318379459379202,7318383754346498,7318357985263616,7318362280165376,7318388049313794,7318396639248386,];

pub fn make_parser<'src_lt>() -> ZCParser<Expr<'src_lt>,i64>
{
 let mut parser1:ZCParser<Expr<'src_lt>,i64> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack();  m.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack(); 
  if let (Var(v),)=(&mut s.value,) {  s.value }  else {parser.bad_pattern("(Var(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut e = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { Letexp(x,e.lbox(),b.lbox())}  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Plus(e1.lbox(), e2.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Minus(e1.lbox(), parser.lbx(2,e2.value))};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Divide(e1.lbox(), e2.lbox())};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Times(e1.lbox(), e2.lbox())};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  Negative(e.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut n = parser.popstack();  Seq(vec![n.lbox()]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut v),)=(_item0_.value,) { 
   v.push(e.lbox());
   Seq(v)
   }  else {parser.bad_pattern("(Seq(mut v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Expr<'src_lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..177 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras<'src_lt>(parser:&mut ZCParser<Expr<'src_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

//Parser generated by rustlr for grammar calc4

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use crate::exprtrees::*; /* ! lines are injected verbatim into parser */
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

const SYMBOLS:[&'static str;16] = ["E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

const TABLE:[u64;177] = [12885360640,51539738624,42950066176,65537,55834836992,4295294977,25770000384,281513632006144,281496452202496,281492157366272,281487862136832,281483567366144,562984313159682,562967133290498,562958543355906,562962838323202,562997198061570,562980018192386,562988608126978,562971428257794,844450700132352,844476469870592,844467880198144,844437815492608,844424930983937,844480764968960,1125938561613826,1125917086777346,1125934266646530,1125921381744642,1125929971679234,1125947151548418,1125908496842754,1125912791810050,1407400653553664,1407430718390272,1407417833619456,1407439308062723,1407426423291904,1407374884470785,1407387768913920,1688862745624576,1688849861246977,1688892810330112,1688905695100928,1688875630264320,1688901400002560,1970380671811584,1970376376713216,1970324838023169,1970350606974976,1970337722335232,1970367787040768,2251851353423872,2251825583685632,2251842763751424,2251855648522240,2251812699045888,2251799814799361,2533300560789506,2533326330593282,2533339215495170,2533330625560578,2533287675887618,2533317740658690,2814775537106944,2814792717172736,2814805601943552,2814762652467200,2814801306845184,2814749768286209,3096237629177856,3096267693883392,3096224745062401,3096250513817600,3096276283555840,3096280578654208,3377742670594048,3377725490528256,3377712605888512,3377699721838593,3377755555364864,3377751260266496,3659204763385856,3659183287894016,3659196172730368,3659187582664704,3659191877894144,3940662559375360,3940666854604800,3940671149441024,3940658264604672,3940688330096640,4222137536086016,4222146126151680,4222141831315456,4222133241315328,4222159011905536,4503638282534914,4503621102862336,4503646872469506,4503608217763842,4503612512731138,4503633987567618,4503616808026112,4503629692600322,4785091784736768,4785104669114370,4785121848983554,4785087489245186,4785083194277890,4785113259048962,4785108964081666,4785096079572992,5066558171054082,5066571055955970,5066583940857858,5066596825759746,5066562466021378,5066566760988674,5066579645890562,5066588235825154,5348037442600962,5348058917437442,5348033147633666,5348071802339330,5348041738158080,5348054622470146,5348063212404738,5348046032994304,5629546779246594,5629529599377410,5629538189312002,5629516714475522,5629533894344706,5629508124540930,5629512419508226,5629521009442818,5911013166153730,5910991691317250,5911004576219138,5910987396349954,5910995986284546,5911021756088322,5910983101382658,5911008871186434,6192501027897346,6192492437962754,6192462373191682,6192475258093570,6192505322864642,6192513912799234,6473937349705728,6473976004083712,6473967414411264,6473924465917953,6473980299182080,6473950234345472,6755420916547584,6755446687334400,6755416621711360,6755408031711232,6755412326481920,7036874419470337,7036887303127040,7036925957505024,7036930252603392,7036917367832576,7036900187766784,7318379459379202,7318388049313794,7318370869968896,7318362279903232,7318383754346498,7318396639248386,7318357985132544,7318366575132672,];

pub fn make_parser<'src_lt>() -> ZCParser<Expr<'src_lt>,i64>
{
 let mut parser1:ZCParser<Expr<'src_lt>,i64> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack();  m.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack(); 
  if let (Var(v),)=(&mut s.value,) {  s.value }  else {parser.bad_pattern("(Var(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut e = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { Letexp(x,e.lbox(),b.lbox())}  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Plus(e1.lbox(), e2.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Minus(e1.lbox(), parser.lbx(2,e2.value))};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Divide(e1.lbox(), e2.lbox())};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Times(e1.lbox(), e2.lbox())};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  Negative(e.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut n = parser.popstack();  Seq(vec![n.lbox()]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut v),)=(_item0_.value,) { 
   v.push(e.lbox());
   Seq(v)
   }  else {parser.bad_pattern("(Seq(mut v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Expr<'src_lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..177 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras<'src_lt>(parser:&mut ZCParser<Expr<'src_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

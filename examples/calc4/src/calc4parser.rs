//Parser generated by rustlr for grammar calc4

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use crate::exprtrees::*; /* ! lines are injected verbatim into parser */
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

static SYMBOLS:[&'static str;16] = ["E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

static TABLE:[u64;177] = [12885164032,4295163905,25769869312,42950000640,55834968064,131073,51540066304,281526516776960,281500746579968,281517926711296,281530811678720,281474977234945,281487861874688,562962839109632,562967134142464,562988608847872,562971428847616,562958544011264,844476470198272,844489354641411,844480765100032,844467880132608,844437815296000,844450700001280,844424931049473,1125942856843264,1125912792006656,1125899907825665,1125951446908928,1125955741810688,1125925676711936,1407374884601857,1407430718521344,1407400653422592,1407387768717312,1407426423619584,1407417833553920,1688862745231362,1688884220067842,1688879925100546,1688867040198658,1688871335165954,1688888515035138,1688897104969730,1688858450264066,1970372081614850,1970346311811074,1970342016843778,1970363491680258,1970333426909186,1970337721876482,1970354901745666,1970359196712962,2251816994406400,2251821289111552,2251829879570432,2251808404275200,2251812699373568,2533330625363968,2533274791575553,2533326330462208,2533317740396544,2533300560265216,2533287675559936,2814805602074624,2814775536975872,2814801307172864,2814792717107200,2814749768351745,2814762652270592,3096280578981890,3096237629308930,3096289168916482,3096267694080002,3096276284014594,3096250514210818,3377699721838593,3377742670528512,3377712605691904,3377751260594176,3377755555495936,3377725490397184,3659230532206592,3659226237304832,3659217647239168,3659187582402560,3659174698614785,3659200467107840,3940671149375488,3940662559637504,3940666854670336,3940658264539136,3940688330096640,4222146126086144,4222159010856962,4222171895758850,4222154715889666,4222137536020482,4222141831380992,4222133241053186,4222163305824258,4503633988616192,4503616808091648,4503621102796800,4503608217960448,4503612513058816,4785108964343810,4785083194540034,4785121849245698,4785087489507330,4785104669376514,4785091784474626,4785096079441922,4785113259311106,5066596825759746,5066558171054082,5066579645890562,5066562466021378,5066583940857858,5066566760988674,5066571055955970,5066588235825154,5348063212404738,5348058917437442,5348054622470146,5348046032928768,5348037442600962,5348033147633666,5348041738223616,5348071802339330,5629533894213634,5629521009639424,5629516714934272,5629508124409858,5629538189180930,5629546779115522,5629529599246338,5629512419377154,5910991691186178,5911013166022658,5911008871055362,5910987396218882,5910995986153474,5911004576088066,5911021755957250,5910983101251586,6192505322864642,6192462373191682,6192492437962754,6192513912799234,6192475258093570,6192501027897346,6473967414345728,6473980299313152,6473950234214400,6473937349509120,6473924465917953,6473976004411392,6755446687334400,6755416621776896,6755412326744064,6755420916482048,6755408031645696,7036917367767040,7036874419470337,7036887302930432,7036900187635712,7036930252734464,7036925957832704,7318396639248386,7318366575198208,7318388049313794,7318370869903360,7318383754346498,7318362280165376,7318379459379202,7318357985067008,];

pub fn make_parser<'src_lt>() -> ZCParser<Expr<'src_lt>,i64>
{
 let mut parser1:ZCParser<Expr<'src_lt>,i64> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack();  m.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack(); 
  if let (Var(v),)=(&mut s.value,) {  s.value }  else {parser.bad_pattern("(Var(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut e = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { Letexp(x,e.lbox(),b.lbox())}  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack().lbox(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack().lbox();  Plus(e1,e2) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack();  Minus(e1.lbox(), parser.lbx(2,e2.value))};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack().lbox(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack().lbox();  Divide(e1,e2) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e2 = parser.popstack().lbox(); let mut _item1_ = parser.popstack(); let mut e1 = parser.popstack().lbox();  Times(e1,e2) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut e = parser.popstack().lbox(); let mut _item0_ = parser.popstack();  Negative(e) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut n = parser.popstack().lbox();  Seq(vec![n]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack().lbox(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut v),)=(_item0_.value,) { 
   v.push(e);
   Seq(v)
   }  else {parser.bad_pattern("(Seq(mut v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr<'src_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Expr<'src_lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..177 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser


// Lexical Scanner using RawToken and StrTokenizer
pub struct calc4lexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> calc4lexer<'t> 
{
  pub fn from_str(s:&'t str) -> calc4lexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> calc4lexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> calc4lexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["let","in",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    stk.set_line_comment("#");
    calc4lexer {stk,keywords}
  }
}
impl<'src_lt> Tokenizer<'src_lt,Expr<'src_lt>> for calc4lexer<'src_lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'src_lt,Expr<'src_lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<Expr<'src_lt>>::default())),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"int",Val(n))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"var",Var(x))),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<Expr<'src_lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<Expr<'src_lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<Expr<'src_lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
}//impl Tokenizer

fn load_extras<'src_lt>(parser:&mut ZCParser<Expr<'src_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

//Parser generated by rustlr

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use crate::exprtrees::*;
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

const SYMBOLS:[&'static str;12] = ["E","ES","+","-","*","/","(",")",";","int","START","EOF"];

const TABLE:[u64;99] = [65537,38655033344,4295163905,12885164032,25769934848,281492157104128,281509337104384,281483567104000,281487862202368,281496451940352,562975723356160,562949954142209,562962838585344,562988608454656,844450700066816,844437815296000,844472174772227,844424930918401,844463585165312,1125899907694593,1125912792006656,1125925676777472,1125938561875968,1407404948324354,1407396358389762,1407409243291650,1407387768455170,1407383473487874,1407392063422466,1688849861181441,1688875630198784,1688862745427968,1688888515297280,1970350606909440,1970324837957633,1970337722138624,1970363492007936,2251799814733825,2251838468718592,2251812698849280,2251825583620096,2533313445429248,2533300560330752,2533274791510017,2533287675559936,2814788422270978,2814797012205570,2814762652467202,2814775537369090,3096233334210560,3096241924210688,3096246219046912,3096237629308928,3096254809767936,3377712606019584,3377716900921344,3377708310921216,3377721195757568,3377734081511424,3659191877632000,3659187582468098,3659183287500802,3659204762337282,3659209057304578,3659196172468224,3940662559047682,3940671148982274,3940658264080386,3940666854014978,3940684033884162,3940679738916866,4222146125889536,4222133240659970,4222137535627266,4222159010463746,4222154715496450,4222141831053312,4503612512534530,4503608217567234,4503633987371010,4503629692403714,4503616807501826,4503621102469122,4785104668983298,4785096079310848,4785083194146818,4785108963950594,4785087489114114,4785091784474624,5066562466086914,5066571056021506,5066579645956098,5066558171119618,5066566761054210,5066583940923394,5348071802667010,5348063212732418,5348050327830530,5348037442928642,];

pub fn new_parser<'parser_lt>(tokenizer:&'parser_lt mut dyn Tokenizer<'parser_lt,Expr>) -> ZCParser<'parser_lt,Expr,Expr>
{
 let mut parser1:ZCParser<Expr,Expr> = ZCParser::new(10,20,tokenizer);
 let mut rule = ZCRProduction::<Expr,Expr>::new_skeleton("start");
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let _m_ = parser.popstack(); 
  if let (m,)=(_m_.value,) { m /* should be a Val(n) */}  else {parser.bad_pattern("(m,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let _e2_ = parser.popstack(); let _item1_ = parser.popstack(); let _e1_ = parser.popstack(); 
  if let (e2,e1,)=(_e2_.value,_e1_.value,) {  Plus(makelbox!(_e1_,e1),makelbox!(_e2_,e2)) }  else {parser.bad_pattern("(e2,e1,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let _e2_ = parser.popstack(); let _item1_ = parser.popstack(); let _e1_ = parser.popstack(); 
  if let (e2,e1,)=(_e2_.value,_e1_.value,) {  Minus(makelbox!(_e1_,e1),makelbox!(_e2_,e2)) }  else {parser.bad_pattern("(e2,e1,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let _e2_ = parser.popstack(); let _item1_ = parser.popstack(); let _e1_ = parser.popstack(); 
  if let (e2,e1,)=(_e2_.value,_e1_.value,) {  Divide(makelbox!(_e1_,e1),makelbox!(_e2_,e2)) }  else {parser.bad_pattern("(e2,e1,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let _e2_ = parser.popstack(); let _item1_ = parser.popstack(); let _e1_ = parser.popstack(); 
  if let (e2,e1,)=(_e2_.value,_e1_.value,) {  Times(makelbox!(_e1_,e1),makelbox!(_e2_,e2)) }  else {parser.bad_pattern("(e2,e1,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let _e_ = parser.popstack(); let _item0_ = parser.popstack(); 
  if let (e,)=(_e_.value,) {  Negative(makelbox!(_e_,e)) }  else {parser.bad_pattern("(e,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ let _item2_ = parser.popstack(); let _e_ = parser.popstack(); let _item0_ = parser.popstack(); 
  if let (e,)=(_e_.value,) {  e }  else {parser.bad_pattern("(e,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let _item1_ = parser.popstack(); let _n_ = parser.popstack(); 
  if let (n,)=(_n_.value,) {  Seq(vec![parser.lb(n)]) }  else {parser.bad_pattern("(n,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ let _item2_ = parser.popstack(); let _e_ = parser.popstack(); let _item0_ = parser.popstack(); 
  if let (e,Seq(mut v),)=(_e_.value,_item0_.value,) { 
   v.push( makelbox!(_e_,e) );
   Seq(v)
 }  else {parser.bad_pattern("(e,Seq(mut v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Expr,Expr>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let _item0_ = parser.popstack(); <Expr>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..99 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras<'parser_lt>(parser:&'parser_lt mut ZCParser<Expr,Expr>)
{
}//end of load_extras: don't change this line as it affects augmentation

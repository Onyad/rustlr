//Parser generated by rustlr for grammar calcenum
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
use std::any::Any;
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use crate::exprtrees::*; /* ! lines are injected verbatim into parser */
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

static SYMBOLS:[&'static str;16] = ["E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

static TABLE:[u64;177] = [55834902528,51539673088,42950131712,12885164032,131073,25770196992,4295163905,281496451547138,281505041481730,281509336449026,281492156579842,281522221350914,281513631416322,281487861612546,281483566645250,562971428782080,562988608782336,562962839044096,562958544142336,562967133880320,844450700328960,844476469805056,844424930983937,844437815296000,844480765034496,844467880263680,844489354641411,1125899907760129,1125925677039616,1125955741745152,1125951446515712,1125912792006656,1125942856974336,1407383473553410,1407392063488002,1407413538324482,1407387768520706,1407422128259074,1407409243357186,1407404948389890,1407396358455298,1688892810395648,1688875630460928,1688862745427968,1688901399937024,1688849861246977,1688905695166464,1970324838023169,1970380671877120,1970367787106304,1970350607171584,1970376376647680,1970337722138624,2251855648587776,2251842763816960,2251799814799361,2251851353358336,2251825583882240,2251812698849280,2533300560592896,2533326330068992,2533317740527616,2533274791575553,2533330625298432,2533287675559936,2814805602271234,2814762652598274,2814775537500162,2814814192205826,2814792717369346,2814801307303938,3096237628981248,3096267693948928,3096276283490304,3096250514014208,3096280578719744,3096224745062401,3377742670659584,3377699721838593,3377712605691904,3377751260200960,3377725490724864,3377755555430400,3659187582861312,3659183287959552,3659213353320448,3659191877697536,3659196172599296,3940662559309826,3940684034146306,3940679739179010,3940696919048194,3940688329113602,3940658264342530,3940671149309952,3940666854408192,4222137536282624,4222133241380864,4222141831118848,4222146126020608,4222154716872704,4503633988616192,4503612512993280,4503621102731264,4503616807829504,4503608218091520,4785108964147202,4785083194343426,4785113259114498,4785087489310722,4785121849049090,4785096079245314,4785091784278018,4785104669179906,5066583940923394,5066579645956098,5066588235890690,5066558171119618,5066562466086914,5066596825825282,5066566761054210,5066571056021506,5348063212470274,5348046032863232,5348033147699202,5348071802404866,5348054622535682,5348037442666498,5348058917502978,5348041737961472,5629529599180802,5629508124344322,5629521009573888,5629516714672128,5629512419311618,5629546779049986,5629533894148098,5629538189115394,5911000281382914,5911038936088578,5911017461252098,5911030346153986,5910987396481026,5911026051186690,6192488142864386,6192479552929794,6192483847897090,6192466668027906,6192462373060610,6192496732798978,6192458078093314,6192470962995202,6473937349509120,6473967414476800,6473950234542080,6473924465917953,6473980299247616,6473976004018176,6755412326678528,6755408031776768,6755420916416512,6755446687334400,6755416621514752,7036925957439488,7036900187963392,7036874419470337,7036930252668928,7036887302930432,7036917367898112,7318379459379202,7318370869837824,7318396639248386,7318362280099840,7318388049313794,7318357985198080,7318366574936064,7318383754346498,];


fn _semaction_rule_0_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut m = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<i64>::default()};  Val(m) }

fn _semaction_rule_1_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut s = if let RetTypeEnum::Enumvariant_2(_x_2)=parser.popstack().value { _x_2 } else {<&'src_lt str>::default()};  Var(s) }

fn _semaction_rule_2_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _b_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut b = parser.lbx(5,_b_);  let mut _item4_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e = parser.lbx(3,_e_);  let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _vx_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut vx = parser.lbx(1,_vx_);  let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; 
  if let (Var(x),)=(&mut *vx,) { Letexp(x,e,b)}  else {parser.report("(Var(x),)"); <Expr<'src_lt>>::default()} }

fn _semaction_rule_3_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);   Plus(e1,e2) }

fn _semaction_rule_4_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);   Minus(e1,e2) }

fn _semaction_rule_5_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);  Divide(e1,e2)}

fn _semaction_rule_6_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut e2 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut e1 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  Times(parser.lbx(0,e1),parser.lbx(2,e2))}

fn _semaction_rule_7_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e = parser.lbx(1,_e_);  let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  Negative(e) }

fn _semaction_rule_8_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  e }

fn _semaction_rule_9_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut n = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  Seq(vec![parser.lbx(0,n)]) }

fn _semaction_rule_10_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; 
  if let (Seq(mut v),)=(_item0_,) { 
   v.push(parser.lbx(1,e));
   Seq(v)
   }  else {parser.report("(Seq(mut v),)"); <Expr<'src_lt>>::default()} }

fn _semaction_rule_11_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; <Expr<'src_lt>>::default()}

pub fn make_parser<'src_lt>() -> ZCParser<RetTypeEnum<'src_lt>,i64>
{
 let mut parser1:ZCParser<RetTypeEnum<'src_lt>,i64> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_10_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_11_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..177 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>, lexer:&mut calcenumlexer<'src_lt>) -> Expr<'src_lt>
{
  if let RetTypeEnum::Enumvariant_0(_x_) = parser.parse(lexer) { _x_ } else { <Expr<'src_lt>>::default()}
}//parse_with public function

//Enum for return values 
pub enum RetTypeEnum<'src_lt> {
  Enumvariant_1(i64),
  Enumvariant_2(&'src_lt str),
  Enumvariant_0(Expr<'src_lt>),
}
impl<'src_lt> Default for RetTypeEnum<'src_lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<Expr<'src_lt>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct calcenumlexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> calcenumlexer<'t> 
{
  pub fn from_str(s:&'t str) -> calcenumlexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> calcenumlexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> calcenumlexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["let","in",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    stk.set_line_comment("#");
    calcenumlexer {stk,keywords}
  }
}
impl<'src_lt> Tokenizer<'src_lt,RetTypeEnum<'src_lt>> for calcenumlexer<'src_lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'src_lt,RetTypeEnum<'src_lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<RetTypeEnum<'src_lt>>::default())),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"int",RetTypeEnum::Enumvariant_1(n))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"var",RetTypeEnum::Enumvariant_2(x))),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'src_lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'src_lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<RetTypeEnum<'src_lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
}//impl Tokenizer

fn load_extras<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

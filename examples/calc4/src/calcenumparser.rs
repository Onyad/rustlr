//Parser generated by rustlr for grammar calcenum
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use crate::exprtrees::*; /* ! lines are injected verbatim into parser */
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

static SYMBOLS:[&'static str;17] = ["_WILDCARD_TOKEN_","E","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

static TABLE:[u64;177] = [30065164288,47244902400,4295098369,8590000129,17180196864,55835033600,60129738752,281505041874944,281535106449408,281492156907520,281522221613056,281530811744256,281479272202241,281543696187395,562992903815168,562967133880320,562975724077056,562962838978560,562971429044224,844459289935874,844442110066690,844446405033986,844476469805058,844467879870466,844463584903170,844437815099394,844450700001282,1125947151745024,1125917087039488,1125904202727425,1125955741876224,1125929972006912,1125960036581376,1407435013292032,1407422128455680,1407392063750144,1407379179503617,1407430718586880,1407404948717568,1688897105166336,1688905695297536,1688879925428224,1688909990002688,1688867040460800,1688854156279809,1970346311811074,1970376376582146,1970337721876482,1970350606778370,1970359196712962,1970367786647554,1970363491680258,1970342016843778,2251825584340992,2251842764472320,2251816994144256,2251812699242496,2251821289308160,2533334920134656,2533322035298304,2533291970592768,2533279086542849,2533304855560192,2533330625429504,2814779832270848,2814766947303424,2814805602140160,2814797012008960,2814754063319041,2814809896845312,3096254809178114,3096293463883778,3096284873949186,3096280578981890,3096241924276226,3096271989047298,3377716900724736,3377729785692160,3377704016805889,3377746965430272,3377759850266624,3377755555561472,3659191877435392,3659234826977280,3659178993582081,3659230532272128,3659221942140928,3659204762402816,3940662559506432,3940675444604928,3940671149572096,3940688330096640,3940666854408192,4222146126282752,4222163305824258,4222176190726146,4222137536020482,4222141830987778,4222159010856962,4222150421315584,4222167600791554,4503625398026240,4503633988616192,4503621102993408,4503612512927744,4503616807829504,4785134734278658,4785130439311362,4785143324213250,4785091784605698,4785104669507586,4785121849376770,5066583940792322,5066588235759618,5066592530726914,5066571056414720,5066575351447552,5066562465955842,5066566760923138,5066601120661506,5348037442600962,5348050328158208,5348067507372034,5348058917437442,5348063212404738,5348076097306626,5348046033125376,5348041737568258,5629533894344706,5629551074213890,5629516714475522,5629521009442818,5629538189312002,5629512419508226,5629542484279298,5629525304410114,5910991691120642,5911026050859010,5910995986087938,5911013165957122,5911000281055234,5910987396153346,5911008870989826,5911017460924418,6192479552798720,6192509617373184,6192453784174593,6192505322668032,6192466667831296,6192496732536832,6473945939705858,6473963119575042,6473937349771266,6473941644738562,6473958824607746,6473950234673154,6473976004476930,6473967414542338,6755412326612992,6755425211711488,6755450982301696,6755416621514752,6755420916678656,7036904482930688,7036891597963264,7036878714437633,7036921662668800,7036930252800000,7036934547505152,7318392344281090,7318375165132800,7318383754346498,7318362280034304,7318370870099968,7318400934215682,7318366574936064,7318388049313794,];


fn _semaction_rule_0_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut m = if let RetTypeEnum::Enumvariant_4(_x_4)=parser.popstack().value { _x_4 } else {<i64>::default()};  Val(m) }

fn _semaction_rule_1_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut s = if let RetTypeEnum::Enumvariant_5(_x_5)=parser.popstack().value { _x_5 } else {<&'src_lt str>::default()};  Var(s) }

fn _semaction_rule_2_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _b_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut b = parser.lbx(5,_b_);  let mut _item4_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e = parser.lbx(3,_e_);  let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _vx_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut vx = parser.lbx(1,_vx_);  let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; 
  if let (Var(x),)=(&mut *vx,) { Letexp(x,e,b)}  else {parser.report("(Var(x),)"); <Expr<'src_lt>>::default()} }

fn _semaction_rule_3_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);   Plus(e1,e2) }

fn _semaction_rule_4_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);   Minus(e1,e2) }

fn _semaction_rule_5_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);  Divide(e1,e2)}

fn _semaction_rule_6_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut e2 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut e1 = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  Times(parser.lbx(0,e1),parser.lbx(2,e2))}

fn _semaction_rule_7_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _e_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  let mut e = parser.lbx(1,_e_);  let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  Negative(e) }

fn _semaction_rule_8_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  e }

fn _semaction_rule_9_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut n = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()};  Seq(vec![parser.lbx(0,n)]) }

fn _semaction_rule_10_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; 
  if let (Seq(mut v),)=(_item0_,) { 
   v.push(parser.lbx(1,e));
   Seq(v)
   }  else {parser.report("(Seq(mut v),)"); <Expr<'src_lt>>::default()} }

fn _semaction_rule_11_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>) -> Expr<'src_lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Expr<'src_lt>>::default()}; <Expr<'src_lt>>::default()}

pub fn make_parser<'src_lt>() -> ZCParser<RetTypeEnum<'src_lt>,i64>
{
 let mut parser1:ZCParser<RetTypeEnum<'src_lt>,i64> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_10_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,i64>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_11_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..177 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>, lexer:&mut calcenumlexer<'src_lt>) -> Result<Expr<'src_lt>,Expr<'src_lt>>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Expr<'src_lt>>::default())}
}//parse_with public function

pub fn parse_train_with<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>, lexer:&mut calcenumlexer<'src_lt>, parserpath:&str) -> Result<Expr<'src_lt>,Expr<'src_lt>>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Expr<'src_lt>>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum<'src_lt> {
  Enumvariant_0(Expr<'src_lt>),
  Enumvariant_5(&'src_lt str),
  Enumvariant_1(()),
  Enumvariant_4(i64),
}
impl<'src_lt> Default for RetTypeEnum<'src_lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<Expr<'src_lt>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct calcenumlexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
}
impl<'t> calcenumlexer<'t> 
{
  pub fn from_str(s:&'t str) -> calcenumlexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> calcenumlexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> calcenumlexer<'t> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    for kw in ["let","_WILDCARD_TOKEN_","in",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [] {lexnames.insert(k,v);}
    stk.set_line_comment("#");
    calcenumlexer {stk,keywords,lexnames}
  }
}
impl<'src_lt> Tokenizer<'src_lt,RetTypeEnum<'src_lt>> for calcenumlexer<'src_lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'src_lt,RetTypeEnum<'src_lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum<'src_lt>>::default()))
      },
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"int",RetTypeEnum::Enumvariant_4(n))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"var",RetTypeEnum::Enumvariant_5(x))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum<'src_lt>>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'src_lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'src_lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<RetTypeEnum<'src_lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
}//impl Tokenizer

fn load_extras<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,i64>)
{
}//end of load_extras: don't change this line as it affects augmentation

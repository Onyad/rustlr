//Parser generated by rustlr

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{RuntimeParser,RProduction,Stateaction,decode_action};
use crate::exprtrees::*;
use crate::exprtrees::Expr::*;
use rustlr::{LBox};

const SYMBOLS:[&'static str;12] = ["E","ES","+","-","*","/","(",")",";","int","START","EOF"];

const TABLE:[u64;99] = [65537,12885032960,25770131456,38654902272,4295229441,281483567300608,281487862202368,281509336973312,281496451940352,281492157038592,562975723552768,562988608323584,562962838454272,562949954142209,844446404968450,844437815033858,844459289870338,844454994903042,844442110001154,844433520066562,1125925676974080,1125899907629057,1125938561744896,1125912791875584,1125947151482883,1407374884405249,1407400653684736,1407387768586240,1407413538455552,1688849861181441,1688862745296896,1688875630395392,1688888515166208,1970350607106048,1970324837957633,1970363491876864,1970337722007552,2251838468849666,2251812699045890,2251847058784258,2251825583947778,2533274791444481,2533287675428864,2533300560527360,2533313445298176,2814749768220673,2814762652139520,2814775537238016,2814788422008832,3096259103883266,3096233334079490,3096241924145152,3096237629046786,3096254808915970,3096246219046912,3377721195757568,3377716900855808,3377712606019584,3377734081445888,3377708311117824,3659187582730240,3659191877566464,3659204763254784,3659196172468224,3659183287828480,3940662559047682,3940666854014978,3940671148982274,3940679738916866,3940684033884162,3940658264080386,4222141830791170,4222146125758466,4222137535823874,4222133240856578,4222159010660354,4222154715693058,4503633987239938,4503621102600192,4503612512403458,4503616807698432,4503629692272642,4503608217436162,4785108963885058,4785091784409088,4785087489048578,4785096079310848,4785104668917762,4785083194081282,5066575351119874,5066588236021762,5066596825956354,5066562466217986,5348033147830274,5348037442797570,5348054622666754,5348046032732162,5348041737764866,5348058917634050,];

pub fn make_parser() -> RuntimeParser<Expr,Expr>
{
 let mut parser1:RuntimeParser<Expr,Expr> = RuntimeParser::new(10,20);
 let mut rule = RProduction::<Expr,Expr>::new_skeleton("start");
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let m:Expr=parser.stack.pop().unwrap().value;  m /* should be a Val(n) */};
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e2:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   let e1:Expr=parser.stack.pop().unwrap().value;   Plus(parser.lb(e1),parser.lb(e2)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e2:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   let e1:Expr=parser.stack.pop().unwrap().value;   Minus(parser.lb(e1),parser.lb(e2)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e2:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   let e1:Expr=parser.stack.pop().unwrap().value;   Divide(parser.lb(e1),parser.lb(e2)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e2:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   let e1:Expr=parser.stack.pop().unwrap().value;   Times(parser.lb(e1),parser.lb(e2)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   Negative(parser.lb(e)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ parser.stack.pop();   let e:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   e };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ parser.stack.pop();   let n:Expr=parser.stack.pop().unwrap().value;   Seq(vec![parser.lb(n)]) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("ES");
 rule.Ruleaction = |parser|{ parser.stack.pop();   let e:Expr=parser.stack.pop().unwrap().value;   let mut _vflab_0=parser.stack.pop().unwrap().value;  
  if let (Seq(mut v),)=(_vflab_0,) { 
   v.push(parser.lb(e));
   Seq(v)
 }  else {parser.bad_pattern("(Seq(mut v),)")} };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("START");
 rule.Ruleaction = |parser|{ parser.stack.pop();  return <Expr>::default();};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..99 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras(parser:&mut RuntimeParser<Expr,Expr>)
{
}//end of load_extras: don't change this line as it affects augmentation

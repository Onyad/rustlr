//Parser generated by rustlr for grammar calcrewc
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use crate::exprtrees::*; /* ! lines are injected verbatim into parser */
use crate::exprtrees::Expr::*;
use rustlr::{LBox,makelbox};

static SYMBOLS:[&'static str;19] = ["_WILDCARD_TOKEN_","E","E1","ES","+","-","*","/","(",")","=",";","let","in","int","var","NE111","START","EOF"];

static TABLE:[u64;210] = [8590065665,60130000896,21475033088,68719804417,4295032833,34360131584,51540131840,12885491713,64424771584,281496452399104,281505042202624,281492157497344,281500747169792,281474977497088,281522222333952,563001493749762,562971428978690,563014378651650,563027263553538,562984313880578,563010083684354,844489354903552,844459290263552,844429226147841,844476470263808,844485060132864,844446405165056,1125899906908162,1125925676711938,1125917086777346,1125955741483010,1125929971679234,1125938561613826,1125921381744642,1125942856581122,1125947151548418,1407452193816578,1407383474601985,1407409243684864,1407396358586368,1407435013554176,1407379178586113,1407426423685120,1407439308324864,1688884220395520,1688914285035520,1688854156410881,1688871335297024,1688909990264832,1688901400395776,1970363491680258,1970342016843778,1970324836974594,1970372081614850,1970346311811074,1970380671549442,1970367786647554,1970350606778370,1970354901745666,2251804109897729,2251821288718336,2251859943686144,2251864238456832,2251834173816832,2251851353817088,2533352099807235,2814771242139648,2814754063384577,2814801307238400,2814784127238144,2814809897107456,2814814191878144,3096289168588800,3096276283949056,3096284873818112,3096246218850304,3096259103948800,3096229040160769,3377721195560960,3377751260659712,3377759850528768,3377734080659456,3377764145299456,3377704016936961,3659226237370368,3659239122010112,3659209057370112,3659178993713153,3659196172271616,3659234827239424,3940653970489345,3940671148982272,3940709803950080,3940701214081024,3940684034080768,3940714098720768,4222176190922754,4222159011053570,4222201960726530,4222146126151682,4222184780857346,4222189075824642,4503638282600450,4503629692862464,4503642577567746,4503646872535042,4503621102731266,4503599627894786,4503655462469634,4503625397829632,4503616807763970,4785139029377026,4785151914278914,4785126144475138,4785134734409730,4785108964605954,4785096079704066,5066575351250944,5066571056480256,5066566761578496,5066549581578240,5066579646283776,5066588237135872,5348046033190912,5348067508879360,5348054622994432,5348050327961600,5348041738289152,5348024558288896,5629546779246594,5629521009442818,5629529599377410,5629555369181186,5629525304410114,5629499534606338,5629516714475522,5629542484279298,5629538189312002,5911000281055234,5911021755891714,5911030345826306,5911017460924418,5910974511251458,5911004576022530,5910991691120642,5911013165957122,5910995986087938,6192475258093568,6192449488093186,6192470963322880,6192479553126400,6192488142798850,6192496732733442,6192466668421120,6192505322668034,6192492437766146,6473967414280194,6473954529837056,6473941644476418,6473924464607234,6473980299182082,6473945939443714,6473950234804224,6473971709247490,6473963119312898,6755442390925314,6755446685892610,6755425211514880,6755416621121538,6755438095958018,6755399441252354,6755455275827202,6755420916088834,6755429506547712,7036874418356226,7036900188160002,7036904483127298,7036891598225410,7036913073061890,7036917368029186,7036921662996482,7036930252931074,7036895893192706,7318383754608640,7318370869510144,7318353691213825,7318400934608896,7318413819248640,7318409524477952,7599854436679680,7599845846876160,7599880207597568,7599841551974400,7599824371974144,7599850141646848,7881359477899264,7881333708029952,7881350888030208,7881320822931456,7881363772669952,7881303644766209,8162830159314946,8162821569380354,8162817274413058,8162812979445762,8162800095068160,8162791505395712,8162795800297472,8162804390100992,8162774325395456,];


fn _semaction_rule_0_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut m = if let RetTypeEnum::Enumvariant_5(_x_5)=parser.popstack().value { _x_5 } else {<i64>::default()};  Val(m) }

fn _semaction_rule_1_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut s = if let RetTypeEnum::Enumvariant_6(_x_6)=parser.popstack().value { _x_6 } else {<&'src_lt str>::default()};  Var(s) }

fn _semaction_rule_2_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _b_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut b = parser.lbx(5,_b_);  let mut _item4_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut _e_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e = parser.lbx(3,_e_);  let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut _vx_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut vx = parser.lbx(1,_vx_);  let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; 
  if let (Var(x),)=(&mut *vx,) { Letexp(x,e,b)}  else {parser.report("(Var(x),)"); <Expr<'src_lt>>::default()} }

fn _semaction_rule_3_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);   Plus(e1,e2) }

fn _semaction_rule_4_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);   Minus(e1,e2) }

fn _semaction_rule_5_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _e2_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e2 = parser.lbx(2,_e2_);  let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut _e1_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e1 = parser.lbx(0,_e1_);  Divide(e1,e2)}

fn _semaction_rule_6_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut e2 = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut e1 = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  Times(parser.lbx(0,e1),parser.lbx(2,e2))}

fn _semaction_rule_7_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  parser.report_error("unidentified operator",true); Val(0)}

fn _semaction_rule_8_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _e_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  let mut e = parser.lbx(1,_e_);  let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()};  Negative(e) }

fn _semaction_rule_9_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()};  e }

fn _semaction_rule_10_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Expr<'src_lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; let mut e = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()}; e}

fn _semaction_rule_11_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Vec<LBox<Expr<'src_lt>>> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()};  vec![parser.lbx(0,_item0_)] }

fn _semaction_rule_12_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Vec<LBox<Expr<'src_lt>>> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_3(_x_3)=parser.popstack().value { _x_3 } else {<Expr<'src_lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()};  _item0_.push(parser.lbx(1,_item1_)); _item0_ }

fn _semaction_rule_13_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Vec<LBox<Expr<'src_lt>>> {
let mut v = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; v}

fn _semaction_rule_14_<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>) -> Vec<LBox<Expr<'src_lt>>> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<Vec<LBox<Expr<'src_lt>>>>::default()}; <Vec<LBox<Expr<'src_lt>>>>::default()}

pub fn make_parser<'src_lt>() -> ZCParser<RetTypeEnum<'src_lt>,()>
{
 let mut parser1:ZCParser<RetTypeEnum<'src_lt>,()> = ZCParser::new(15,30);
 let mut rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("E1");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_3(_semaction_rule_10_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("NE111");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_11_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("NE111");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_12_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_13_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'src_lt>,()>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_14_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..210 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>, lexer:&mut calcrewclexer<'src_lt>) -> Result<Vec<LBox<Expr<'src_lt>>>,Vec<LBox<Expr<'src_lt>>>>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Vec<LBox<Expr<'src_lt>>>>::default())}
}//parse_with public function

pub fn parse_train_with<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>, lexer:&mut calcrewclexer<'src_lt>, parserpath:&str) -> Result<Vec<LBox<Expr<'src_lt>>>,Vec<LBox<Expr<'src_lt>>>>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<Vec<LBox<Expr<'src_lt>>>>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum<'src_lt> {
  Enumvariant_6(&'src_lt str),
  Enumvariant_0(Vec<LBox<Expr<'src_lt>>>),
  Enumvariant_3(Expr<'src_lt>),
  Enumvariant_5(i64),
  Enumvariant_1(()),
}
impl<'src_lt> Default for RetTypeEnum<'src_lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<Vec<LBox<Expr<'src_lt>>>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct calcrewclexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
   lexnames: HashMap<&'static str,&'static str>,
}
impl<'t> calcrewclexer<'t> 
{
  pub fn from_str(s:&'t str) -> calcrewclexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> calcrewclexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> calcrewclexer<'t> {
    let mut lexnames = HashMap::with_capacity(64);
    let mut keywords = HashSet::with_capacity(64);
    for kw in ["let","in","_WILDCARD_TOKEN_",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    for d in [] {stk.add_triple(d);}
    for (k,v) in [] {lexnames.insert(k,v);}
    stk.set_line_comment("#");
    calcrewclexer {stk,keywords,lexnames}
  }
}
impl<'src_lt> Tokenizer<'src_lt,RetTypeEnum<'src_lt>> for calcrewclexer<'src_lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'src_lt,RetTypeEnum<'src_lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => {
        let truesym = self.lexnames.get(sym).unwrap_or(&sym);
        Some(TerminalToken::from_raw(token,truesym,<RetTypeEnum<'src_lt>>::default()))
      },
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"int",RetTypeEnum::Enumvariant_5(n))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"var",RetTypeEnum::Enumvariant_6(x))),
      RawToken::Symbol(s) if self.lexnames.contains_key(s) => {
        let tname = self.lexnames.get(s).unwrap();
        Some(TerminalToken::from_raw(token,tname,<RetTypeEnum<'src_lt>>::default()))
      },
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'src_lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'src_lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<RetTypeEnum<'src_lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
}//impl Tokenizer

fn load_extras<'src_lt>(parser:&mut ZCParser<RetTypeEnum<'src_lt>,()>)
{
}//end of load_extras: don't change this line as it affects augmentation

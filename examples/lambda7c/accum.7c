// closures

define make_accum = lambda x:int . {
  define a = x;
  define f = int lambda y . { a=a+y; a; }
  f;
}

define ac1 = make_accum(0);
define ac2 = make_accum(0);
ac1(2);
ac1(3);
print(ac1(2));
print(ac2(2));
print(ac2(2));
define ac3 = if (getint()==1) then ac1 else ac2;
print(ac3(1));

free(ac1);
free(ac2);

/*
but ac1 and ac2 will actually be bound to structs.  they must be treated
differently.  should be able to handle statically.  Where to put this
info?  must exist in type system.  Each time a closure is created,
a new type - struct type, must be associated with the "function": userstruct.

but the typechecker must return a LRfun type. where is this extra type info
going to be held?  Another structure that's part of the symbol table.
The information for a function must indicate that it's really a closure:
must relate it to a specific closure type.

Don't put it in symbol table.  Scoping doesn't matter after we've already
type checked it. Use a global structure to map functions like f_12 to
LLVM structure types LLVMtype::Userstruct("cl_f_12");  This map can
be in the LLVMCompiler struct.

Closure should just always consist of variables that are defined in the
local frame?  What about other variables that it tries to reference?

define z = 1;
let g2 = {
 let u = 2 in {
  define f = lambda y. {
    define v = 3;
    define g = lambda r.z+u+v+y+r;
    g;  // return g.
  }
  f
 }
} // g2 will be bound to the g returned
g2(1);

What should g's closure consist of?
v, y for sure.
z and u?  if g is allowed to be define that way, they MUST be somewhere.

1. passed in as extra args
   - won't work in case of u: once g2 returns, u popped off?

   g2 is itself a closure that includes u so calling g2(1) is
   calling g2(cl_g2,1).

   are we talking inheritance?  runtime closure lookup sounds dangerous. (ds)
   

2. included in the closure as pointers: not practical?, would have to
form closure based on current stack state, each time invoked.

If they're pointers, where will they point to?  The fact is that g
is created each time f and g2 is called, so each g must carry different
a closures that contains pointers to other closure.  But f will have
it's own closure, so there's no dynamic scoping.

When compiling each function definition, create struct type with
  values for each local var
  pointers for each closure var.
function body, and map function name to cl_function and function.

Each time a function is *called*, a closure instance is created.
each value is copied into the closure (fargs), each free arg should
already be a pointer.  pointer is inherited from the parent closure: the
function call itself must happen in the context of a closure.

main has its own closure, which we can call the global closure.
*/

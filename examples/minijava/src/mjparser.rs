//Parser generated by rustlr for grammar mj

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use rustlr::{LBox,makelbox};
use crate::absyntax::*;
use crate::absyntax::Construct::*;
use crate::absyntax::Expr::*;
use crate::absyntax::Stat::*;

static SYMBOLS:[&'static str;58] = ["ID","INTEGER","STRING","BOOL","class","public","static","void","main","String","extends","return","length","(",")","[","]",";","DOT","!",",","new","this","LBR","RBR","OROR","int","boolean","if","else","while","==","=","+","-","*","/","<","&&","MOD","Program","MainCl","ClassDec","ClassDecl","Extension","VarDec","MethodDec","Decl","FormalLst","FormalRst","Type","Stat","Stats","Exp","ExpLst","ExpRst","START","EOF"];

static TABLE:[u64;1263] = [176093724673,171798888449,17180000256,281719789977602,281659660566529,281492156710914,562949953748992,844669743267843,1126144719978498,1126080295927809,1125917087105024,1407473668325376,1688849860853760,1970342017040386,1970569650307074,2251821289177088,2533463769677825,2533373575036930,2533317740855296,2814775537762304,3096323528982528,3377699721510912,3659204763058176,3940761343754242,3940765638721538,3940752753819650,3940688329310210,3940679739375618,3940851538526209,3940649674604546,3940671149441026,4222223435235330,4503633988288512,4785177684803584,4785104670556160,4785272173821953,4785186274803712,4785267878920193,4785190570033152,4785113260556288,4785289353822209,4785096080359424,4785074605719552,5066605417267200,5348046033125378,5348054623059970,5348140522405890,5348136227438594,5348063212994562,5348024558288898,5348127637504002,5629529599705090,5629538189639682,5629611204083714,5629615499051010,5629602614149122,5629499534934018,5629521009770498,5910974512889856,6192488144109568,6192561158356992,6192479554109440,6192449489272832,6192565453586432,6192664238030849,6474169277743106,6473941644476418,6755399442366466,6755463867662336,7036874419208194,7318349395853314,7599824372432898,7881299349078018,8162812981477376,8444386742566912,8444322317991936,8725724280389632,9007267976642560,9288738658451456,9570162093522946,9570196453261314,9570273762672642,9570170683457538,9570179273392130,9570205043195906,9570157798555650,9570269467705346,9570153503588354,9570265172738050,9570230812999682,9570243697901570,9570247992868866,9570260877770754,9570252287836162,9570239402934274,9570278057639938,9570187863326722,9570149208621058,9851632777494528,9851680022200320,9851705792200704,9851624187494400,9851851820695553,9851714382200832,9851637072855040,9851628482658304,9851718677037056,10133154999304192,10414574139408386,10696117837692928,10977670124208128,10977657239240704,10977683008913408,10977597109895168,10977631469764608,10977687304273920,10977588520222720,10977601404403712,10977691598913536,10977665829306368,10977674419503104,10977678713880576,11259059201245186,11259162280460290,11259166575427586,11259145100591106,11259153690525698,11259140805623810,11259084971048962,11259157985492994,11259149395558402,11259076381114370,11259063496212482,11259067791179778,11259106445885442,11259072086147074,11259132215689218,11540547062726658,11540607192268802,11540542767759362,11540628667105282,11540581422465026,11540534177824770,11540637257039874,11540551357693954,11540559947628546,11540632962072578,11540620077170690,11540538472792066,11540641552007170,11540624372137986,11540615782203394,11822043514011648,11821957614469120,11821949024468992,11822039219175424,11822030629175296,11822004859174912,11821953319632896,11822176659177473,11821961909829632,12103557145624578,12103488426147842,12103574325493762,12103492721115138,12103509900984322,12103497016082434,12103501311049730,12103531375820802,12103578620461058,12103565735559170,12103582915428354,12103570030526466,12103484131180546,12103591505362946,12103587210395650,12385049302466562,12385053597433858,12385040712531970,12385057892401154,12384984877957122,12384976288022530,12385032122597378,12385006352793602,12385066482335746,12384967698087938,12384971993055234,12384959108153346,12385045007499266,12384963403120642,12385062187368450,12666468444143616,12666464149307392,12666378249764864,12666386839961600,12666429789306880,12666455559307264,12666601589374977,12666382544601088,12666373954600960,12947960602099712,12947848932884480,13229409807958018,13229457052598274,13229392628088834,13229478527434754,13229491412336642,13229474232467458,13229469937500162,13229482822402050,13229384038154242,13229487117369346,13229431282794498,13229396923056130,13229401218023426,13229388333121538,13229465642532866,13510859012505602,13510914848063488,13511005044867073,13511013634867201,13510837538586624,13510910552834048,13510828948586496,13510798883749888,13792273863278592,14073748840054784,14355236700225536,14355279649570816,14355228110028800,14355451450097665,14355305419571200,14355314009571328,14355223814864896,14355232404865024,14355318304407552,14636754626281472,14636703086739456,14636711676936192,14636698791575552,14636793281118208,14636788986281984,14636926426873857,14636780396281856,14636707381575680,14918229602992128,14918182358286336,14918263962992640,14918173768286208,14918178063450112,14918268257828864,14918401403650049,14918255372992512,14918186653646848,15199704579702784,15199657334996992,15199743234539520,15199730349703168,15199738939703296,15199876380426241,15199661630357504,15199653040160768,15199648744996864,15481218211250176,15481128016871424,15481123721707520,15481213916413952,15481351357202433,15481205326413824,15481136607068160,15481179556413440,15481132311707648,15762688893124608,15762607288418304,15762598698418176,15762654533124096,15762602993582080,15762693187960832,15762680303124480,15762611583778816,15762826333978625,16044103737802754,16044193932115970,16044129507606530,16044176752246786,16044077967998978,16044112327737346,16044073673031682,16044086557933570,16044155277410306,16044168162312194,16044172457279490,16044163867344898,16044082262966274,16044202522050562,16044120917671938,16044185342181378,16044095147868162,16044198227083266,16044189637148674,16325630256545792,16325561537200128,16325643141382144,16325604486545408,16325776287465473,16325552947003392,16325557241839616,16325638846545920,16325548651839488,16607027923714048,16607251264241665,16607023628550144,16607079463256064,16607036513910784,16607032218550272,16607113823256576,16607118118092800,16607105233256448,16888511490621440,16888588799967232,16888502900424704,16888726241017857,16888507195260928,16888498605260800,16888593094803456,16888554439966720,16888580209967104,17169986467332096,17170029416677376,17170201217794049,17170063776677888,17170068071514112,17169977877135360,17169982171971584,17170055186677760,17169973581971456,17451616063258624,17451555934109696,17451598883848192,17451611768619008,17451525868748800,17451590293651456,17451512984567808,17451581703585792,17451594588553216,17451603178225664,17451607473258496,17451508690845696,17733069565263872,17733086744150018,17733082449182722,17733065270362112,17733009434738690,17732983664934914,17732996549836802,17733000845459456,17733091039969280,17733056679378946,17733030909575170,17732987959902210,17733073860558848,17733078154936320,17732992254869506,18014454349365248,18295937916076032,18577408597884928,18858823445118976,19140358551437312,19421915129905154,19421906539970562,19421919424872450,19421936604741634,19421928014807042,19421837820493826,19421829233246208,19421932309774338,19421850705395714,19421846410428418,19421923719839746,19421833525526530,19421859295330306,19421940899708930,19421842115461122,19421880770166786,19703334271451138,19703325682434048,19703312796614658,19703407285895170,19703355746287618,19703321386549250,19703308501647362,19703390106025986,19703381516091394,19703317091581954,19703411580862466,19703398695960578,19703402990927874,19703415875829762,19703394400993282,19984809248489474,19984877968621568,19984865084047360,19984856493981696,19984890853654528,19984800659144704,19984830724505600,19984792068620290,19984796363587586,19984869378949120,19984787773652994,19984873674244096,19984886559014912,19984882262933506,19984783478685698,20266271340363778,20266305700102146,20266348649775106,20266267045396482,20266340059840514,20266258455461890,20266365829644290,20266284225265666,20266262750429186,20266352945332224,20266357239709698,20266344354807810,20266361534676994,20266275635855360,20266331469905922,20547836512436224,20547815037468672,20547780677926912,20547819332370432,20547832216485890,20547750612566016,20547742022172674,20547823627665408,20547806446682114,20547733432238082,20547759202041858,20547746317139970,20547840807075840,20547827922042880,20547737727205378,20829212703522818,20829302898753536,20829234178359298,20829298604376064,20829216998490114,20829315783786496,20829208408555522,20829255653195778,20829294307901442,20829311487770626,20829225589276672,20829221293457410,20829281422999554,20829290012934146,20829307192803330,21110773581086720,21110790760497152,21110782169382914,21110683385135106,21110777875464192,21110730629775362,21110700565987328,21110709154938882,21110691975069698,21110756399579138,21110687680102402,21110786464350210,21110696270036994,21110769285791744,21110764989513730,21392171246944258,21392184131846146,21392248557797376,21392166951976962,21392158362042370,21392257146290178,21392265737207808,21392261441257474,21392244262502400,21392205606682626,21392162657009666,21392239967600640,21392175542697984,21392231376486402,21392252852174848,21673736419278848,21673633338818562,21673659108622338,21673714944311296,21673641928753154,21673650519408640,21673646223720450,21673637633785858,21673719239213056,21673680583458818,21673740713918464,21673706353262594,21673732123066370,21673727828885504,21673723534508032,21955215690629120,21955194214547458,21955134085005314,21955108315201538,21955198509514754,21955211394416642,21955112610168834,21955189919580162,21955207099449346,21955202805596160,21955125496119296,21955116905136130,21955155559841794,21955121200103426,21955181329645570,22236587588648960,22236669192634368,22236690667339776,22236664897732608,22236682077339648,22236686372700160,22236630538190848,22236673487929344,22236600472829952,22236677782306816,22236591885320192,22236656307666944,22518148464246786,22518144169279490,22518165644115970,22518105514573826,22518084039737346,22518058269933570,22518075449802754,22518139874312194,22518157054181378,22518066859868162,22518152759214082,22518071154835458,22518062564900866,22518131284377602,22518161349148674,22799533248872448,23081038287601664,23080952388059136,23081003927601152,23080956682895360,23080960978255872,23080948092895232,23081042582437888,23081175729373185,23081029697601536,23362521857130496,23643983949070336,23643958174220290,23644108503056385,23925471810748416,24207075636609025,24206852294901760,24207079931510785,24206942489280512,24206856589737984,24206938194444288,24206929604444160,24206908130263042,24206847999737856,24206903834443776,24206860885098496,24488400286121986,24488395991154690,24488464710631426,24488473300566018,24488477595533314,24488391696187394,24488481890500610,24488490480435202,24488456120696834,24488387401220098,24488383106252802,24488486185467906,24488408876056578,24488430350893058,24488469005598722,24769948277866498,24769862378520578,24769858083553282,24769965457735682,24769875263422466,24769870968455170,24769961162768386,24769943982899202,24769956867801090,24769866673487874,24769931097997314,24769952572833794,24769905328193538,24769939687931906,24769883853357058,25051380305297408,25051341653016576,25051427549413376,25051406074773504,25051414664839168,25051423255035904,25051337355755520,25051350239936512,25051418959740928,25051440434446336,25051436139806720,25051431844446208,25332829509844994,25332868164550658,25332747905466370,25332846689714178,25332850984681474,25332803740041218,25332756495400962,25332842394746882,25332760790368258,25332863869583362,25332752200433666,25332838099779586,25332786560172034,25332777970237442,25332859574616066,25332876754485250,25332971248615425,25332795150106626,25614283011129346,25895697859018752,25895736513855488,25895912612167681,25895727923855360,25895809528102912,25895813823332352,26177254439976962,26177284504748034,26177271619846146,26177288799715330,26177396178878465,26177181425532930,26177267324878850,26177275914813442,26177177130565634,26177220080238594,26177172835598338,26177301684617218,26177211490304002,26177202900369410,26177263029911554,26177293094682626,26177228670173186,26177185720500226,26458707946897408,26740255935037440,26740273115299840,26740208693477376,26740277409677312,26740264525103104,26740286000070656,26740182920790018,26740268820004864,26740359017398273,26740290294710272,26740187216019456,26740230165561344,26740281704710144,26740200100200448,27021662192140290,27021730911617026,27021666487107586,27021765271355394,27021683666976770,27021748091486210,27021760976388098,27021752386453506,27021739501551618,27021675077042178,27021657897172994,27021743796518914,27021705141813250,27021670782074882,27021756681420802,27303077038718976,27303119992586240,27303300380950529,27303287490674689,27303291791147009,27303175827423232,27303072748077056,27303128578260992,27303184411656192,27303188706885632,27303102807408640,27303085628915712,27303154348261376,27303266021277697,27303201597161472,27303167233097728,27303162938261504,27303081333555200,27303171532128256,27303111397408768,27303193007095808,27584547724984320,27866052760829952,27866026992140288,27866241744568321,27866104301682688,27866117186519040,27866078531682304,27866061350830080,27866112891682816,27866250334371841,27866035582337024,27866125780975616,27866138660306944,27866151550582784,27866237444096001,27866031286976512,27866069946007552,27866134365077504,27866022701498368,27866142960517120,27866215974699009,27866121485549568,28147639408001026,28147660882837506,28147557803622402,28147566393556994,28147574983491586,28147643702968322,28147630818066434,28147562098589698,28147647997935618,28147652292902914,28147570688524290,28147605048262658,28147656587870210,28147665177804802,28147583573426178,28429054255104000,28428985535758336,28429200288514049,28429028485103616,28428981240397824,28429067139940352,28429062845104128,28428972650397696,28428976945561600,28710507757699074,28992077223362560,28992072928985088,28992055748722688,28991999918211072,28992081518395392,28992085813755904,28991987033243648,28992064338788352,28992068633690112,28992029979246592,28992090108395520,29273526429089794,29273453414645762,29273522134122498,29273479184449538,29273436234776578,29273509249220610,29273410464972802,29273427644841986,29273492069351426,29273496364318722,29273406170005506,29273487774384130,29273500659286018,29273517839155202,29273397580070914,29273401875038210,29273513544187906,29273444824711170,29554881146126338,29554954160570370,29554975635406850,29554911210897410,29554902620962818,29554967045472258,29554928390766594,29554876851159042,29554971340439554,29554962750504962,29554992815276034,29554988520308738,29554919800832002,29554885441093634,29555001405210626,29554984225341442,29554872556191746,29836351827804162,29836450612051970,29836446317084674,29836356122771458,29836386187542530,29836360417738754,29836437727150082,29836459201986562,29836347532836866,29836394777477122,29836442022117378,29836463496953858,29836570877296641,29836476381855746,29836467791921154,29836429137215490,29836403367411714,29836377597607938,30117826805825536,30117831100661760,30117835396022272,30117822510661632,30117878345367552,30117904115367936,30117917000204288,30118050149040129,30117912705368064,30399353327124480,30680772462903298,30680931378528258,30680922788593666,30680879838920706,30680909908279296,30680914198659074,30680935673495554,30680836889247746,30680939968462850,30680905608724482,30680849774149634,30680918493626370,30680927083560962,30962303280676864,31243752480243714,31243825494687746,31243834084622338,31243722415472642,31243838379589634,31243761070178306,31243743890309122,31525257522118658,31525283296968704,31525407852986369,31806775455580160,32088280492539904,32088289082605568,32088383576342529,32088254723063808,32088314852212736,32088211773521920,32088207478292482,32088224657702912,32088233250979840,32088301967179776,32088293377507328,32088310557573120,32088297672802304,32088306262212608,32369703929053184,32369712519053312,32369635209707520,32369622324346880,32369849963184129,32369716813889536,32369626619510784,32369630914347008,32369678159052800,32651097306693632,32932666767310848,32932619526799360,32932572282290176,32932610931621888,32932791325360129,32932701131374592,32932585163128832,32932671066341376,32932799915163649,32932692541308928,32932787024887809,32932688241098752,32932580867768320,32932602341621760,32932662472474624,32932675362684928,32932683945869312,32932628112474112,32932576572932096,32932653882474496,32932765555490817,33214154629906432,33214197579644928,33214206169055232,33214111680364544,33214120274690048,33214210464415744,33214201874022400,33214188989448192,33214214759055360,33214180399382528,33214124564545536,33214193284349952,33495749870288897,33495535116550144,33495522231189504,33495578065895424,33495526526353408,33495616720732160,33495530821189632,33495603835895808,33495612425895936,33776997207900160,33777087402606592,33777078812606464,33777010093260800,33777053042606080,33777005797900288,33777224847065089,33777001503064064,33777091697442816,34058472184610816,34058562379317248,34058480774610944,34058485069971456,34058476479774720,34058566674153472,34058553789317120,34058528019316736,34058699823841281,34340007289290754,34621666948612098,34621439315345410,34902957245464578,35184440816959488,35184526710996992,35184531006029824,35184539596029952,35184522416619520,35184479466881024,35184513826422784,35184518121324544,35184505236357120,35184449401520128,35184436517339136,35184535301390336,35466001687314434,35465980212477954,35466014572216322,35465988802412546,35465911493001218,35465924377903106,35466010277249026,35466005982281730,35465997392347138,35465993097379842,35465902908833792,35465954442674178,35747446597943298,35747377878466562,35747433713041410,35747369288531970,35747412238204930,35747326338859010,35747330633826306,35747403648270338,35747450892910594,35747334928793602,35747438008008706,35747425123106818,35747360698597378,35747322043891714,35747416533172226,35747420828139522,35747352108662786,35747442302976002,36028891510341634,36028925870080002,36028852855635970,36028835675766786,36028917280145410,36028912985178114,36028895805308930,36028809905963010,36028844265701378,36028908690210818,36028827085832194,36028887215374338,36028900100276226,36028878625439746,36028797021061122,36028801316028418,36028805610995714,36028921575112706,36310349308362752,36310332133998592,36310379373723648,36310435208232960,36310422323462144,36310418028167168,36310336424181760,36310405143199744,36310413733265408,36310426617839616,36310430912872448,36310439502872576,36591914479583232,36591910184943616,36591880119910400,36591888709976064,36591901594550272,36591819995676672,36591811400892416,36591897300172800,36591905889583104,36591854350434304,36591824285073408,36591893004877824,36873299261784064,36873389456293888,36873282087550976,36873355096621056,36873380866293760,36873367981588480,36873329327144960,36873363686686720,36873385161654272,36873286377603072,36873372276883456,36873376571260928,37154761353199618,37154860137447426,37154834373738496,37154838662610946,37154804302872578,37154774238101506,37154864432414722,37154855842480130,37154851547512834,37154847252545538,37154830072676354,37154842957578242,37436171905138688,37436227739844608,37436399542009857,37436266394681344,37436403839795201,37436232035663874,37436253509844992,37436184790499328,37436262099845120,37436180495138816,37436176200302592,37717651177013248,37717840159571969,37717775735455744,37717762845179904,37717676945702912,37717874519244801,37717685535703040,37717694130880512,37717659767209984,37717745670422528,37717655471849472,37717741371392000,37717758549950464,37717865931669505,37717728486555648,37717767145390080,37717861628968961,37717737076555776,37717646886371328,37717702716555264,37999130447773698,37999151922610178,37999216347119618,37999203462217730,37999160512544770,37999250706857986,37999237821956098,37999134742740994,37999169102479362,37999212052152322,37999126152806402,37999233526988802,37999220642086914,37999242116923394,37999177692413954,37999121857839106,37999246411890690,37999224937054210,38280635489124352,38280626899124224,38280609720631296,38280824472666113,38280815885156353,38280644084301824,38280678439976960,38280605425270784,38280596839792640,38280725688877056,38280790112993281,38280712798601216,38280601130434560,38280687029977088,38280708503371776,38280717098811392,38280695623843840,38280811582390273,38280652669976576,38280691324813312,38562076107145216,38562153416687616,38562084697341952,38562080401981440,38562166301523968,38562127646687232,38562162006687744,38562299451867137,38562071811981312,38843606924918784,39125030354485250,39125150613569538,39125060419256322,39125142023634946,39125069009190914,39125146326204416,39125124843765762,39125103368929282,39125133433700354,39125111958863874,39125026059517954,39125051829321730,39125034649452546,39125077599125506,39125021764550658,39125120548798466,39125116253831170,39125137728667650,39406505331261442,39406535396032514,39406586935640066,39406578345705474,39406526806097922,39406599820541954,39406552575901698,39406617000411138,39406543985967106,39406509626228738,39406612705443842,39406608410476546,39406621295378434,39406496741326850,39406501036294146,39406591230607362,39406625590345730,39406595525574658,39688104863727616,39688126338367488,39688036144709632,39688079094251520,39688130633400320,39688113453793280,39688117748695040,39688049028890624,39688134928760832,39688122043990016,39688044740083712,39688139223400448,39969605609717762,39969588429848578,39969614199652354,39969554070110210,39969597019783170,39969524005339138,39969601314750466,39969511120437250,39969579839913986,39969519716859904,39969609904685058,39969592724815874,40251037635575808,40251136419364865,40251140722524161,40251020460818432,40250925967409152,40250921676767232,40250930262245376,40251050525851648,40250951736098816,40251011866951680,40251149309640705,40250968921276416,40251041935785984,40250934557605888,40251003276951552,40250960326098944,40251016161787904,40251114949967873,40250977506951168,40251033340346368,40532508317450242,40532516907384834,40532443892940802,40532405238235138,40532409533202434,40532478252679170,40532452482875394,40532491137581058,40532512612417538,40532435303006210,40532499727515650,40532486842613762,40532396648300546,40532426713071618,40532400943267842,40532525497319426,40532495432548354,40532521202352130,40813983294226434,40813961819389954,40814000474095618,40813918869716994,40813901689847810,40813927459651586,40813875920044034,40813991884161026,40813880215011330,40813871625076738,40813987589193730,40813974704291842,40813996179128322,40813953229455362,40813970409324546,40813884509978626,40813910279782402,40813966114357250,41095445385707522,41095359486361602,41095402436034562,41095428205838338,41095462565576706,41095458270609410,41095441090740226,41095449680674818,41095475450478594,41095355191394306,41095436795772930,41095471155511298,41095385256165378,41095346601459714,41095466860544002,41095393846099970,41095376666230786,41095350896427010,];

pub fn make_parser<'lt>() -> ZCParser<Construct<'lt>,Construct<'lt>>
{
 let mut parser1:ZCParser<Construct<'lt>,Construct<'lt>> = ZCParser::new(60,147);
 let mut rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("start");
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Program");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Classes(cs),Maincl(mc),)=(_item1_.value,_item0_.value,) {  Program(parser.lb(mc),cs) }  else {parser.bad_pattern("(Classes(cs),Maincl(mc),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MainCl");
 rule.Ruleaction = |parser|{ let mut _item16_ = parser.popstack(); let mut _item15_ = parser.popstack(); let mut _item14_ = parser.popstack(); let mut _item13_ = parser.popstack(); let mut _item12_ = parser.popstack(); let mut _item11_ = parser.popstack(); let mut _item10_ = parser.popstack(); let mut _item9_ = parser.popstack(); let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(thebody),Id(an),Id(cn),)=(_item14_.value,_item11_.value,_item1_.value,) { 
   Maincl(Mainclass{classname:cn,
             argvname:an,
             body: Blockst(thebody),
	    })
  }  else {parser.bad_pattern("(Stms(thebody),Id(an),Id(cn),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{  Classes(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Class(cl),Classes(mut cs),)=(_item1_.value,_item0_.value,) { 
  cs.push(parser.lbx(1,cl)); Classes(cs)
  }  else {parser.bad_pattern("(Class(cl),Classes(mut cs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDec");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),Id(sup),Id(name),)=(_item4_.value,_item2_.value,_item1_.value,) { 
  let mut vdecs=Vec::new();
  let mut mdecs=Vec::new();
  separatedecs(ds,&mut vdecs,&mut mdecs); /*split var and method declarations*/
  Class(ClassDec {superclass:sup,
                  classname:name,
		  vars:vdecs,
		  methods:mdecs})
  }  else {parser.bad_pattern("(Decs(mut ds),Id(sup),Id(name),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{ let mut sup = parser.popstack(); let mut _item0_ = parser.popstack();  sup.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{  Id("Object") };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(v),Id(t),)=(_item1_.value,_item0_.value,) {  Vdec(VarDec{dname:v,dtype:t,initval:Nothing,}) }  else {parser.bad_pattern("(Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),Id(t),)=(_item3_.value,_item1_.value,_item0_.value,) { 
  Vdec(VarDec{dname:v,dtype:t,initval:e})
  }  else {parser.bad_pattern("(Exp(e),Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MethodDec");
 rule.Ruleaction = |parser|{ let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(mbody),Vdecs(args),Id(name),Id(ty),)=(_item7_.value,_item4_.value,_item2_.value,_item1_.value,) { 
  Method(MethodDec{ formals:args,
                    body: mbody,
		    classname:ty,
		    methodname:name, })
  }  else {parser.bad_pattern("(Stms(mbody),Vdecs(args),Id(name),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{  Decs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(parser.lbx(1,v.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(makelbox!(m,m.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item2_.value,_item1_.value,_item0_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item3_.value,_item2_.value,_item1_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack();  return Id("int[]"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("boolean"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("String"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("int"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("void"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut c = parser.popstack();  c.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{  Stms(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Stms(mut sv),)=(_item1_.value,_item0_.value,) {  sv.push(makelbox!(_item1_,s)); Stms(sv) }  else {parser.bad_pattern("(Stm(s),Stms(mut sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(sv),)=(_item1_.value,) {  Stm(Blockst(sv)) }  else {parser.bad_pattern("(Stms(sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(b),Stm(a),Exp(c),)=(_item6_.value,_item4_.value,_item2_.value,) { 
  Stm(Ifstat(makelbox!(_item2_,c), makelbox!(_item4_,a), makelbox!(_item6_,b)))
  }  else {parser.bad_pattern("(Stm(b),Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(a),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Ifstat(makelbox!(_item2_,c),makelbox!(_item4_,a),parser.lbx(5,Nopst))) }  else {parser.bad_pattern("(Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Whilest(parser.lbx(2,c),parser.lbx(4,s))) }  else {parser.bad_pattern("(Stm(s),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),)=(_item2_.value,_item0_.value,) {  Stm(Assignst(v,parser.lbx(2,e))) }  else {parser.bad_pattern("(Exp(e),Id(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Exp(i),Exp(v),)=(_item5_.value,_item2_.value,_item0_.value,) { 
  Stm(ArAssignst(parser.lbx(0,v),parser.lbx(2,i),parser.lbx(5,e)))
  }  else {parser.bad_pattern("(Exp(e),Exp(i),Exp(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(m),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) { 
  Stm(Callstat(parser.lb(obj),m,args))
  }  else {parser.bad_pattern("(Exps(args),Id(m),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),)=(_item1_.value,) {  Stm(Returnst(parser.lbx(1,e))) }  else {parser.bad_pattern("(Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Vdec(v),)=(_item0_.value,) { Stm(Vardecst(v.dname,v.dtype,parser.lb(v.initval)))}  else {parser.bad_pattern("(Vdec(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("*",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("+",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("/",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("-",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("&&",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("OROR",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(a),)=(_item1_.value,) {  Exp(Notexp(parser.lbx(1,a))) }  else {parser.bad_pattern("(Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("<",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("%",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("==",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(i),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("[]",parser.lbx(0,a),parser.lbx(2,i)))}  else {parser.bad_pattern("(Exp(i),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(field),Exp(obj),)=(_item2_.value,_item0_.value,) {  Exp(Field(field,parser.lbx(0,obj))) }  else {parser.bad_pattern("(Id(field),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(f),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) {  Exp(Callexp(parser.lb(obj),f,args)) }  else {parser.bad_pattern("(Exps(args),Id(f),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (i,)=(_item0_.value,) {  i }  else {parser.bad_pattern("(i,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack();  s.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (b,)=(_item0_.value,) {  b }  else {parser.bad_pattern("(b,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item0_.value,) {  Exp(Var(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  Exp(Thisptr) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(s),)=(_item3_.value,) {  Exp(Newarray(parser.lbx(3,s))) }  else {parser.bad_pattern("(Exp(s),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item1_.value,) {  Exp(Newobj(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item1_.value,_item0_.value,) {  er.push(parser.lbx(0,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item2_.value,_item1_.value,) {  er.push(parser.lbx(1,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Construct<'lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..1263 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser


// Lexical Scanner using RawToken and StrTokenizer
pub struct mjlexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> mjlexer<'t> 
{
  pub fn from_str(s:&'t str) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> mjlexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["class","public","static","void","main","String","extends","return","length","new","this","int","boolean","if","else","while",] {keywords.insert(kw);}
    for c in ['(',')','[',']',';','!',',','=','+','-','*','/','<','.','%','{','}',] {stk.add_single(c);}
    for d in ["==","&&","||",] {stk.add_double(d);}
    mjlexer {stk,keywords}
  }
}
impl<'lt> Tokenizer<'lt,Construct<'lt>> for mjlexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,Construct<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<Construct<'lt>>::default())),
      RawToken::Alphanum("true") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(true)))),
      RawToken::Alphanum("false") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(false)))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"ID",Id(x))),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"INTEGER",Exp(Int(n as i32)))),
      RawToken::Strlit(s) => Some(TerminalToken::from_raw(token,"STRING",Exp(Strlit(s)))),
      RawToken::Symbol(r".") => Some(TerminalToken::from_raw(token,"DOT",<Construct<'lt>>::default())),
      RawToken::Symbol(r"%") => Some(TerminalToken::from_raw(token,"MOD",<Construct<'lt>>::default())),
      RawToken::Symbol(r"{") => Some(TerminalToken::from_raw(token,"LBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"}") => Some(TerminalToken::from_raw(token,"RBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"||") => Some(TerminalToken::from_raw(token,"OROR",<Construct<'lt>>::default())),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<Construct<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<Construct<'lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<Construct<'lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<Construct<'lt>,Construct<'lt>>)
{
}//end of load_extras: don't change this line as it affects augmentation

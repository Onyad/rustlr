//Parser generated by rustlr for grammar mj

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use rustlr::{LBox,makelbox};
use crate::absyntax::*;
use crate::absyntax::Construct::*;
use crate::absyntax::Expr::*;
use crate::absyntax::Stat::*;

const SYMBOLS:[&'static str;58] = ["ID","INTEGER","STRING","BOOL","class","public","static","void","main","String","extends","return","length","(",")","[","]",";","DOT","!",",","new","this","LBR","RBR","OROR","int","boolean","if","else","while","==","=","+","-","*","/","<","&&","MOD","Program","MainCl","ClassDec","ClassDecl","Extension","VarDec","MethodDec","Decl","FormalLst","FormalRst","Type","Stat","Stats","Exp","ExpLst","ExpRst","START","EOF"];

const TABLE:[u64;1263] = [171798888449,17179934720,176093790209,281474976972800,563194766688258,563134637342721,562967133421570,844669743267843,1125998691483648,1407619696689154,1407392063881216,1407555272704001,1688871335690240,1970324837629952,2252044627017730,2251816993751042,2533300560920576,2814848551747586,2814938746454017,2814792717631488,3096254809505792,3377798505758720,3659174698287104,3940684034801664,4222163306020866,4222240615432194,4222236320464898,4222326515302401,4222124651315202,4222146126151682,4222154716086274,4222227730530306,4503698411945986,4785130439901184,5066747150729217,5066549582626816,5066742855958529,5066579647332352,5066652661383168,5066764330467329,5066588237004800,5066661251645440,5066665546809344,5066571057201152,5348063214174208,5629499536244736,5910991691055106,5911219324321794,6192565452537858,6192479553191938,6192470963257346,6192561157570562,6192488143126530,6192449488420866,6192552567635970,6473924465590274,6755614191517697,6755438097268736,6755515407073280,6755399442890752,6755511111909376,6755429507596288,7036904483258370,7036913073192962,7036986087636994,7036895893323778,7036977497702402,7036990382604290,7036874418487298,7318349395787778,7318413821149184,7599824372563970,7881299349340162,8162774325788674,8444313728057344,8725861719277568,8725797294833664,9007199257165824,9288742953418752,9570217930194944,9851680022134784,9851851820761089,9851628482789376,9851632777691136,9851624187691008,9851637072789504,9851705792004096,9851718677299200,9851714382266368,10133099162042370,10133146406682626,10133197946290178,10133137816748034,10133202241257474,10133154996617218,10133228011061250,10133193651322882,10133210831192066,10133103457009666,10133223716093954,10133129226813442,10133215126159362,10133219421126658,10133120636878850,10133180766420994,10133112046944258,10133189356355586,10133107751976962,10414629976080384,10696049116119042,10977524094992384,11259140805689344,11259157985820672,11259145100787712,11259132216082432,11259166576017408,11259149396017152,11259153691049984,11259106446016512,11259072086933504,11259063496933376,11259162281115648,11259076381376512,11540474047954944,11540478343053312,11540564242530304,11540555652268032,11540529882398720,11540568537563136,11540701682532353,11540486933053440,11540482637955072,11822004859109376,11821957614665728,11821949024665600,11822176659308545,11822039219240960,11821961909764096,11821953319763968,11822043514273792,11822030628978688,12103557145821186,12103509901180930,12103587210592258,12103501311246338,12103570030723074,12103531376017410,12103591505559554,12103492721311746,12103582915624962,12103488426344450,12103578620657666,12103484131377154,12103497016279042,12103574325690370,12103565735755778,12385062187171842,12385066482139138,12385032122400770,12385057892204546,12385040712335362,12385006352596994,12384963402924034,12384967697891330,12385053597237250,12384959107956738,12385049302269954,12384976287825922,12384971992858626,12384984877760514,12385045007302658,12666528573882370,12666446969503746,12666481329242114,12666532868849666,12666519983947778,12666541458784258,12666524278915074,12666537163816962,12666515688980482,12666507099045890,12666442674536450,12666459854405634,12666434084601858,12666451264471042,12666438379569154,12948007845691394,12947917651378178,12947999255756802,12947913356410882,12948003550724098,12947934831247362,12947994960789506,12947921946345474,12947909061443586,12947982075887618,12948012140658690,12947956306083842,12947926241312770,12948016435625986,12947990665822210,13229435578875904,13229323909660672,13510944914341890,13510949209309186,13510953504276482,13510932029440002,13510957799243778,13510859014995970,13510876194865154,13510884784799746,13510906259636226,13510867604930562,13510966389178370,13510871899897858,13510940619374594,13510863309963266,13510962094211074,13792385529675776,13792273860657152,13792312515035136,13792488611643393,13792389824839680,13792303925362688,13792480021643265,13792333989216258,14073808969596928,14355232405061632,14355451450097665,14355223815061504,14355314009636864,14355228110159872,14355318304669696,14355236700160000,14355305419374592,14355279649505280,14636698791772160,14636707381772288,14636780396085248,14636926426873857,14636788986347520,14636711676870656,14636754626215936,14636703086870528,14636793281380352,14918263963058176,14918401403650049,14918268258091008,14918173768482816,14918255372795904,14918178063581184,14918229602926592,14918186653581312,14918182358482944,15199648747159552,15481351357202433,15481136607002624,15481179556347904,15481205326217216,15481213916479488,15481128017002496,15481132311904256,15481123721904128,15481218211512320,15762688893190144,15762654533058560,15762826333978625,15762680302927872,15762611583713280,15762693188222976,15762607288614912,15762602993713152,15762598698614784,16044168164933632,16044163869900800,16044086560423936,16044301310754817,16044077970423808,16044155279638528,16044082265325568,16044129509769216,16044073675325440,16325604486479872,16325638846611456,16325561537134592,16325552947134464,16325548652036096,16325643141644288,16325776287531009,16325630256349184,16325557242036224,16607105233059840,16607113823322112,16607032218746880,16607023628746752,16607027923845120,16607079463190528,16607036513845248,16607118118354944,16607251264307201,16888511490555904,16888580209770496,16888507195457536,16888498605457408,16888726241083393,16888593095065600,16888502900555776,16888554439901184,16888588800032768,17169982172168192,17170029416611840,17169977877266432,17170055186481152,17170201217859585,17170063776743424,17169973582168064,17169986467266560,17170068071776256,17451504391159810,17451538750898178,17451448556584962,17451560225734658,17451452851552258,17451564520701954,17451568815669250,17451530160963586,17451487211290626,17451577405603842,17451551635800066,17451470031421442,17451547340832770,17451495801225218,17451543045865474,17451461441486850,17451478621356034,17451573110636546,17451457146519554,17733086745460736,17733082450165760,17733000845721600,17733078155395072,17733091040362496,17733069565132800,17733073860362240,17733065270034432,17732983667621888,17733056680427520,17733030910361600,17732987961278464,18014531656089602,18014475822432256,18014462936612866,18014548837072896,18014557425893378,18014458641645570,18014505886285826,18014566017073152,18014540246745088,18014544541843456,18014467231580162,18014484411449346,18014471526547458,18014561720860674,18014553132105728,18295929326141440,18577412892852224,18858883574661120,19140298421895168,19421872182919168,19703394402107392,19703334271385602,19703308501581826,19703321386483714,19703390105960450,19703398697336832,19703381516025858,19703402992369664,19703411580796930,19703407285829634,19703317091516418,19703415877337088,19703312796549122,19703355746222082,19703325682696192,19984877969080320,19984800659406848,19984792068489218,19984796363456514,19984886559145984,19984882262802434,19984873674047488,19984856492998658,19984783478554626,19984809248358402,19984869378818048,19984865083719680,19984830723194882,19984787773521922,19984890854047744,20266284224937986,20266340059512834,20266365830758400,20266258455134210,20266348650758144,20266344354480130,20266267045068802,20266305699774466,20266352945790976,20266331469578242,20266271340036098,20266361534349314,20266262750101506,20266275636117504,20266357239382018,20547815036747778,20547780677009410,20547746317271042,20547806446813186,20547823626682370,20547827921649666,20547750612238338,20547737727336450,20547819331715074,20547729140154368,20547733432369154,20547832216616962,20547759202172930,20547836511584258,20547742022303746,20547840806551554,20829281424244736,20829315784179712,20829212703784962,20829255654178816,20829208408817666,20829216998752258,20829298604179456,20829307193065474,20829234178621442,20829221293719554,20829302899212288,20829225589538816,20829311489277952,20829290013851648,20829294308950016,21110691975593986,21110786465988608,21110782169907202,21110769285660672,21110700566249472,21110790760890368,21110764990562304,21110687680626690,21110777875922944,21110709155463170,21110696270561282,21110683385659394,21110730630889472,21110773580890112,21110756400103426,21392158361780226,21392265737601024,21392205606420482,21392162656747522,21392184131584002,21392231376224258,21392239966158850,21392171246682114,21392252852633600,21392257146028034,21392248556093442,21392175542960128,21392244261126146,21392166951714818,21392261440995330,21673706353065986,21673736417837058,21673719237967874,21673740712804354,21673646223523842,21673727827902466,21673680583262210,21673732122869762,21673659108425730,21673714943000578,21673650519670784,21673633338621954,21673723532935170,21673637633589250,21673641928556546,21955215689908226,21955202806054912,21955134085529602,21955112610693122,21955108315725826,21955125496381440,21955194215071746,21955198510039042,21955189920104450,21955116905660418,21955207099973634,21955211394940930,21955181330169858,21955121200627714,21955155560366082,22236587587141634,22236686371389442,22236664897404928,22236682076422146,22236673487732736,22236656306618370,22236600473092096,22236609061978114,22236630536814594,22236669192503296,22236677782765568,22236591882108930,22236596177076226,22236583292174338,22236690667732992,22518152759476224,22518157054246912,22518144169213952,22518066862096384,22518148464443392,22518139874115584,22518165644443648,22518105514442752,22518075449802752,22518131284508672,22518161349541888,22518062565359616,22799606261088258,22799550426513410,22799640620826626,22799559016448002,22799636325859330,22799614851022850,22799533246644226,22799619145990146,22799632030892034,22799623440957442,22799537541611522,22799546131546114,22799541836578818,22799627735924738,22799580491284482,23081008225648640,23362650706149377,23362478904246272,23362435954900992,23362504674115584,23362431659802624,23362517559410688,23362427364900864,23362423069802496,23362513264377856,23643996833906688,23925583479832577,23925433150930946,23925458925846528,24206856588558338,24206903833198594,24206938192936962,24206860883525634,24206959667773442,24207071341576193,24206968257708034,24206942487904258,24206895243264002,24206847998623746,24206852293591042,24206929603002370,24206886653329410,24206878063394818,24206976847642626,24206951077838850,24206946782871554,24206963962740738,24488322976645120,24488554908352513,24488327271743488,24488413171220480,24488417466253312,24488378811088896,24488404580958208,24488383106973698,24488335861743616,24488550613319681,24488331566645248,24769870967865346,24769905327603714,24769862377930754,24769866672898050,24769956867211266,24769939687342082,24769952572243970,24769931097407490,24769858082963458,24769943982309378,24769883852767234,24769965457145858,24769961162178562,24769948277276674,24769875262832642,25051380304904194,25051406074707970,25051431844511746,25051418959609858,25051423254577154,25051337355231234,25051427549544450,25051333060263938,25051341650198530,25051440434446338,25051414664642562,25051358830067714,25051436139479042,25051350240133122,25051345945165826,25332898231549952,25332855281549312,25332902526582784,25332915411550208,25332816629792768,25332825216909312,25332881051615232,25332812332466176,25332889641222144,25332893936320512,25332906821353472,25332911116648448,25614252946948098,25614338846294018,25614351731195906,25614343141261314,25614235767078914,25614222882177026,25614325961392130,25614278716751874,25614313076490242,25614334551326722,25614231472111618,25614446225391617,25614321666424834,25614261536882690,25614317371457538,25614227177144322,25614270126817282,25614304486555650,25895757987840002,26177172835926016,26177284504944640,26177288800108544,26177202900631552,26177211490304000,26177387588943873,26458647817551872,26458742303227904,26458652108718080,26458841091276801,26458738008195072,26458759481655296,26458660698718208,26458695062126592,26458703648063488,26458746601865216,26458656403619840,26458768076767232,26458875450621953,26458729417932800,26458862560477185,26458686467014656,26458866861146113,26458776666439680,26458750897094656,26458677877342208,26458763776819200,26740200100462592,26740255935168512,26740230165102592,26740182920790018,26740281704906752,26740277410136064,26740264524775424,26740359017922561,26740286000201728,26740290295103488,26740273115103232,26740187216019456,26740268819873792,26740208694001664,27021657901039616,27303132873883650,27303180118523906,27303150053752834,27303227363164162,27303141463818242,27303218773229570,27303223068196866,27303158643687426,27303235953098754,27303240248066050,27303231658131458,27303214478262274,27303145758785538,27303137168850946,27303205888327682,27584552015560704,27584676573282304,27584659388497920,27584586373857280,27584629324775424,27584762467319809,27584650804199424,27584663683661824,27584637915037696,27584603554906112,27584556310462464,27584594968969216,27584646508707840,27584577784184832,27584766767988737,27584642210070528,27584775357464577,27584667983609856,27584740998119425,27584560605560832,27584547724394496,27866022701760512,28147652293689344,28147639408328704,28147574987948032,28147656588460032,28147660883755008,28147665178656768,28147562103111680,28147643703427072,28147630818721792,28147605048655872,28147647998656512,28429028489953280,28710542116913152,28710451922403328,28710460512403456,28710503461748736,28710537821880320,28710447627304960,28710675265421313,28710529231618048,28710456217305088,28992029978656770,28991999913885698,28992055748460546,28992081518264322,28992072928329730,28992060047884288,28991987028983810,28992085813231618,28992064338395138,28992077223297026,28991922602639362,28992068633362434,28992090108198914,29273453413990402,29273397579415554,29273401874382850,29273487773728770,29273620924006401,29273526428434434,29273410464317442,29273436234121218,29273406169350146,29273500658630658,29273444824055810,29273513543532546,29273496363663362,29273427644186626,29273509248565250,29273479183794178,29273517838499842,29273492068696066,29554928397058048,29836450612707330,29836437727805442,29836429137870850,29836467792576514,29836386188197890,29836446317740034,29836403368067074,29836442022772738,29836394778132482,29836347533492226,29836459202641922,29836377598263298,29836351828459522,29836360418394114,29836356123426818,29836476382511106,29836472087543810,29836463497609218,30117869754253314,30117921293860866,30117822509613058,30117835394514946,30117852574384130,30117904113991682,30117951358631938,30117826804580354,30117831099547650,30117916998893570,30117878344187906,30117938473730050,30117912703926274,30117925588828162,30117861164318722,30117942768697346,30117934178762754,30399400571895808,30680828298723328,30680776759377920,30680772464279552,30680854068592640,30681000102723585,30680862658854912,30680781054279680,30680866953887744,30680785349378048,30962307571384322,31243868446785538,31243782547439618,31243829792079874,31243877036720130,31243795432341506,31243889921622018,31243791137374210,31243885626654722,31243799727308802,31243855561883650,31243786842406914,31243864151818242,31243872741752834,31243881331687426,31243808317243394,31525300471398402,31525197392183298,31525227456954370,31525218867019778,31525313356300290,31525236046888962,31525309061332994,31806732498829314,31806758273744896,31806882829762561,32088147353141248,32369703928856576,32369716814151680,32369622324543488,32369678158987264,32369626619641856,32369712519118848,32369635209641984,32369849963184129,32369630914543616,32651178905567232,32651110186352640,32651105891254272,32651324939960321,32651191790862336,32651101596352512,32651187495829504,32651097301254144,32651153135697920,32932649588097024,32932705422802944,32932714012409856,32932726897770496,32932731192541184,32932636703653888,32932735487836160,32932679652737024,32932739782737920,32932718307508224,32932645297913856,32932722602737664,33214274893512705,33214137449250816,33214141744283648,33214051549773824,33214055844675584,33214060139773952,33214128858988544,33214103089119232,33214047254675456,33495522235318272,33495749868388353,33495736978243585,33495578065829888,33495616720994304,33495612425961472,33495638194585600,33495526526484480,33495569479892992,33495603835699200,33495621019631616,33495651084206080,33495530821386240,33495535116484608,33495625316237312,33495560884781056,33495741278912513,33495552295108608,33495642494533632,33495633899421696,33495715509043201,33777087402672128,33777053042540544,33777001503195136,33776997208096768,33777091697704960,33777224847065089,33777010093195264,33777078812409856,33777005798096896,34058489361924098,34058716995190786,34340007291977730,34340097486290944,34340183390486529,34340110371389440,34340088895963136,34340093191061504,34340106076094464,34340024471650304,34340033065189376,34340054536290304,34340114666291200,34340011587207168,34340080306356224,34340101781323776,34621482266001410,34902974424481794,34903060323827714,34903047438925826,34903064618795010,34903030259056642,34903038848991234,34902961539579906,34903056028860418,34902952955346944,34903043143958530,34903004489252866,34903051733893122,35184436517339136,35184505236488192,35184522416422912,35184440817025024,35184449401782272,35184535301521408,35184531006226432,35184513826095104,35184526711455744,35184539596423168,35184518121193472,35184479466422272,35466010278232064,35465988802805760,35465911494049792,35466005982937088,35465980213198848,35466001688166400,35466014573133824,35465907203866624,35465997393133568,35465924378492928,35465954443132928,35465993097904128,35747450893369346,35747433713500162,35747420828598274,35747326339317762,35747442303434754,35747446598402050,35747416533630978,35747438008467458,35747360699056130,35747377878925314,35747412238663682,35747322044350466,35747352109121538,35747425123565570,35747334929252354,35747369288990722,35747403648729090,35747330634285058,36028943051325440,36028904396554240,36028964526555136,36028930166620160,36028947346554880,36028861447471104,36028955936358400,36028951641587712,36028938756227072,36028874331914240,36028870042255360,36028960231653376,36310400846331906,36310319241953282,36310327831887874,36310284882214914,36310366486593538,36310392256397314,36310396551364610,36310383666462722,36310280587247618,36310271997313026,36310353601691650,36310375076528130,36310310652018690,36310276292280322,36310362191626242,36310387961430018,36310302062084098,36310370781560834,36591893004746752,36591811400892416,36591880120041472,36591914479976448,36591888709648384,36591807110840320,36591905889779712,36591901595009024,36591897299976192,36591824285335552,36591910185074688,36591854349975552,36873282082439170,37154787123200000,37154709813723136,37154791418232832,37154924565299201,37154705518624768,37154701223723008,37154696928624640,37154752763068416,37154757058953218,37154928863019009,37154778532937728,37436309350514688,37436322229256194,37436305049387010,37436339409125378,37436249214812162,37436335114158082,37436279279583234,37436330819190786,37436313639321602,37436317934288898,37436236329910274,37436326524223490,37717762845245440,37717655472046080,37717646885978112,37717745670291456,37717775734865920,37717741371654144,37717767145193472,37717865931669505,37717651177144320,37717685535440896,37717728486359040,37717694130552832,37717861628903425,37717758550081536,37717840159703041,37717737076621312,37717874519048193,37717702716489728,37717659767144448,37717676945768448,37999242116923394,37999151922610178,37999134742740994,37999212052152322,37999130447773698,37999121857839106,37999160512544770,37999250706857986,37999233526988802,37999169102479362,37999177692413954,37999126152806402,37999220642086914,37999203462217730,37999224937054210,37999216347119618,37999237821956098,37999246411890690,38280811582324737,38280687030042624,38280635488862208,38280652669911040,38280626899189760,38280695623712768,38280712798666752,38280605425467392,38280644083974144,38280717098614784,38280824472469505,38280678439780352,38280790113124353,38280601130565632,38280609720565760,38280708503502848,38280691325075456,38280815885156353,38280725688287232,38280596839399424,38562131948142592,38843602623332352,38843551083986944,38843774428643329,38843555378888704,38843641278496768,38843559673987072,38843636983463936,38843546788888576,38843628393201664,39125051829387266,39125060419321858,39125142023700482,39125137728733186,39125103368994818,39125116253896706,39125030354550786,39125069009256450,39125133433765890,39125120548864002,39125021764616194,39125026059583490,39125034649518082,39125077599191042,39125124843831298,39125150613635074,39125111958929410,39125146318667778,39406612705378306,39406599820476418,39406595525509122,39406586935574530,39406505331195906,39406591230541826,39406621302915072,39406625590280194,39406501036228610,39406608410411010,39406535395966978,39406509626163202,39406617000345602,39406578345639938,39406543985901570,39406552575836162,39406526806032386,39406496741261314,39688122043072514,39688134927974402,39688036143726594,39688126338039810,39688044740083712,39688139222941698,39688117748105218,39688130633007106,39688049028628482,39688079093399554,39688104863203330,39688113453137922,39969519716859904,39969511121420288,39969592725274624,39969609905602560,39969601315536896,39969614200504320,39969579840569344,39969554070503424,39969588430176256,39969597020504064,39969605610307584,39969524005863424,40251050525261824,40251114950098945,40250960325836800,40251037635641344,40250921676374016,40251041935589376,40251033340477440,40251140722524161,40251136419299329,40251016162050048,40250968920948736,40250930262441984,40251003276754944,40250925967540224,40251020460687360,40250934557540352,40251149309444097,40251011867017216,40250977506885632,40250951736164352,40532521202417666,40532435303071746,40532452482940930,40532516907450370,40532495432613890,40532525497384962,40532508317515778,40532499727581186,40532426713137154,40532478252744706,40532409533267970,40532405238300674,40532443893006338,40532491137646594,40532400943333378,40532396648366082,40532512612483074,40532486842679298,40813875919978498,40813996179062786,40814000474030082,40813953229389826,40813880214945794,40813987589128194,40813918869651458,40813884509913090,40813961819324418,40813910279716866,40813927459586050,40813970409259010,40813983294160898,40813966114291714,40813974704226306,40813901689782274,40813991884095490,40813871625011202,41095376666230786,41095350896427010,41095436795772930,41095428205838338,41095355191394306,41095402436034562,41095393846099970,41095475450478594,41095462565576706,41095445385707522,41095359486361602,41095466860544002,41095471155511298,41095449680674818,41095346601459714,41095441090740226,41095385256165378,41095458270609410,];

pub fn make_parser<'lt>() -> ZCParser<Construct<'lt>,Construct<'lt>>
{
 let mut parser1:ZCParser<Construct<'lt>,Construct<'lt>> = ZCParser::new(60,147);
 let mut rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("start");
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Program");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Classes(cs),Maincl(mc),)=(_item1_.value,_item0_.value,) {  Program(parser.lb(mc),cs) }  else {parser.bad_pattern("(Classes(cs),Maincl(mc),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MainCl");
 rule.Ruleaction = |parser|{ let mut _item16_ = parser.popstack(); let mut _item15_ = parser.popstack(); let mut _item14_ = parser.popstack(); let mut _item13_ = parser.popstack(); let mut _item12_ = parser.popstack(); let mut _item11_ = parser.popstack(); let mut _item10_ = parser.popstack(); let mut _item9_ = parser.popstack(); let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(thebody),Id(an),Id(cn),)=(_item14_.value,_item11_.value,_item1_.value,) { 
   Maincl(Mainclass{classname:cn,
             argvname:an,
             body: Blockst(thebody),
	    })
  }  else {parser.bad_pattern("(Stms(thebody),Id(an),Id(cn),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{  Classes(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Class(cl),Classes(mut cs),)=(_item1_.value,_item0_.value,) { 
  cs.push(parser.lbx(1,cl)); Classes(cs)
  }  else {parser.bad_pattern("(Class(cl),Classes(mut cs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDec");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),Id(sup),Id(name),)=(_item4_.value,_item2_.value,_item1_.value,) { 
  let mut vdecs=Vec::new();
  let mut mdecs=Vec::new();
  separatedecs(ds,&mut vdecs,&mut mdecs); /*split var and method declarations*/
  Class(ClassDec {superclass:sup,
                  classname:name,
		  vars:vdecs,
		  methods:mdecs})
  }  else {parser.bad_pattern("(Decs(mut ds),Id(sup),Id(name),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{ let mut sup = parser.popstack(); let mut _item0_ = parser.popstack();  sup.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{  Id("Object") };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(v),Id(t),)=(_item1_.value,_item0_.value,) {  Vdec(VarDec{dname:v,dtype:t,initval:Nothing,}) }  else {parser.bad_pattern("(Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),Id(t),)=(_item3_.value,_item1_.value,_item0_.value,) { 
  Vdec(VarDec{dname:v,dtype:t,initval:e})
  }  else {parser.bad_pattern("(Exp(e),Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MethodDec");
 rule.Ruleaction = |parser|{ let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(mbody),Vdecs(args),Id(name),Id(ty),)=(_item7_.value,_item4_.value,_item2_.value,_item1_.value,) { 
  Method(MethodDec{ formals:args,
                    body: mbody,
		    classname:ty,
		    methodname:name, })
  }  else {parser.bad_pattern("(Stms(mbody),Vdecs(args),Id(name),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{  Decs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(parser.lbx(1,v.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(makelbox!(m,m.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item2_.value,_item1_.value,_item0_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item3_.value,_item2_.value,_item1_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack();  return Id("int[]"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("boolean"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("String"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("int"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("void"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut c = parser.popstack();  c.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{  Stms(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Stms(mut sv),)=(_item1_.value,_item0_.value,) {  sv.push(makelbox!(_item1_,s)); Stms(sv) }  else {parser.bad_pattern("(Stm(s),Stms(mut sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(sv),)=(_item1_.value,) {  Stm(Blockst(sv)) }  else {parser.bad_pattern("(Stms(sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(b),Stm(a),Exp(c),)=(_item6_.value,_item4_.value,_item2_.value,) { 
  Stm(Ifstat(makelbox!(_item2_,c), makelbox!(_item4_,a), makelbox!(_item6_,b)))
  }  else {parser.bad_pattern("(Stm(b),Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(a),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Ifstat(makelbox!(_item2_,c),makelbox!(_item4_,a),parser.lbx(5,Nopst))) }  else {parser.bad_pattern("(Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Whilest(parser.lbx(2,c),parser.lbx(4,s))) }  else {parser.bad_pattern("(Stm(s),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),)=(_item2_.value,_item0_.value,) {  Stm(Assignst(v,parser.lbx(2,e))) }  else {parser.bad_pattern("(Exp(e),Id(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Exp(i),Exp(v),)=(_item5_.value,_item2_.value,_item0_.value,) { 
  Stm(ArAssignst(parser.lbx(0,v),parser.lbx(2,i),parser.lbx(5,e)))
  }  else {parser.bad_pattern("(Exp(e),Exp(i),Exp(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(m),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) { 
  Stm(Callstat(parser.lb(obj),m,args))
  }  else {parser.bad_pattern("(Exps(args),Id(m),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),)=(_item1_.value,) {  Stm(Returnst(parser.lbx(1,e))) }  else {parser.bad_pattern("(Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Vdec(v),)=(_item0_.value,) { Stm(Vardecst(v.dname,v.dtype,parser.lb(v.initval)))}  else {parser.bad_pattern("(Vdec(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("*",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("+",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("/",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("-",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("&&",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("OROR",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(a),)=(_item1_.value,) {  Exp(Notexp(parser.lbx(1,a))) }  else {parser.bad_pattern("(Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("<",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("%",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("==",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(i),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("[]",parser.lbx(0,a),parser.lbx(2,i)))}  else {parser.bad_pattern("(Exp(i),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(field),Exp(obj),)=(_item2_.value,_item0_.value,) {  Exp(Field(field,parser.lbx(0,obj))) }  else {parser.bad_pattern("(Id(field),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(f),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) {  Exp(Callexp(parser.lb(obj),f,args)) }  else {parser.bad_pattern("(Exps(args),Id(f),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (i,)=(_item0_.value,) {  i }  else {parser.bad_pattern("(i,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack();  s.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (b,)=(_item0_.value,) {  b }  else {parser.bad_pattern("(b,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item0_.value,) {  Exp(Var(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  Exp(Thisptr) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(s),)=(_item3_.value,) {  Exp(Newarray(parser.lbx(3,s))) }  else {parser.bad_pattern("(Exp(s),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item1_.value,) {  Exp(Newobj(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item1_.value,_item0_.value,) {  er.push(parser.lbx(0,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item2_.value,_item1_.value,) {  er.push(parser.lbx(1,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Construct<'lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..1263 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser


// Lexical Scanner using RawToken and StrTokenizer
pub struct mjlexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> mjlexer<'t> 
{
  pub fn from_str(s:&'t str) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> mjlexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["class","public","static","void","main","String","extends","return","length","new","this","int","boolean","if","else","while",] {keywords.insert(kw);}
    for c in ['(',')','[',']',';','!',',','=','+','-','*','/','<','.','%','{','}',] {stk.add_single(c);}
    for d in ["==","&&","||",] {stk.add_double(d);}
    mjlexer {stk,keywords}
  }
}
impl<'lt> Tokenizer<'lt,Construct<'lt>> for mjlexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,Construct<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<Construct<'lt>>::default())),
      RawToken::Alphanum("true") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(true)))),
      RawToken::Alphanum("false") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(false)))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"ID",Id(x))),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"INTEGER",Exp(Int(n as i32)))),
      RawToken::Strlit(s) => Some(TerminalToken::from_raw(token,"STRING",Exp(Strlit(s)))),
      RawToken::Symbol(r".") => Some(TerminalToken::from_raw(token,"DOT",<Construct<'lt>>::default())),
      RawToken::Symbol(r"%") => Some(TerminalToken::from_raw(token,"MOD",<Construct<'lt>>::default())),
      RawToken::Symbol(r"{") => Some(TerminalToken::from_raw(token,"LBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"}") => Some(TerminalToken::from_raw(token,"RBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"||") => Some(TerminalToken::from_raw(token,"OROR",<Construct<'lt>>::default())),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<Construct<'lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<Construct<'lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<Construct<'lt>,Construct<'lt>>)
{
}//end of load_extras: don't change this line as it affects augmentation

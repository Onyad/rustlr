//Parser generated by rustlr for grammar mj

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use rustlr::{LBox,makelbox};
use crate::absyntax::*;
use crate::absyntax::Construct::*;
use crate::absyntax::Expr::*;
use crate::absyntax::Stat::*;

static SYMBOLS:[&'static str;58] = ["ID","INTEGER","STRING","BOOL","class","public","static","void","main","String","extends","return","length","(",")","[","]",";","DOT","!",",","new","this","LBR","RBR","OROR","int","boolean","if","else","while","==","=","+","-","*","/","<","&&","MOD","Program","MainCl","ClassDec","ClassDecl","Extension","VarDec","MethodDec","Decl","FormalLst","FormalRst","Type","Stat","Stats","Exp","ExpLst","ExpRst","START","EOF"];

static TABLE:[u64;1263] = [171798757377,176093790209,17180065792,281719789846531,563134637277185,563194766688258,562967133421570,844424930459648,1126144719978498,1125917087170560,1126080295862273,1407473668325376,1688867040329730,1689094673596418,1970324837564416,2251821289177088,2533463769743361,2533317740789760,2533373575036930,2814775537762304,3096224744734720,3377798505758720,3659204763058176,3940748458524674,4222154716086274,4222326515236865,4222236320464898,4222124651315202,4222227730530306,4222240615432194,4222163306020866,4222146126151682,4503633988288512,4785190570033152,4785186274607104,4785177684869120,4785074605391872,4785272174084097,4785096080556032,4785113260490752,4785104670621696,4785267879051265,4785289353691137,5066605417267200,5348024559468544,5629499535654914,5910974512234498,5911038937464832,6192449488355330,6192552567570434,6192565452472322,6192488143060994,6192561157505026,6192470963191810,6192479553126402,6474036134281218,6473924465131522,6473963119837186,6474040429248514,6473945939968002,6474027544346626,6473954529902594,6755416621187074,6755644254453762,7036986088292352,7037089168228353,7036904484306944,7036990383718400,7036874419077120,7036913074176000,7318349395722242,7599824372563970,7881299349078018,8162812981477376,8444322318057472,8444386742501376,8725792999866368,9007199257165824,9288738658451456,9570157800980480,9570149211111424,9570162095751168,9570153505751040,9570243700195328,9570205045817344,9570230815555584,9570376843984897,9570239405293568,9851637070233602,9851628480299010,9851748739383298,9851740149448706,9851714379644930,9851753034350594,9851705789710338,9851718674612226,9851744444416002,9851624185331714,9851735854481410,9851722969579522,9851662840037378,9851727264546818,9851671429971970,9851680019906562,9851645660168194,9851654250102786,9851632775266306,10133099162697730,10414629976014848,10696117837692928,10977601404993536,10977683008978944,10977670123945984,10977687304011776,10977588519501824,10977665829634048,10977657239109632,10977674419306496,10977631469568000,10977597110091776,10977691599044608,10977678714339328,11259140805427202,11259145100394498,11259059201048578,11259067790983170,11259084970852354,11259166575230978,11259149395361794,11259162280263682,11259072085950466,11259157985296386,11259076380917762,11259063496015874,11259153690329090,11259132215492610,11259106445688834,11540620077236226,11540615782268930,11540534177890306,11540637257105410,11540551357759490,11540559947694082,11540538472857602,11540632962138114,11540581422530562,11540547062792194,11540607192334338,11540628667170818,11540641552072706,11540624372203522,11540542767824898,11822103644012546,11822107938979842,11822112233947138,11822034924535810,11822009154732034,11822090759110658,11822082169176066,11822056399372290,11822026334601218,11822099349045250,11822116528914434,11822022039633922,11822095054077954,11822013449699330,11822017744666626,12103535671771136,12103424002686976,12385006352596994,12385066482139138,12384976287825922,12385062187171842,12385049302269954,12385053597237250,12384967697891330,12384984877760514,12384963402924034,12384959107956738,12384971992858626,12385057892204546,12385040712335362,12385032122400770,12385045007302658,12666442674733058,12666481329438722,12666434084798466,12666451264667650,12666528574078978,12666507099242498,12666446969700354,12666541458980866,12666515689177090,12666537164013570,12666524279111682,12666532869046274,12666519984144386,12666459854602242,12666438379765762,12947853226278912,12947943420723200,12947904766345216,12948076566151169,12947930536083456,12947939125821440,12947848931639296,12947861816279040,12947857521508352,13229328202989568,13229418397433856,13229414102532096,13229332498219008,13229323908349952,13229405512794112,13229336792989696,13229551542927361,13229379743055872,13511013634867201,13510910552637440,13510837538521088,13510798883422208,13510859012505602,13511005044867073,13510914848063488,13510828948652032,13792273863278592,14073757428350976,14073804673187840,14073748838481920,14073976473321473,14073830442926080,14073761723121664,14073753133121536,14073843327565824,14073839032664064,14355228109832192,14355305419636736,14355223815192576,14355279649898496,14355451450097665,14355232405061632,14355236699832320,14355318304276480,14355314009374720,14636793280987136,14636926426873857,14636711676542976,14636788986085376,14636780396347392,14636698791903232,14636754626609152,14636707381772288,14636703086542848,14918186653253632,14918255373058048,14918268257697792,14918173768613888,14918182358482944,14918229603319808,14918178063253504,14918263962796032,14918401403650049,15199661629964288,15199648745324544,15199738939506688,15199730349768704,15199653039964160,15199657335193600,15199743234408448,15199704580030464,15199876380426241,15481218211119104,15481351357202433,15481123722035200,15481213916217344,15481128016674816,15481205326479360,15481132311904256,15481179556741120,15481136606674944,15762598698745856,15762602993385472,15762688892928000,15762826333978625,15762654533451776,15762611583385600,15762607288614912,15762693187829760,15762680303190016,16044168164540416,16044163869638656,16044082265325568,16044086560096256,16044301310754817,16044155279900672,16044077970096128,16044129510162432,16044073675456512,16325638846349312,16325604486873088,16325548652167168,16325552946806784,16325643141251072,16325557242036224,16325561536806912,16325630256611328,16325776287531009,16607023631040512,16888520078000130,16888537257869314,16888601682378754,16888507193098242,16888554437738498,16888627452182530,16888528667934722,16888614567280642,16888597387411458,16888511488065538,16888580207542274,16888588797476866,16888610272313346,16888498603163650,16888502898130946,16888545847803906,16888593092444162,16888618862247938,16888623157215234,17169986466938880,17170029417005056,17170055186743296,17170201217794049,17170068071383040,17169973582299136,17169977876938752,17169982172168192,17170063776481280,17451512985812992,17732979372654592,18014505886285826,18014462936612866,18014458641645570,18014540247400448,18014544541712384,18014561720860674,18014471526547458,18014566016811008,18014557425893378,18014531656089602,18014553132105728,18014467231580162,18014475822759936,18014548837072896,18014484411449346,18295937913978880,18296032403456000,18295950799470592,18296006633586688,18296019518423040,18296028108816384,18295980864045056,18296036698488832,18296015224111104,18296023813783552,18296040993521664,18295933621108736,18577408597884928,18858823445118976,19140358551437312,19421915130953728,19421932310298624,19421936605331456,19421923720626176,19421940900364288,19421906540429312,19421928015659008,19421837820821504,19421880770887680,19421919425265664,19421850706313216,19421842118148096,19703312796680194,19703317091647490,19703334271516674,19703321386614786,19703394401058818,19703325683023872,19703398697336832,19703402992369664,19703308501712898,19703381516156930,19703415877074944,19703390106091522,19703355746353154,19703407285960706,19703411580928002,19984809248620546,19984856493260802,19984890853785600,19984869378686976,19984882263064578,19984800659734528,19984792068751362,19984886558752768,19984830724308992,19984865084375040,19984787773784066,19984873674047488,19984877969080320,19984796363718658,19984783478816770,20266275636445184,20266361535463424,20266331470561280,20266284225200130,20266348650758144,20266344355397632,20266357239644162,20266365830496256,20266267045330946,20266262750363650,20266340061085696,20266271340298242,20266305701019648,20266258455396354,20266352945790976,20547750613155840,20547823627468800,20547819332108288,20547746316812290,20547806446354434,20547815037796352,20547742021844994,20547780676550658,20547836511125506,20547827922501632,20547737726877698,20547840807206912,20547759201714178,20547733431910402,20547832216158210,20829298603196418,20829294308229122,20829216998817794,20829307193131010,20829281423327234,20829221293785090,20829315783065602,20829212703850498,20829311488098306,20829208408883202,20829255653523458,20829234178686978,20829302899212288,20829225589866496,20829290013261826,21110709155201026,21110696270299138,21110687680364546,21110730630037506,21110756399841282,21110773580890112,21110764991217664,21110683385397250,21110782169645058,21110691975331842,21110700566577152,21110777875922944,21110769285529600,21110786465595392,21110790760628224,21392171246682114,21392166951714818,21392257146028034,21392162656747522,21392252852633600,21392184131584002,21392265737338880,21392244261126146,21392205606420482,21392158361780226,21392248556093442,21392261440995330,21392239966158850,21392175543287808,21392231376224258,21673680583262210,21673659108425730,21673633338621954,21673740712804354,21673646223523842,21673714943000578,21673732122869762,21673723532935170,21673736417837058,21673637633589250,21673706353065986,21673641928556546,21673650519998464,21673727827902466,21673719237967874,21955194215268354,21955181330366466,21955116905857026,21955112610889730,21955198510235650,21955125495791618,21955211395137538,21955202805202946,21955121200824322,21955108315922434,21955215690104834,21955134085726210,21955207100170242,21955189920301058,21955155560562690,21955104023707648,22236600473419776,22236630536617986,22236686371192834,22236669192372224,22236591881912322,22236673487732736,22236583291977730,22236664896356354,22236656306421762,22236682076225538,22236690667470848,22236677782765568,22236596176879618,22236609061781506,22236587586945026,22518053974507520,22518011024441344,22518002434441216,22518225775886337,22517998139801600,22518088333983744,22518092628885504,22518006729670656,22518079744245760,22799533248937984,23081025403224066,23081089827733506,23081098417668098,23081081237798914,23081115597537282,23081055467995138,23081111302569986,23081016813289474,23081107007602690,23081094122700802,23081102712635394,23081033993158658,23081008223354882,23081021108256770,23081012518322178,23362521857130496,23643958174220290,23644108503121921,23643983949004800,23925471810748416,24206933899345922,24207011208757250,24206925309411330,24207006913789954,24206994028888066,24206912424509442,24206916719476738,24206955374182402,24206921014444034,24206998323855362,24206908129542146,24207002618822658,24207015503724546,24206981143986178,24206989733920770,24488383106973698,24488378811482112,24488417465860096,24488413170958336,24488550613254145,24488327271415808,24488322976776192,24488335861415936,24488331566645248,24488404581220352,24488554908286977,24769862378323968,24769952573161472,24769948278128640,24769905328390144,24769875263815680,24769931097931776,24769965457866752,24769956867801088,24769961162833920,24769943982768128,24769866676305920,24769939688456192,25051423254577154,25051406074707970,25051358830067714,25051345945165826,25051414664642562,25051418959609858,25051337355231234,25051427549544450,25051431844511746,25051436139479042,25051341650198530,25051380304904194,25051350240133122,25051333060263938,25051440434446338,25332859574616066,25332760790368258,25332876754485250,25332842394746882,25332846689714178,25332747905466370,25332838099779586,25332777970237442,25332795150106626,25332756495400962,25332850984681474,25332863869583362,25332829509844994,25332868164550658,25332971248615425,25332786560172034,25332803740041218,25332752200433666,25614437635457025,25614334551195648,25614338846621696,25614252947210240,25614222881980416,25614261537079296,25895757987840002,26177220080238594,26177181425532930,26177228670173186,26177293094682626,26177288799715330,26177185720500226,26177263029911554,26177396178878465,26177172835598338,26177284504748034,26177271619846146,26177301684617218,26177202900369410,26177275914813442,26177254439976962,26177211490304002,26177177130565634,26177267324878850,26458712238587904,26458798138392576,26458780958195712,26458789548720128,26458707944079362,26458793843032064,26458811023097856,26458806728065024,26458725124079616,26458733716701184,26458815318130688,26458802433425408,26458884040622081,26458755188654080,26740182923739136,27021662192140290,27021743796518914,27021748091486210,27021760976388098,27021670782074882,27021705141813250,27021657897172994,27021765271355394,27021666487107586,27021752386453506,27021683666976770,27021730911617026,27021756681420802,27021675077042178,27021739501551618,27303193006833664,27303266021736449,27303188706885632,27303111397343232,27303201596899328,27303128578588672,27303300381081601,27303102807474176,27303167232966656,27303119992651776,27303077038522368,27303184411459584,27303085628522496,27303287490543617,27303171532193792,27303162938064896,27303291791015937,27303072748077056,27303081333751808,27303154348326912,27303175827357696,27584547724984320,27866237443964929,27866117186387968,27866250334502913,27866052760895488,27866104301748224,27866035581943808,27866061350764544,27866138660306944,27866078532009984,27866069946073088,27866121485615104,27866241744437249,27866125780975616,27866112891486208,27866151550320640,27866215975157761,27866031287173120,27866142960254976,27866022701498368,27866134364880896,27866026991943680,28147579278458880,28147553508720640,28147506263883776,28147497674014720,28147587868196864,28147592163098624,28147725311803393,28147501968654336,28147510558654464,28429032780988418,28710520641945602,28710555001683970,28710524936912898,28710589361422338,28710593656389634,28710610836258818,28710533526847490,28710507757043714,28710602246324226,28710597951356930,28710580771487746,28710615131226114,28710516346978306,28710512052011010,28710606541291522,28992017092050946,28992051451789314,28992034271920130,28992025681985538,28991931192705026,28992038566887426,28991969847410690,28991926897737730,28992012797083650,28991935487672322,28991952667541506,28991922602770434,28992042861854722,28992004207149058,28991978437345282,28991961257476098,28992021387018242,29273453420019712,29555022882209792,29555031471882240,29555040061947904,29554949871632384,29554979932471296,29555035766915072,29555005702012928,29555018586849280,29554936986796032,29555014292537344,29555027177242624,29836403373637632,30118045854138369,30117951358566402,30117921293795330,30117869754187778,30117878344122370,30117904113926146,30117822509547522,30117934178697218,30117826804514818,30117916998828034,30117852574318594,30117925588762626,30117861164253186,30117831099482114,30117835394449410,30117912703860738,30117938473664514,30117942768631810,30399297487699968,30399391976783872,30399525125881857,30399387681882112,30399306077569024,30399310372339712,30399301782339584,30399353322405888,30399379092144128,30680772462903298,30680939968462850,30680914198659074,30680922788593666,30680836889247746,30680879838920706,30680918493626370,30680905608724482,30680849774149634,30680931378528258,30680935673495554,30680927083560962,30680909908344832,30962359107911682,30962350517977090,30962277503533058,30962247438761986,30962268913598466,30962286093467650,30962363402878978,31243761071751170,31243821201293314,31243834086195202,31243838381162498,31243816906326018,31243752481816578,31243731006980098,31243769661685762,31243778251620354,31243722417045506,31243825496260610,31243726712012802,31243812611358722,31243842676129794,31243804021424130,31243846971097090,31243735301947394,31243851266064386,31525283296903168,31525257522118658,31525407852986369,31806775455580160,32088254722867200,32088224658292736,32088297672605696,32088233250914304,32088301967638528,32088306262278144,32088383576342529,32088314852343808,32088289082933248,32088280492408832,32088207478292482,32088310557310976,32088293377245184,32088211772801024,32369849963184129,32369622324674560,32369630914543616,32369703929118720,32369712518856704,32369678159380480,32369626619314176,32369716813758464,32369635209314304,32651097306693632,32932628112801792,32932585162735616,32932666767179776,32932576572735488,32932572278095872,32932580867964928,32932653882540032,32932662472278016,32932799916736513,33214060139446272,33214274893512705,33214128859250688,33214047254806528,33214051549446144,33214103089512448,33214055844675584,33214141743890432,33214137448988672,33495749868716033,33495560884977664,33495535116156928,33495625316237312,33495616720601088,33495526526156800,33495522235711488,33495569480286208,33495651084533760,33495552295108608,33495715509370881,33495612425699328,33495736978178049,33495603835961344,33495642494468096,33495638194520064,33495530821386240,33495741278650369,33495578066223104,33495633899094016,33495621019828224,33777130352672768,33777138943197184,33777156122542080,33777143237509120,33777160417574912,33777061633064960,33777070228242432,33777147532869632,33777151827902464,33777164712607744,33777104583131136,33777074518556672,34058472184938496,34058553789382656,34058566674022400,34058528019644416,34058476479578112,34058562379120640,34058480774807552,34058699823841281,34058485069578240,34340007289290754,34621439315345410,34621666948612098,34902957245464578,35184526711455744,35184535301128192,35184522416422912,35184505236226048,35184432227024896,35184539596161024,35184436516618240,35184479466684416,35184531006095360,35184513826750464,35184518121062400,35184449402109952,35465988802412546,35466005982281730,35465902908833792,35466014572216322,35466001687314434,35465997392347138,35465911493001218,35465954442674178,35465993097379842,35466010277249026,35465924377903106,35465980212477954,35747480959516672,35747455189647360,35747489549582336,35747399355531264,35747472369844224,35747485254549504,35747429420105728,35747390770511872,35747463780171776,35747386470039552,35747476664877056,35747468074483712,36028955936227328,36028861446750208,36028857157353472,36028951641587712,36028960231260160,36028930166358016,36028874332241920,36028964526292992,36028904396816384,36028947346554880,36028938756882432,36028943051194368,36310319241953282,36310302062084098,36310353601691650,36310396551364610,36310370781560834,36310400846331906,36310280587247618,36310375076528130,36310366486593538,36310327831887874,36310383666462722,36310276292280322,36310362191626242,36310271997313026,36310387961430018,36310284882214914,36310310652018690,36310392256397314,36591746974482434,36591755564417026,36591794219122690,36591777039253506,36591828578861058,36591785629188098,36591867233566722,36591858643632130,36591802809057282,36591751269449730,36591841463762946,36591875823501314,36591871528534018,36591862938599426,36591850053697538,36591845758730242,36591837168795650,36591759859384322,36873389456424960,36873376571719680,36873299262373888,36873380866359296,36873286376882176,36873372276686848,36873329326948352,36873363687014400,36873294972452864,36873367981326336,36873385161392128,36873355096489984,37154735582216192,37154915978117121,37154911675416577,37154787122937856,37154817191706624,37154752763461632,37154701223395328,37154808596332544,37154696932950016,37154791417839616,37154705518624768,37154825781772288,37154812891758592,37154778533199872,37154890206609409,37154924565954561,37154709813395456,37154795717066752,37154744177524736,37154726992347136,37436232035663874,37436262099648512,37436266394550272,37436184790106112,37436227740172288,37436176200105984,37436171905466368,37436403839795201,37436253509910528,37436399541944321,37436180495335424,37717797205966850,37717724191522818,37717792910999554,37717788616032258,37717810090868738,37717784327290880,37717754256293890,37717711306620930,37717814385836034,37717801500934146,37717805795901442,37717780026097666,37999126153527296,37999151922479104,37999237821890560,37999212053069824,37999315136741377,37999349496086529,37999121863081984,37999233526464512,37999203463331840,37999169107656704,37999177693593600,37999340908445697,37999220647198720,37999130448756736,37999216347971584,37999336605548545,37999242121838592,37999250711904256,37999160512348160,37999134743527424,38280596834549762,38280678438928386,38280644079190018,38280652669124610,38280708503699458,38280626899320834,38280687028862978,38280691323830274,38280717093634050,38280695618797570,38280721388601346,38280635489255426,38280712798666754,38280609719451650,38280601129517058,38280605424484354,38280725683568642,38280699913764866,38562071811129346,38562174890344450,38562170595377154,38562110465835010,38562084696031234,38562192070213634,38562153415507970,38562080401063938,38562162005442562,38562187775246338,38562127645704194,38562196372652032,38562101875900418,38562119055769602,38562076106096642,38562200660148226,38562166300409858,38562183480279042,38843606924918784,39125034650370048,39125026060369920,39125030355599360,39125103370174464,39125021765730304,39125116254814208,39125077600436224,39125249405419521,39125111959912448,39406617000411138,39406526806097922,39406625590345730,39406612705443842,39406621295378434,39406599820541954,39406543985967106,39406535396032514,39406505331261442,39406509626228738,39406595525574658,39406496741326850,39406591230607362,39406608410476546,39406586935640066,39406501036294146,39406578345705474,39406552575901698,39688066208235520,39688199356350465,39688164997005313,39688087682154496,39688091982102528,39688190768971777,39687984603791360,39688027553857536,39687980309020672,39688070507462656,39688018967920640,39687976013791232,39688053323595776,39688001782743040,39688083386728448,39688100572168192,39688186465812481,39687971723345920,39688061913333760,39688010372612096,39969614199652354,39969554070110210,39969524005339138,39969609904685058,39969592724815874,39969605609717762,39969597019783170,39969579839913986,39969519716859904,39969511120437250,39969588429848578,39969601314750466,40251076292247552,40251084881920000,40251063407542272,40250994693636096,40251067701854208,40251054817017856,40251089176952832,40251029047476224,40250986097410048,40250998982901760,40251080586887168,40251071997214720,40532409532940290,40532491137318914,40532443892678658,40532516907122690,40532486842351618,40532521202089986,40532452482613250,40532525497057282,40532499727253506,40532508317188098,40532478252417026,40532426712809474,40532512612155394,40532435302744066,40532400943005698,40532495432286210,40532405237972994,40532396648038402,40813875920044034,40813871625076738,40813910279782402,40813983294226434,40813991884161026,40813970409324546,40813953229455362,40813966114357250,40813996179128322,40813901689847810,40814000474095618,40813884509978626,40813927459651586,40813974704291842,40813918869716994,40813987589193730,40813961819389954,40813880215011330,41095436796035074,41095359486623746,41095471155773442,41095376666492930,41095346601721858,41095475450740738,41095355191656450,41095428206100482,41095393846362114,41095449680936962,41095441091002370,41095350896689154,41095466860806146,41095462565838850,41095402436296706,41095385256427522,41095458270871554,41095445385969666,];

pub fn make_parser<'lt>() -> ZCParser<Construct<'lt>,Construct<'lt>>
{
 let mut parser1:ZCParser<Construct<'lt>,Construct<'lt>> = ZCParser::new(60,147);
 let mut rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("start");
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Program");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Classes(cs),Maincl(mc),)=(_item1_.value,_item0_.value,) {  Program(parser.lb(mc),cs) }  else {parser.bad_pattern("(Classes(cs),Maincl(mc),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MainCl");
 rule.Ruleaction = |parser|{ let mut _item16_ = parser.popstack(); let mut _item15_ = parser.popstack(); let mut _item14_ = parser.popstack(); let mut _item13_ = parser.popstack(); let mut _item12_ = parser.popstack(); let mut _item11_ = parser.popstack(); let mut _item10_ = parser.popstack(); let mut _item9_ = parser.popstack(); let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(thebody),Id(an),Id(cn),)=(_item14_.value,_item11_.value,_item1_.value,) { 
   Maincl(Mainclass{classname:cn,
             argvname:an,
             body: Blockst(thebody),
	    })
  }  else {parser.bad_pattern("(Stms(thebody),Id(an),Id(cn),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{  Classes(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Class(cl),Classes(mut cs),)=(_item1_.value,_item0_.value,) { 
  cs.push(parser.lbx(1,cl)); Classes(cs)
  }  else {parser.bad_pattern("(Class(cl),Classes(mut cs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDec");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),Id(sup),Id(name),)=(_item4_.value,_item2_.value,_item1_.value,) { 
  let mut vdecs=Vec::new();
  let mut mdecs=Vec::new();
  separatedecs(ds,&mut vdecs,&mut mdecs); /*split var and method declarations*/
  Class(ClassDec {superclass:sup,
                  classname:name,
		  vars:vdecs,
		  methods:mdecs})
  }  else {parser.bad_pattern("(Decs(mut ds),Id(sup),Id(name),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{ let mut sup = parser.popstack(); let mut _item0_ = parser.popstack();  sup.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{  Id("Object") };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(v),Id(t),)=(_item1_.value,_item0_.value,) {  Vdec(VarDec{dname:v,dtype:t,initval:Nothing,}) }  else {parser.bad_pattern("(Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),Id(t),)=(_item3_.value,_item1_.value,_item0_.value,) { 
  Vdec(VarDec{dname:v,dtype:t,initval:e})
  }  else {parser.bad_pattern("(Exp(e),Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MethodDec");
 rule.Ruleaction = |parser|{ let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(mbody),Vdecs(args),Id(name),Id(ty),)=(_item7_.value,_item4_.value,_item2_.value,_item1_.value,) { 
  Method(MethodDec{ formals:args,
                    body: mbody,
		    classname:ty,
		    methodname:name, })
  }  else {parser.bad_pattern("(Stms(mbody),Vdecs(args),Id(name),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{  Decs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(parser.lbx(1,v.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(makelbox!(m,m.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item2_.value,_item1_.value,_item0_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item3_.value,_item2_.value,_item1_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack();  return Id("int[]"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("boolean"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("String"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("int"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("void"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut c = parser.popstack();  c.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{  Stms(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Stms(mut sv),)=(_item1_.value,_item0_.value,) {  sv.push(makelbox!(_item1_,s)); Stms(sv) }  else {parser.bad_pattern("(Stm(s),Stms(mut sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(sv),)=(_item1_.value,) {  Stm(Blockst(sv)) }  else {parser.bad_pattern("(Stms(sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(b),Stm(a),Exp(c),)=(_item6_.value,_item4_.value,_item2_.value,) { 
  Stm(Ifstat(makelbox!(_item2_,c), makelbox!(_item4_,a), makelbox!(_item6_,b)))
  }  else {parser.bad_pattern("(Stm(b),Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(a),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Ifstat(makelbox!(_item2_,c),makelbox!(_item4_,a),parser.lbx(5,Nopst))) }  else {parser.bad_pattern("(Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Whilest(parser.lbx(2,c),parser.lbx(4,s))) }  else {parser.bad_pattern("(Stm(s),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),)=(_item2_.value,_item0_.value,) {  Stm(Assignst(v,parser.lbx(2,e))) }  else {parser.bad_pattern("(Exp(e),Id(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Exp(i),Exp(v),)=(_item5_.value,_item2_.value,_item0_.value,) { 
  Stm(ArAssignst(parser.lbx(0,v),parser.lbx(2,i),parser.lbx(5,e)))
  }  else {parser.bad_pattern("(Exp(e),Exp(i),Exp(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(m),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) { 
  Stm(Callstat(parser.lb(obj),m,args))
  }  else {parser.bad_pattern("(Exps(args),Id(m),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),)=(_item1_.value,) {  Stm(Returnst(parser.lbx(1,e))) }  else {parser.bad_pattern("(Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Vdec(v),)=(_item0_.value,) { Stm(Vardecst(v.dname,v.dtype,parser.lb(v.initval)))}  else {parser.bad_pattern("(Vdec(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("*",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("+",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("/",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("-",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("&&",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("OROR",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(a),)=(_item1_.value,) {  Exp(Notexp(parser.lbx(1,a))) }  else {parser.bad_pattern("(Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("<",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("%",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("==",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(i),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("[]",parser.lbx(0,a),parser.lbx(2,i)))}  else {parser.bad_pattern("(Exp(i),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(field),Exp(obj),)=(_item2_.value,_item0_.value,) {  Exp(Field(field,parser.lbx(0,obj))) }  else {parser.bad_pattern("(Id(field),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(f),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) {  Exp(Callexp(parser.lb(obj),f,args)) }  else {parser.bad_pattern("(Exps(args),Id(f),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (i,)=(_item0_.value,) {  i }  else {parser.bad_pattern("(i,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack();  s.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (b,)=(_item0_.value,) {  b }  else {parser.bad_pattern("(b,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item0_.value,) {  Exp(Var(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  Exp(Thisptr) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(s),)=(_item3_.value,) {  Exp(Newarray(parser.lbx(3,s))) }  else {parser.bad_pattern("(Exp(s),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item1_.value,) {  Exp(Newobj(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item1_.value,_item0_.value,) {  er.push(parser.lbx(0,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item2_.value,_item1_.value,) {  er.push(parser.lbx(1,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Construct<'lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..1263 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser


// Lexical Scanner using RawToken and StrTokenizer
pub struct mjlexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> mjlexer<'t> 
{
  pub fn from_str(s:&'t str) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> mjlexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["class","public","static","void","main","String","extends","return","length","new","this","int","boolean","if","else","while",] {keywords.insert(kw);}
    for c in ['(',')','[',']',';','!',',','=','+','-','*','/','<','.','%','{','}',] {stk.add_single(c);}
    for d in ["==","&&","||",] {stk.add_double(d);}
    mjlexer {stk,keywords}
  }
}
impl<'lt> Tokenizer<'lt,Construct<'lt>> for mjlexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,Construct<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<Construct<'lt>>::default())),
      RawToken::Alphanum("true") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(true)))),
      RawToken::Alphanum("false") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(false)))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"ID",Id(x))),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"INTEGER",Exp(Int(n as i32)))),
      RawToken::Strlit(s) => Some(TerminalToken::from_raw(token,"STRING",Exp(Strlit(s)))),
      RawToken::Symbol(r".") => Some(TerminalToken::from_raw(token,"DOT",<Construct<'lt>>::default())),
      RawToken::Symbol(r"%") => Some(TerminalToken::from_raw(token,"MOD",<Construct<'lt>>::default())),
      RawToken::Symbol(r"{") => Some(TerminalToken::from_raw(token,"LBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"}") => Some(TerminalToken::from_raw(token,"RBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"||") => Some(TerminalToken::from_raw(token,"OROR",<Construct<'lt>>::default())),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<Construct<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<Construct<'lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<Construct<'lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<Construct<'lt>,Construct<'lt>>)
{
}//end of load_extras: don't change this line as it affects augmentation

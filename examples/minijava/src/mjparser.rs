//Parser generated by rustlr for grammar mj

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
#![allow(unreachable_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use rustlr::{LBox,makelbox};
use crate::absyntax::*;
use crate::absyntax::Construct::*;
use crate::absyntax::Expr::*;
use crate::absyntax::Stat::*;

static SYMBOLS:[&'static str;58] = ["ID","INTEGER","STRING","BOOL","class","public","static","void","main","String","extends","return","length","(",")","[","]",";","DOT","!",",","new","this","LBR","RBR","OROR","int","boolean","if","else","while","==","=","+","-","*","/","<","&&","MOD","Program","MainCl","ClassDec","ClassDecl","Extension","VarDec","MethodDec","Decl","FormalLst","FormalRst","Type","Stat","Stats","Exp","ExpLst","ExpRst","START","EOF"];

static TABLE:[u64;1263] = [176093790209,17180065792,171798757377,281719789846531,563134637277185,563194766688258,562967133421570,844424930459648,1126080295927809,1125917087105024,1126144719978498,1407473668325376,1688849860853760,1970569650307074,1970342017040386,2251821289177088,2533373575036930,2533317740855296,2533463769677825,2814775537762304,3096323528982528,3377699721510912,3659204763058176,3940671149441026,3940851538526209,3940649674604546,3940752753819650,3940679739375618,3940761343754242,3940688329310210,3940765638721538,4222223435235330,4503633988288512,4785096080359424,4785074605391872,4785104670687232,4785177684869120,4785190569705472,4785272173821953,4785267879247873,4785289353822209,4785186275000320,4785113260490752,5066605417267200,5348136227438594,5348024558288898,5348063212994562,5348140522405890,5348127637504002,5348054623059970,5348046033125378,5629499535654914,5910974512889856,6192565453258752,6192664238030849,6192479554240512,6192488144044032,6192449488945152,6192561158553600,6473924465524738,6755644254453762,6755416621187074,7036986087636994,7036874418487298,7036990382604290,7036895893323778,7036904483258370,7036977497702402,7036913073192962,7318349395722242,7599824372498434,7599888797794304,7881299349274626,8162812981477376,8444322317991936,8444386742566912,8725724280389632,9007267976642560,9288738658451456,9570157798555650,9570239402934274,9570196453261314,9570269467705346,9570187863326722,9570230812999682,9570205043195906,9570278057639938,9570260877770754,9570162093522946,9570273762672642,9570179273392130,9570265172738050,9570153503588354,9570252287836162,9570149208621058,9570243697901570,9570170683457538,9570247992868866,9851705792135168,9851718677168128,9851714381873152,9851680022200320,9851628482658304,9851632777428992,9851624187953152,9851851820695553,9851637072723968,10133154999304192,10414574139408386,10696117837692928,10977665829437440,10977683009241088,10977670124601344,10977674419503104,10977657239109632,10977691598716928,10977678714208256,10977597110026240,10977588519829504,10977687303815168,10977601404600320,10977631469436928,11259166575296514,11259106445754370,11259076380983298,11259153690394626,11259067791048706,11259063496081410,11259084970917890,11259132215558146,11259157985361922,11259149395427330,11259140805492738,11259145100460034,11259072086016002,11259162280329218,11259059201114114,11540474049200128,11540585718415360,11821957614403584,11822039218847744,11822004859174912,11821949024927744,11821953319632896,11822030629109760,11822043514142720,11822176659308545,11821961909698560,12103574325493762,12103531375820802,12103582915428354,12103565735559170,12103492721115138,12103578620461058,12103570030526466,12103591505362946,12103484131180546,12103501311049730,12103509900984322,12103557145624578,12103587210395650,12103497016082434,12103488426147842,12384993467564032,12385126612795393,12384903273054208,12384898978349056,12384911863119872,12384980582531072,12384954812596224,12384907567824896,12384989172269056,12666541458915330,12666442674667522,12666459854536706,12666507099176962,12666532868980738,12666434084732930,12666438379700226,12666481329373186,12666528574013442,12666446969634818,12666524279046146,12666519984078850,12666537163948034,12666451264602114,12666515689111554,12947926241443842,12947921946476546,12947999255887874,12947934831378434,12947956306214914,12948003550855170,12947994960920578,12947909061574658,12947982076018690,12947913356541954,12947990665953282,12948016435757058,12948007845822466,12948012140789762,12947917651509250,13229478527500290,13229388333187074,13229431282860034,13229469937565698,13229396923121666,13229401218088962,13229409808023554,13229487117434882,13229474232532994,13229457052663810,13229482822467586,13229465642598402,13229384038219778,13229491412402178,13229392628154370,13510914847735808,13511013634867201,13510859012505602,13510837538521088,13510910553030656,13510828948717568,13511005044867073,13510798883422208,13792273863278592,14073830442795008,14073753133318144,14073843327827968,14073761723383808,14073804672860160,14073839032532992,14073757428088832,14073748838612992,14073976473321473,14355223815323648,14355318304538624,14355228110028800,14355279649570816,14355236700094464,14355314009243648,14355232404799488,14355305419505664,14355451450097665,14636926426873857,14636707381510144,14636754626281472,14636711676805120,14636793281249280,14636703086739456,14636780396216320,14636698792034304,14636788985954304,14918173770383360,15199743234670592,15199661630226432,15199648745455616,15199738939375616,15199657334931456,15199730349637632,15199653040160768,15199876380426241,15199704579702784,15481218211381248,15481213916086272,15481179556413440,15481132311642112,15481136606937088,15481128016871424,15481351357202433,15481205326348288,15481123722166272,15762693188091904,15762826333978625,15762607288352768,15762688892796928,15762598698876928,15762654533124096,15762602993582080,15762680303058944,15762611583647744,16044301310754817,16044086560358400,16044082265063424,16044077970292736,16044155279769600,16044129509834752,16044073675587584,16044168164802560,16044163869507584,16325557241774080,16325643141513216,16325552947003392,16325604486545408,16325548652298240,16325638846218240,16325561537069056,16325776287531009,16325630256480256,16607139590569986,16607152475471874,16607148180504578,16607045101289474,16607027921420290,16607053691224066,16607135295602690,16607126705668098,16607036511354882,16607070871093250,16607122410700802,16607118115733506,16607062281158658,16607023626452994,16607143885537282,16607113820766210,16607079461027842,16607105230831618,16607032216387586,16888580209901568,16888498605719552,16888511490490368,16888726241017857,16888554439966720,16888507195195392,16888588799639552,16888593094934528,16888502900424704,17169973582430208,17170068071645184,17170201217794049,17170029416677376,17169982171906048,17170063776350208,17169986467201024,17169977877135360,17170055186612224,17451504395878400,17732987962589184,18014557427007488,18014548837269504,18014462937595904,18014540247203840,18014531656876032,18014458644398080,18014505887203328,18014566016483328,18014553131974656,18014544542367744,18014475822366720,18014561721581568,18296019519078400,18295937913323522,18296028108685312,18296032402604034,18296006632800258,18295946503258114,18295933618356226,18295959388160002,18296036697571330,18295942208290818,18295980862996482,18296040993193984,18296015223914496,18295950799077376,18296023813980160,18577408597884928,18858823445118976,19140358551437312,19421906539773954,19421928015527936,19421859295133698,19421919424675842,19421850705920000,19421842115264514,19421880769970178,19421936604545026,19421932309577730,19421923719643138,19421846410231810,19421915129708546,19421833525329922,19421940899512322,19421837820297218,19703308501778434,19703334271582210,19703312796745730,19703411580993538,19703321386680322,19703325682630656,19703407286026242,19703355746418690,19703381516222466,19703317091713026,19703415876747264,19703402992238592,19703398697533440,19703390107467776,19703394402631680,19984869379342336,19984796363718658,19984873674244096,19984830724177920,19984856493260802,19984890853457920,19984882263064578,19984800659341312,19984877968949248,19984865084178432,19984809248620546,19984886558556160,19984787773784066,19984792068751362,19984783478816770,20266258455658498,20266352944939010,20266344355004418,20266254163378176,20266340060037122,20266262750625794,20266361534873602,20266331470102530,20266275635527682,20266357239906306,20266271340560386,20266365829840898,20266267045593090,20266305700298754,20266348649971714,20266284225462274,20547815037599744,20547806446419970,20547840806879232,20547836511977472,20547737726943234,20547742021910530,20547827922370560,20547750612762624,20547759201779714,20547823627665408,20547819332763648,20547733431975938,20547780676616194,20547746316877826,20547832216223746,20829302899081216,20829311488688128,20829290014310400,20829225589473280,20829217001766912,20829255654309888,20829212704702464,20829315783589888,20829307194114048,20829294309474304,20829281423982592,20829298604376064,21110691975135234,21110730629840898,21110709155004418,21110696270102530,21110700566183936,21110756399644674,21110777874481154,21110790759383042,21110782169448450,21110773579513858,21110764989579266,21110683385200642,21110769284546562,21110786464415746,21110687680167938,21392257146486786,21392239967731712,21392171247140866,21392265737011200,21392231377403904,21392184132042754,21392261442109440,21392252852502528,21392166952173570,21392205607731200,21392162657206274,21392175542894592,21392158362238978,21392248557797376,21392244262895616,21673719239606272,21673727829213184,21673650519605248,21673633338556418,21673646223458306,21673659108360194,21673723534508032,21673706353000450,21673637633523714,21673736417771522,21673732122804226,21673714942935042,21673740713721856,21673641928491010,21673680583196674,21955112610168834,21955181329645570,21955194214547458,21955121200103426,21955211394416642,21955198509514754,21955155559841794,21955215690432512,21955189919580162,21955202805923840,21955125496315904,21955108315201538,21955116905136130,21955207099449346,21955134085005314,22236677782634496,22236669191454722,22236682076356610,22236596177010690,22236664896487426,22236600473026560,22236630536749058,22236591882043394,22236656306552834,22236583292108802,22236673487929344,22236587587076098,22236690667143168,22236609061912578,22236686371323906,22518058272161792,22799477411348480,22799528950890496,22799481706119168,22799486001414144,22799554720825344,22799700752662529,22799563310563328,22799473116643328,22799567605858304,23081016813289474,23081102712635394,23081089827733506,23081012518322178,23081021108256770,23081098417668098,23081115597537282,23081033993158658,23081025403224066,23081107007602690,23081081237798914,23081094122700802,23081111302569986,23081055467995138,23081008223354882,23362521857130496,23643983949004800,23644108503121921,23643958174220290,23925471810748416,24207075636543489,24206929604378624,24206856589672448,24206852294901760,24206848000196608,24206903834443776,24206942489411584,24206938194116608,24207079931576321,24206860884967424,24206908130263042,24488391696187394,24488456120696834,24488395991154690,24488408876056578,24488464710631426,24488387401220098,24488400286121986,24488383106252802,24488486185467906,24488490480435202,24488469005598722,24488481890500610,24488473300566018,24488430350893058,24488477595533314,24769956867801090,24769939687931906,24769870968455170,24769952572833794,24769965457735682,24769875263422466,24769883853357058,24769931097997314,24769866673487874,24769862378520578,24769943982899202,24769905328193538,24769961162768386,24769948277866498,24769858083553282,25051427549741056,25051414664970240,25051380304969728,25051337355362304,25051440434249728,25051436139347968,25051423255035904,25051341653016576,25051350240133120,25051406074642432,25051431844773888,25051418960134144,25332760790368258,25332971248615425,25332829509844994,25332868164550658,25332859574616066,25332752200433666,25332803740041218,25332846689714178,25332786560172034,25332795150106626,25332850984681474,25332842394746882,25332777970237442,25332838099779586,25332876754485250,25332863869583362,25332747905466370,25332756495400962,25614222881980416,25614437635457025,25614261537079296,25614338846294016,25614334551588864,25614252947275776,25895757987840002,26177254439976962,26177396178878465,26177172835598338,26177211490304002,26177263029911554,26177267324878850,26177301684617218,26177284504748034,26177271619846146,26177220080238594,26177293094682626,26177181425532930,26177288799715330,26177275914813442,26177228670173186,26177177130565634,26177202900369410,26177185720500226,26458707944079362,26458793843687424,26458755188523008,26458806728327168,26458802433294336,26458798138589184,26458789548523520,26458811022901248,26458712238915584,26458884040556545,26458725123686400,26458780958195712,26458815317803008,26458733716766720,26740182923739136,27021765271355394,27021683666976770,27021666487107586,27021760976388098,27021657897172994,27021756681420802,27021739501551618,27021730911617026,27021705141813250,27021743796518914,27021748091486210,27021752386453506,27021662192140290,27021675077042178,27021670782074882,27303171532324864,27303193006833664,27303188706557952,27303167233228800,27303077038718976,27303111397343232,27303081333489664,27303291791212545,27303300381081601,27303201596964864,27303102807539712,27303184411852800,27303119992651776,27303154348195840,27303072747683840,27303128578260992,27303287490674689,27303085628784640,27303266021670913,27303162937933824,27303175827423232,27584547724984320,27866151550386176,27866121485746176,27866104301617152,27866142960254976,27866241744633857,27866069946073088,27866031286910976,27866112891355136,27866022701105152,27866237444096001,27866078531682304,27866125780975616,27866215975092225,27866138659979264,27866052760961024,27866035582205952,27866250334502913,27866117186650112,27866134365274112,27866026992140288,27866061350764544,28147557804277762,28429067140071424,28428981240332288,28429028485103616,28429200288514049,28428976945561600,28429062844776448,28429054255038464,28428985535627264,28428972650856448,28710533526847490,28710589361422338,28710615131226114,28710524936912898,28710580771487746,28710597951356930,28710507757043714,28710593656389634,28710516346978306,28710602246324226,28710610836258818,28710606541291522,28710512052011010,28710555001683970,28710520641945602,28992072928329730,28992064338395138,28991999913885698,28992055748460546,28992060047687680,28992068633362434,28991922602639362,28992085813231618,28992081518264322,28992029978656770,28992090108198914,28992077223297026,28991987028983810,29273453420085248,29554936986796032,29555035766718464,29555031472144384,29555027177111552,29554949871763456,29554979932340224,29555018587504640,29555005702012928,29555022882406400,29555014292340736,29555040061620224,29836386187608066,29836467791986690,29836437727215618,29836446317150210,29836463497019394,29836351827869698,29836377597673474,29836442022182914,29836403367477250,29836356122836994,29836476381921282,29836360417804290,29836450612117506,29836429137281026,29836347532902402,29836394777542658,29836459202052098,30117878350413824,30399301782536192,30399353322078208,30399306077306880,30399297487831040,30399391977046016,30399310372601856,30399387681751040,30399525125881857,30399379092013056,30680995807690753,30680781052903426,30680854067347458,30680772462968834,30680862657282050,30680901311987714,30680875542183938,30680892722053122,30680828297543682,30680785347870722,30680811117674498,30680802527739906,30680866952249346,30680819707609090,30680884132118530,30680871247216642,30680776757936130,30680888427085826,30962359109484546,30962286095040514,30962341929615362,30962371994386434,30962346224582658,30962337634648066,30962247440334850,30962256030269442,30962260325236738,30962329044713474,30962350519549954,30962363404451842,30962251735302146,30962376289353730,30962294684975106,30962303274909698,30962277505105922,30962367699419138,31243743890309122,31243761070178306,31243838379589634,31243825494687746,31243834084622338,31243722415472642,31243752480243714,31525407852986369,31525283296903168,31525257522118658,31806775455580160,32088314852016128,32088224657899520,32088297672802304,32088289082736640,32088207478292482,32088254722736128,32088280492408832,32088383576342529,32088211773128704,32088293377900544,32088306262540288,32088233250979840,32088301967507456,32088310557114368,32369678159052800,32369712518725632,32369622324805632,32369626619510784,32369635209576448,32369716814020608,32369703928987648,32369849963184129,32369630914281472,32651101596221440,32651110186287104,32651153135763456,32651191790731264,32651324939960321,32651187495436288,32651097301516288,32651178905698304,32651105890992128,32932576572932096,32932572278226944,32932666767441920,32932628112474112,32932799916736513,32932653882408960,32932585162997760,32932580867702784,32932662472146944,33214047260246016,33495749870288897,33495535116419072,33495526526353408,33495612425568256,33495603835830272,33495616720863232,33495530821124096,33495578065895424,33495522231648256,33777160417378304,33777130352672768,33777156122804224,33777138943000576,33777061633392640,33777143238164480,33777151827771392,33777070228242432,33777147533066240,33777074518163456,33777104583000064,33777164712280064,34058588147613696,34058566674284544,34058592447889408,34058601038020608,34058691232268289,34058562378989568,34058485069840384,34058528019316736,34058476479774720,34058686931730433,34058519433707520,34058699822137345,34058570973380608,34058510838398976,34058502248595456,34058480774545408,34058665462726657,34058553789251584,34058583852908544,34058472188739584,34058575269789696,34340007289290754,34621666948612098,34621439315345410,34902957245464578,35184526711324672,35184531006357504,35184535300931584,35184505236226048,35184479466553344,35184445111926784,35184513826553856,35184518121717760,35184449401716736,35184522416619520,35184436516945920,35184539595833344,35466005983068160,35466014572544000,35465954443264000,35466010277642240,35466001688035328,35465980212936704,35465997393330176,35465924378427392,35465993098428416,35465988803264512,35465907203801088,35465911493656576,35747480959778816,35747489549254656,35747468075139072,35747386470367232,35747390770511872,35747455189647360,35747476664745984,35747472370040832,35747485254352896,35747399355138048,35747463779975168,35747429419974656,36028904396095490,36028930165899266,36028852862386176,36028874331324418,36028947345768450,36028964525637634,36028943050801154,36028861446422530,36028960230670338,36028955935703042,36028938755833858,36028951640735746,36310422323462144,36310413733396480,36310349308559360,36310435207774208,36310418028560384,36310430913200128,36310379373395968,36310336423788544,36310405143068672,36310332134129664,36310426618167296,36310439502675968,36591850053697538,36591837168795650,36591794219122690,36591841463762946,36591867233566722,36591845758730242,36591871528534018,36591785629188098,36591875823501314,36591755564417026,36591777039253506,36591759859384322,36591858643632130,36591802809057282,36591862938599426,36591828578861058,36591751269449730,36591746974482434,36873346504785922,36873303555112962,36873333619884034,36873221950734338,36873260605440002,36873350799753218,36873337914851330,36873342209818626,36873312145047554,36873230540668930,36873269195374594,36873325029949442,36873320734982146,36873234835636226,36873252015505410,36873277785309186,36873226245701634,36873316440014850,37154696927707138,37154726992478210,37154709812609026,37154744172347394,37154735582412802,37154778532085762,37154701222674434,37154800006922242,37154808596856834,37154795711954946,37154825776726018,37154752762281986,37154821481758722,37154812891824130,37154791416987650,37154705517641730,37154787122020354,37154817186791426,37436210558926848,37436287868141568,37436262099517440,37436300758548480,37436201969123328,37436176200302592,37436171909267456,37436365183254529,37436283573436416,37436184790368256,37436270693908480,37436180495073280,37436219154235392,37436386652258305,37436227739844608,37436266394812416,37436390954827777,37436253509779456,37436399542665217,37436292168417280,37717711306620930,37717797205966850,37717780026097666,37717810090868738,37717792910999554,37717814385836034,37717724191522818,37717805795901442,37717788616032258,37717754256293890,37717801500934146,37717784327225344,37999353793282049,37999177693265920,37999216348233728,37999203463200768,37999126153723904,37999121859018752,37999134743789568,37999212052938752,37999181989085186,37999130448494592,37999349495365633,38280824472797185,38280609720500224,38280644084367360,38280596839399424,38280712798273536,38280708503568384,38280717098549248,38280678439911424,38280691324944384,38280695624040448,38280601130434560,38280725688680448,38280687029649408,38280635489058816,38280790113386497,38280605425205248,38280815885156353,38280811582390273,38280626899255296,38280652669976576,38562076106096642,38562200660148226,38562174890344450,38562170595377154,38562166300409858,38562110465835010,38562196372652032,38562127645704194,38562187775246338,38562101875900418,38562153415507970,38562162005442562,38562119055769602,38562183480279042,38562084696031234,38562080401063938,38562071811129346,38562192070213634,38843559673921536,38843546789150720,38843555378626560,38843774428643329,38843641278365696,38843602623397888,38843551083855872,38843636983070720,38843628393332736,39125081901694976,39406543985967106,39406621295378434,39406496741326850,39406535396032514,39406617000411138,39406505331261442,39406509626228738,39406599820541954,39406552575901698,39406612705443842,39406501036294146,39406526806097922,39406625590345730,39406586935640066,39406608410476546,39406578345705474,39406591230607362,39406595525574658,39688027553529856,39688053323464704,39688018967920640,39688061913202688,39687984604053504,39688199356350465,39688190768971777,39688164996939777,39688070507593728,39688087681826816,39688100572233728,39688091982102528,39688001782808576,39688186465943553,39687980308758528,39688083387121664,39687971722952704,39687976013987840,39688010372612096,39688066208497664,39969524005797888,39969601315405824,39969519716859904,39969597020700672,39969609905012736,39969579840307200,39969605610438656,39969592725798912,39969511121027072,39969554070634496,39969614199914496,39969588430635008,40250994693636096,40250998982049794,40251089176363010,40251067701526530,40251071996493826,40251076291461122,40251084881395714,40251080586428418,40251029046820866,40250986097147906,40251063406559234,40251054816624642,40532396648038402,40532491137318914,40532478252417026,40532426712809474,40532512612155394,40532400943005698,40532516907122690,40532508317188098,40532405237972994,40532521202089986,40532435302744066,40532452482613250,40532409532940290,40532525497057282,40532499727253506,40532443892678658,40532495432286210,40532486842351618,40813953229389826,40813875919978498,40813880214945794,40813991884095490,40813961819324418,40813871625011202,40813910279716866,40814000474030082,40813974704226306,40813983294160898,40813927459586050,40813996179062786,40813901689782274,40813987589128194,40813918869651458,40813966114291714,40813884509913090,40813970409259010,41095346601787394,41095385256493058,41095471155838978,41095458270937090,41095376666558466,41095462565904386,41095436796100610,41095428206166018,41095445386035202,41095449681002498,41095475450806274,41095350896754690,41095441091067906,41095359486689282,41095393846427650,41095466860871682,41095355191721986,41095402436362242,];

pub fn make_parser<'lt>() -> ZCParser<Construct<'lt>,Construct<'lt>>
{
 let mut parser1:ZCParser<Construct<'lt>,Construct<'lt>> = ZCParser::new(60,147);
 let mut rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("start");
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Program");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Classes(cs),Maincl(mc),)=(_item1_.value,_item0_.value,) {  Program(parser.lb(mc),cs) }  else {parser.bad_pattern("(Classes(cs),Maincl(mc),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MainCl");
 rule.Ruleaction = |parser|{ let mut _item16_ = parser.popstack(); let mut _item15_ = parser.popstack(); let mut _item14_ = parser.popstack(); let mut _item13_ = parser.popstack(); let mut _item12_ = parser.popstack(); let mut _item11_ = parser.popstack(); let mut _item10_ = parser.popstack(); let mut _item9_ = parser.popstack(); let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(thebody),Id(an),Id(cn),)=(_item14_.value,_item11_.value,_item1_.value,) { 
   Maincl(Mainclass{classname:cn,
             argvname:an,
             body: Blockst(thebody),
	    })
  }  else {parser.bad_pattern("(Stms(thebody),Id(an),Id(cn),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{  Classes(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDecl");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Class(cl),Classes(mut cs),)=(_item1_.value,_item0_.value,) { 
  cs.push(parser.lbx(1,cl)); Classes(cs)
  }  else {parser.bad_pattern("(Class(cl),Classes(mut cs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ClassDec");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),Id(sup),Id(name),)=(_item4_.value,_item2_.value,_item1_.value,) { 
  let mut vdecs=Vec::new();
  let mut mdecs=Vec::new();
  separatedecs(ds,&mut vdecs,&mut mdecs); /*split var and method declarations*/
  Class(ClassDec {superclass:sup,
                  classname:name,
		  vars:vdecs,
		  methods:mdecs})
  }  else {parser.bad_pattern("(Decs(mut ds),Id(sup),Id(name),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{ let mut sup = parser.popstack(); let mut _item0_ = parser.popstack();  sup.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Extension");
 rule.Ruleaction = |parser|{  Id("Object") };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(v),Id(t),)=(_item1_.value,_item0_.value,) {  Vdec(VarDec{dname:v,dtype:t,initval:Nothing,}) }  else {parser.bad_pattern("(Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("VarDec");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),Id(t),)=(_item3_.value,_item1_.value,_item0_.value,) { 
  Vdec(VarDec{dname:v,dtype:t,initval:e})
  }  else {parser.bad_pattern("(Exp(e),Id(v),Id(t),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("MethodDec");
 rule.Ruleaction = |parser|{ let mut _item8_ = parser.popstack(); let mut _item7_ = parser.popstack(); let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(mbody),Vdecs(args),Id(name),Id(ty),)=(_item7_.value,_item4_.value,_item2_.value,_item1_.value,) { 
  Method(MethodDec{ formals:args,
                    body: mbody,
		    classname:ty,
		    methodname:name, })
  }  else {parser.bad_pattern("(Stms(mbody),Vdecs(args),Id(name),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{  Decs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(parser.lbx(1,v.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Decl");
 rule.Ruleaction = |parser|{ let mut m = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Decs(mut ds),)=(_item0_.value,) {  ds.push(makelbox!(m,m.value)); Decs(ds) }  else {parser.bad_pattern("(Decs(mut ds),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalLst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item2_.value,_item1_.value,_item0_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{  Vdecs(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("FormalRst");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Vdecs(mut frs),Id(a),Id(ty),)=(_item3_.value,_item2_.value,_item1_.value,) { 
  frs.push(parser.lb(VarDec{dname:a,dtype:ty,initval:Nothing}));
  Vdecs(frs) 
  }  else {parser.bad_pattern("(Vdecs(mut frs),Id(a),Id(ty),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack();  return Id("int[]"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("boolean"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("String"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("int"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  return Id("void"); };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Type");
 rule.Ruleaction = |parser|{ let mut c = parser.popstack();  c.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{  Stms(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stats");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Stms(mut sv),)=(_item1_.value,_item0_.value,) {  sv.push(makelbox!(_item1_,s)); Stms(sv) }  else {parser.bad_pattern("(Stm(s),Stms(mut sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stms(sv),)=(_item1_.value,) {  Stm(Blockst(sv)) }  else {parser.bad_pattern("(Stms(sv),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(b),Stm(a),Exp(c),)=(_item6_.value,_item4_.value,_item2_.value,) { 
  Stm(Ifstat(makelbox!(_item2_,c), makelbox!(_item4_,a), makelbox!(_item6_,b)))
  }  else {parser.bad_pattern("(Stm(b),Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(a),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Ifstat(makelbox!(_item2_,c),makelbox!(_item4_,a),parser.lbx(5,Nopst))) }  else {parser.bad_pattern("(Stm(a),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Stm(s),Exp(c),)=(_item4_.value,_item2_.value,) {  Stm(Whilest(parser.lbx(2,c),parser.lbx(4,s))) }  else {parser.bad_pattern("(Stm(s),Exp(c),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Id(v),)=(_item2_.value,_item0_.value,) {  Stm(Assignst(v,parser.lbx(2,e))) }  else {parser.bad_pattern("(Exp(e),Id(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),Exp(i),Exp(v),)=(_item5_.value,_item2_.value,_item0_.value,) { 
  Stm(ArAssignst(parser.lbx(0,v),parser.lbx(2,i),parser.lbx(5,e)))
  }  else {parser.bad_pattern("(Exp(e),Exp(i),Exp(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item6_ = parser.popstack(); let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(m),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) { 
  Stm(Callstat(parser.lb(obj),m,args))
  }  else {parser.bad_pattern("(Exps(args),Id(m),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(e),)=(_item1_.value,) {  Stm(Returnst(parser.lbx(1,e))) }  else {parser.bad_pattern("(Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Stat");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Vdec(v),)=(_item0_.value,) { Stm(Vardecst(v.dname,v.dtype,parser.lb(v.initval)))}  else {parser.bad_pattern("(Vdec(v),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("*",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("+",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("/",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("-",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("&&",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("OROR",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(a),)=(_item1_.value,) {  Exp(Notexp(parser.lbx(1,a))) }  else {parser.bad_pattern("(Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("<",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("%",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(b),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("==",parser.lbx(0,a),parser.lbx(2,b)))}  else {parser.bad_pattern("(Exp(b),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(i),Exp(a),)=(_item2_.value,_item0_.value,) { Exp(Binop("[]",parser.lbx(0,a),parser.lbx(2,i)))}  else {parser.bad_pattern("(Exp(i),Exp(a),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(field),Exp(obj),)=(_item2_.value,_item0_.value,) {  Exp(Field(field,parser.lbx(0,obj))) }  else {parser.bad_pattern("(Id(field),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item5_ = parser.popstack(); let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(args),Id(f),Exp(obj),)=(_item4_.value,_item2_.value,_item0_.value,) {  Exp(Callexp(parser.lb(obj),f,args)) }  else {parser.bad_pattern("(Exps(args),Id(f),Exp(obj),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (i,)=(_item0_.value,) {  i }  else {parser.bad_pattern("(i,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut s = parser.popstack();  s.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (b,)=(_item0_.value,) {  b }  else {parser.bad_pattern("(b,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item0_.value,) {  Exp(Var(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack();  Exp(Thisptr) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item4_ = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exp(s),)=(_item3_.value,) {  Exp(Newarray(parser.lbx(3,s))) }  else {parser.bad_pattern("(Exp(s),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Id(x),)=(_item1_.value,) {  Exp(Newobj(x)) }  else {parser.bad_pattern("(Id(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("Exp");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut e = parser.popstack(); let mut _item0_ = parser.popstack();  e.value };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpLst");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item1_.value,_item0_.value,) {  er.push(parser.lbx(0,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{  Exps(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("ExpRst");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Exps(mut er),Exp(e),)=(_item2_.value,_item1_.value,) {  er.push(parser.lbx(1,e)); Exps(er) }  else {parser.bad_pattern("(Exps(mut er),Exp(e),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Construct<'lt>,Construct<'lt>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Construct<'lt>>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..1263 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser


// Lexical Scanner using RawToken and StrTokenizer
pub struct mjlexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> mjlexer<'t> 
{
  pub fn from_str(s:&'t str) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> mjlexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> mjlexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["class","public","static","void","main","String","extends","return","length","new","this","int","boolean","if","else","while",] {keywords.insert(kw);}
    for c in ['(',')','[',']',';','!',',','=','+','-','*','/','<','.','%','{','}',] {stk.add_single(c);}
    for d in ["==","&&","||",] {stk.add_double(d);}
    mjlexer {stk,keywords}
  }
}
impl<'lt> Tokenizer<'lt,Construct<'lt>> for mjlexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,Construct<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<Construct<'lt>>::default())),
      RawToken::Alphanum("true") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(true)))),
      RawToken::Alphanum("false") => Some(TerminalToken::from_raw(token,"BOOL",Exp(Bool(false)))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"ID",Id(x))),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"INTEGER",Exp(Int(n as i32)))),
      RawToken::Strlit(s) => Some(TerminalToken::from_raw(token,"STRING",Exp(Strlit(s)))),
      RawToken::Symbol(r".") => Some(TerminalToken::from_raw(token,"DOT",<Construct<'lt>>::default())),
      RawToken::Symbol(r"%") => Some(TerminalToken::from_raw(token,"MOD",<Construct<'lt>>::default())),
      RawToken::Symbol(r"{") => Some(TerminalToken::from_raw(token,"LBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"}") => Some(TerminalToken::from_raw(token,"RBR",<Construct<'lt>>::default())),
      RawToken::Symbol(r"||") => Some(TerminalToken::from_raw(token,"OROR",<Construct<'lt>>::default())),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<Construct<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<Construct<'lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<Construct<'lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<Construct<'lt>,Construct<'lt>>)
{
}//end of load_extras: don't change this line as it affects augmentation

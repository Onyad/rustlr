//Parser generated by rustlr for grammar calcauto
    
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(unreachable_patterns)]
#![allow(irrefutable_let_patterns)]
use std::any::Any;
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{StrTokenizer,RawToken,LexSource};
use std::collections::{HashMap,HashSet};
use rustlr::LBox;
use crate::calcauto_ast;
use crate::calcauto_ast::*;

static SYMBOLS:[&'static str;16] = ["Expr","ES","+","-","*","/","(",")","=",";","let","in","int","var","START","EOF"];

static TABLE:[u64;159] = [25769934848,51540066304,55834771456,42950000640,4295229441,65537,12885295104,281487862398976,281492157104128,281483567300608,281496452136960,281513632137216,563005788192768,562949954273281,562975723356160,562962838716416,563001493487616,562992903421952,844446405033986,844433520132098,844437815099394,844442110066690,844454994968578,844472174837762,844463584903170,1125925676777472,1125899907760129,1125964331352067,1125942856843264,1125912792137728,1125951446908928,1125955741614080,1407430719111168,1688862745559040,1688905695035392,1688892810264576,1688901400330240,1688875630198784,1688849861312513,1970372081614850,1970333426909186,1970346311811074,1970354901745666,1970363491680258,1970337721876482,1970342016843778,2251851353751552,2251842763685888,2251812698980352,2251799814799361,2251855648456704,2251825583620096,2533300560330752,2533287675691008,2533330625167360,2533326330462208,2533274791575553,2533317740396544,2814749768351745,2814775537041408,2814805601878016,2814792717107200,2814801307172864,2814762652401664,3096280578981890,3096267694080002,3096237629308930,3096289168916482,3096250514210818,3096276284014594,3377755555299328,3377699721838593,3377712605822976,3377751260594176,3377725490462720,3377742670528512,3659191877632000,3659183287828480,3659204763385856,3659196172664832,3659187582926848,3940688330096640,3940671149375488,3940658264539136,3940662559637504,3940666854342656,4222159011905536,4503646872469506,4503608217763842,4503638282534914,4503621102796800,4503629692600322,4503612512731138,4503616807763968,4785087489376258,4785121849114626,4785091784343554,4785096079310850,4785113259180034,4785104669245442,4785083194408962,5066596825759746,5066579645890562,5066558171054082,5066571055955970,5066562466021378,5066566760988674,5066588235825154,5348054622470146,5348046032928768,5348041737895936,5348033147633666,5348063212404738,5348037442600962,5348071802339330,5629521009639424,5629508124409858,5629512419377154,5629529599246338,5629538189180930,5629516714606592,5629546779115522,5911013166153730,5911004576219138,5910991691317250,5910983101382658,5911021756088322,5910995986284546,5910987396349954,6192505322864642,6192462373191682,6192475258093570,6192513912799234,6192492437962754,6192501027897346,6473967414345728,6473937349640192,6473950234279936,6473976004411392,6473980299116544,6473924465917953,6755446687334400,6755412326744064,6755408031645696,6755416621449216,6755420916482048,7036874419470337,7036930252537856,7036925957832704,7036917367767040,7036887303061504,7036900187701248,7318396639248386,7318362280165376,7318388049313794,7318379459379202,7318357985067008,7318370869903360,7318366574870528,];


fn _semaction_rule_0_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_1(_x_1)=parser.popstack().value { _x_1 } else {<i64>::default()}; Expr::Val(_item0_) }

fn _semaction_rule_1_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item0_ = if let RetTypeEnum::Enumvariant_2(_x_2)=parser.popstack().value { _x_2 } else {<&'lt str>::default()}; Expr::Var(_item0_) }

fn _semaction_rule_2_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item5_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item4_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item3_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item2_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_2(_x_2)=parser.popstack().value { _x_2 } else {<&'lt str>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; Expr::Letexp(_item1_,parser.lbx(3,_item3_),parser.lbx(5,_item5_)) }

fn _semaction_rule_3_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; Expr::Plus(parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_4_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; Expr::Minus(parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_5_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; Expr::Div(parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_6_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; Expr::Times(parser.lbx(0,_item0_),parser.lbx(2,_item2_)) }

fn _semaction_rule_7_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; Expr::Neg(parser.lbx(1,_item1_)) }

fn _semaction_rule_8_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> Expr<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut e = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()};  e }

fn _semaction_rule_9_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> ES<'lt> {
let mut _item1_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; ES::One(parser.lbx(0,_item0_)) }

fn _semaction_rule_10_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> ES<'lt> {
let mut _item2_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; let mut _item1_ = if let RetTypeEnum::Enumvariant_18(_x_18)=parser.popstack().value { _x_18 } else {<Expr<'lt>>::default()}; let mut _item0_ = if let RetTypeEnum::Enumvariant_0(_x_0)=parser.popstack().value { _x_0 } else {<ES<'lt>>::default()}; ES::Seq(parser.lbx(0,_item0_),parser.lbx(1,_item1_)) }

fn _semaction_rule_11_<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>) -> () {
let mut _item0_ = if let RetTypeEnum::Enumvariant_17(_x_17)=parser.popstack().value { _x_17 } else {<()>::default()}; <()>::default()}

pub fn make_parser<'lt>() -> ZCParser<RetTypeEnum<'lt>,()>
{
 let mut parser1:ZCParser<RetTypeEnum<'lt>,()> = ZCParser::new(12,27);
 let mut rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("start");
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_0_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_1_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_2_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_3_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_4_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_5_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_6_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_7_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("Expr");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_18(_semaction_rule_8_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_9_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("ES");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_0(_semaction_rule_10_(parser)) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<RetTypeEnum<'lt>,()>::new_skeleton("START");
 rule.Ruleaction = |parser|{  RetTypeEnum::Enumvariant_17(_semaction_rule_11_(parser)) };
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..159 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

pub fn parse_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>, lexer:&mut calcautolexer<'lt>) -> Result<ES<'lt>,ES<'lt>>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse(lexer) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<ES<'lt>>::default())}
}//parse_with public function

pub fn parse_train_with<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>, lexer:&mut calcautolexer<'lt>, parserpath:&str) -> Result<ES<'lt>,ES<'lt>>
{
  if let RetTypeEnum::Enumvariant_0(_xres_) = parser.parse_train(lexer,parserpath) {
     if !parser.error_occurred() {Ok(_xres_)} else {Err(_xres_)}
  } else { Err(<ES<'lt>>::default())}
}//parse_train_with public function

//Enum for return values 
pub enum RetTypeEnum<'lt> {
  Enumvariant_17(()),
  Enumvariant_1(i64),
  Enumvariant_0(ES<'lt>),
  Enumvariant_2(&'lt str),
  Enumvariant_18(Expr<'lt>),
}
impl<'lt> Default for RetTypeEnum<'lt> { fn default()->Self {RetTypeEnum::Enumvariant_0(<ES<'lt>>::default())} }


// Lexical Scanner using RawToken and StrTokenizer
pub struct calcautolexer<'t> {
   stk: StrTokenizer<'t>,
   keywords: HashSet<&'static str>,
}
impl<'t> calcautolexer<'t> 
{
  pub fn from_str(s:&'t str) -> calcautolexer<'t>  {
    Self::new(StrTokenizer::from_str(s))
  }
  pub fn from_source(s:&'t LexSource<'t>) -> calcautolexer<'t>  {
    Self::new(StrTokenizer::from_source(s))
  }
  pub fn new(mut stk:StrTokenizer<'t>) -> calcautolexer<'t> {
    let mut keywords = HashSet::with_capacity(16);
    for kw in ["let","in",] {keywords.insert(kw);}
    for c in ['+','-','*','/','(',')','=',';',] {stk.add_single(c);}
    for d in [] {stk.add_double(d);}
    stk.set_line_comment("#");
    calcautolexer {stk,keywords}
  }
}
impl<'lt> Tokenizer<'lt,RetTypeEnum<'lt>> for calcautolexer<'lt>
{
   fn nextsym(&mut self) -> Option<TerminalToken<'lt,RetTypeEnum<'lt>>> {
    let tokopt = self.stk.next_token();
    if let None = tokopt {return None;}
    let token = tokopt.unwrap();
    match token.0 {
      RawToken::Alphanum(sym) if self.keywords.contains(sym) => Some(TerminalToken::from_raw(token,sym,<RetTypeEnum<'lt>>::default())),
      RawToken::Num(n) => Some(TerminalToken::from_raw(token,"int",RetTypeEnum::Enumvariant_1(n))),
      RawToken::Alphanum(x) => Some(TerminalToken::from_raw(token,"var",RetTypeEnum::Enumvariant_2(x))),
      RawToken::Symbol(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      RawToken::Alphanum(s) => Some(TerminalToken::from_raw(token,s,<RetTypeEnum<'lt>>::default())),
      _ => Some(TerminalToken::from_raw(token,"<LexicalError>",<RetTypeEnum<'lt>>::default())),
    }
  }
   fn linenum(&self) -> usize {self.stk.line()}
   fn column(&self) -> usize {self.stk.column()}
   fn position(&self) -> usize {self.stk.current_position()}
   fn current_line(&self) -> &str {self.stk.current_line()}
   fn get_line(&self,i:usize) -> Option<&str> {self.stk.get_line(i)}
}//impl Tokenizer

fn load_extras<'lt>(parser:&mut ZCParser<RetTypeEnum<'lt>,()>)
{
}//end of load_extras: don't change this line as it affects augmentation

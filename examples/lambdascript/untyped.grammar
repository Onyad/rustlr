# Grammar for lambda calculus with step-by-step reduction

!use rustlr::{LBox,unbox};
!use crate::untyped::*;
!use crate::untyped::Term::*;

absyntype Term
externtype Vec<LBox<Term>>
terminals lambda ( ) [ ] DOT let = in define lazy ;
terminal INTEGER
terminal ID
nonterminal T
nonterminal Vars
nonterminal Moreargs
nonterminal Ts
topsym Ts

# place defs in Machine:
Ts --> T:x ;  { parser.exstate.push(x.lbox()); Nothing }
Ts --> Ts T:x ;  { parser.exstate.push(x.lbox()); Nothing }

T --> ID:(x) { x } /* var */
T --> INTEGER:(x) { x } /* const*/
# application always requires ()
T ==> ( T:a Moreargs:@Seq(mut ts)@ ) {
  if ts.len()<1 {return a.value;}
  let mut apterm = App(a.lbox(), ts.pop().unwrap());
  while ts.len()>0 {
    apterm = App(parser.lbx(0,apterm), ts.pop().unwrap());
  }
  apterm }
  <==
T ==> lambda Vars:@Seq(mut vs)@ DOT T:b  {
  let mut t = b.value;
  while vs.len()>0 {
    t = Abs(getvar(&unbox!(vs.pop().unwrap())),parser.lbx(0,t));
  }
  return t; }
  <==
T --> let ID:@Var(x)@ = T:v in T:b  { App(parser.lbx(0,Abs(x,b.lbox())), v.lbox()) }


# define evaluate to the term being defined, but also affects global env
T ==> define ID:@Var(x)@ = T:v {
  let nv = Def(true,x,v.lbox());
  //parser.exstate.push(parser.lbx(0,nv));
  nv 
 } <==

Moreargs -->  { Seq(Vec::new()) }
Moreargs --> T:b Moreargs:ms@Seq(ts)@ { ts.push(b.lbox()); ms.value }

Vars --> ID:x { Seq(vec![x.lbox()]) }
Vars --> Vars:@Seq(mut vs)@ ID:y { vs.push(y.lbox()); Seq(vs) }

EOF

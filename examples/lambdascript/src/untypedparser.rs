//Parser generated by rustlr for grammar untyped

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{LBox,unbox};
use crate::untyped::*;
use crate::untyped::Term::*;

const SYMBOLS:[&'static str;26] = ["lambda","lam","Lam","(",")","[","]","DOT","let","=","in","define","lazy","weak","CBV",";","INTEGER","ID","T","F","Fs","Vars","LAMSYM","Ts","START","EOF"];

const TABLE:[u64;221] = [73015099392,81605099521,60130394112,94490066945,4295950336,68719935488,34360000512,55834705920,589824,98784444417,85899673601,8590327808,77309476865,47245557760,12885426176,281539402268672,563018673356800,562962838847488,563022968520704,563031558914049,844497945231360,844433520459776,844424930721792,844485060526080,844532304314371,844506535231489,844519420198913,844493650067456,844502240722945,844429226082304,844459290132480,844480764837888,844437815558144,844472175689728,844510829805569,1125972922531840,1407447898652672,1407443603488768,1407392063815682,1407417833619458,1407456489242625,1407387768979456,1407439308455938,1688922875887618,1970367786975234,1970342017171458,1970393556779010,1970337722204162,1970397851746306,1970389261811714,2251834173685760,2251881418784769,2251885713358849,2251855648391168,2251799814275072,2251868533620736,2251812699111424,2251808404013056,2251894303752193,2251877124472833,2251804109635584,2251847059243008,2251859944079360,2251872828784640,2533347805888514,2814762652270594,2814766947237890,2814814191878146,2814818486845442,2814792717041666,2814822781812738,3096293463425026,3096237628850178,3096241923817474,3096297758392322,3096267693621250,3096289168457730,3377772736479232,3377789916282881,3659243417174016,3659247712337920,3659256303190017,3659187582664704,3940722690097152,3940701215195136,4222197666217986,4503608217305090,4503668346847234,4503672641814530,4503707001552898,4503603922337794,4503659756912642,4503655461945346,4503633987108866,4503599627370498,4503646872010754,4503612512272386,4785091784540162,4785117554343938,4785139029180418,5066614007070720,5348063214043136,5629572548853762,5629563958919170,5629512419311618,5629516714278914,5629542484082690,5629568253886466,5910991692693504,6192479554371584,6192522504110080,6473954529837058,6473997479510018,6755416621449218,6755442391252994,6755463866089474,7036947434307584,7318388051345408,7599884500795394,7599832961187842,7599893090729986,7599828666220546,7599897385697282,7599871615893506,7599931745435650,7599858730991618,7599837256155138,7599824371253250,7599880205828098,7881376659537921,7881372362997760,7881368067833856,7881299348488192,7881393837965313,7881355182604288,7881385247571969,7881307938226176,7881303643848704,7881346593456128,7881333707898880,7881380952997889,7881312233324544,7881359478292480,8162791504936962,8162843044544514,8162787209969666,8162817274740738,8162847339511810,8162838749577218,8444318021255168,8444253597270016,8444262186745856,8444249301909504,8444305136025600,8444335200993281,8444257891647488,8444296546877440,8444309431713792,8444326613024769,8444343791386625,8444330906419201,8444283661320192,8444322316419072,8725797293260802,8725754343587842,9007237911805952,9288751543287809,9288747246551040,9288708591452160,9288687116877824,9288760131125249,9288682821779456,9288742951387136,9288734361845760,9288721477009408,9288730066157568,9288674232041472,9288768721518593,9288678527401984,9288755836551169,9570192160325632,9851688610037762,9851667135201282,9851641365397506,10133193651650561,10133103457533952,10133167881519104,10133176473550849,10133185061257217,10133133521584128,10133159291977728,10133146407141376,10133180766683137,10133107751911424,10133112047009792,10133099162173440,10133172176683008,10133154996289536,10414591319080962,10414617088884738,10414638563721218,10696122130104320,10696117834940416,10696062000431104,10696096360562688,10696109245399040,10696053410955264,10696130720104449,10696126427037697,10696135014678529,10696049115594752,10696104949710848,10696083475005440,10696057705332736,10696143605071873,10977567042371586,10977541272567810,10977588517208066,11259016249147394,11259042018951170,11259063493787650,];

pub fn make_parser() -> ZCParser<Term,Vec<LBox<Term>>>
{
 let mut parser1:ZCParser<Term,Vec<LBox<Term>>> = ZCParser::new(20,41);
 let mut rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("start");
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut x = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Fs");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item0_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Fs");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut a = parser.popstack();  App(a.lbox(), b.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* var */  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* const*/  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item0_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("F");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (a,)=(_item1_.value,) {  a }  else {parser.bad_pattern("(a,)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  CBV(x.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  Weak(x.lbox()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item1_.value,) { 
  let mut t = b.value;
  while vs.len()>0 {
    t = Abs(getvar(&unbox!(vs.pop().unwrap())),parser.lbx(0,t));
  }
  return t; }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack();  Seq(vec![x.lbox()]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut y = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item0_.value,) {  vs.push(y.lbox()); Seq(vs) }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) {  App(parser.lbx(0,Abs(x,b.lbox())), v.lbox()) }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { 
  let nv = Def(true,x,v.lbox());
  //parser.exstate.push(parser.lbx(0,nv));
  nv 
 }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item2_.value,) { 
  let nv = Def(false,x,v.lbox());
  nv 
 }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("LAMSYM");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(";");

 for i in 0..221 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras(parser:&mut ZCParser<Term,Vec<LBox<Term>>>)
{
}//end of load_extras: don't change this line as it affects augmentation

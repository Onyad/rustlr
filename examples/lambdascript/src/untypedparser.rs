//Parser generated by rustlr for grammar untyped

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_imports)]
#![allow(unused_assignments)]
#![allow(dead_code)]
#![allow(irrefutable_let_patterns)]
extern crate rustlr;
use rustlr::{Tokenizer,TerminalToken,ZCParser,ZCRProduction,Stateaction,decode_action};
use rustlr::{LBox,unbox};
use crate::untyped::*;
use crate::untyped::Term::*;

const SYMBOLS:[&'static str;20] = ["lambda","(",")","[","]","DOT","let","=","in","define","lazy",";","INTEGER","ID","T","Vars","Moreargs","Ts","START","EOF"];

const TABLE:[u64;154] = [60129607681,38655033344,262144,4295360512,51540131840,55835033600,73014640641,25769934848,281522221940736,563005788651520,844506534510595,844485060395009,844429225492480,844480765165568,844463585165312,844476470263808,844450700066816,844424930394112,1125955742269440,1125964332138497,1407430719045632,1688888515297280,1688875630198784,1688849860526080,1688854155624448,1688905695297536,1688909990789121,1688901400395776,1970380671680514,1970333427040258,1970324837105666,1970363491811330,1970376376713218,1970350606909442,1970329132072962,1970372081745922,1970359196844034,2251851353489410,2251838468587522,2251808403816450,2251799813881858,2251847058522114,2251834173620226,2251855648456706,2251804108849154,2251825583685634,2533330624970754,2533274790395906,2533279085363202,2533356394774530,2533300560199682,2533313445101570,2533326330003458,2814779832926208,3096271989571584,3377721196609536,3377755556282368,3659230532468738,3659196172730370,3940679740030976,4222180485693440,4222184781643777,4222193371512833,4222176190791680,4222150420594688,4222163305693184,4222128946020352,4222124650921984,4222133241118722,4503659758419969,4503638282403840,4503625397305344,4503603922731008,4503655462404096,4503651167502336,4503599627632640,4785113258852354,4785126143754242,4785074604146690,4785078899113986,4785130438721538,4785156208525314,4785100373950466,5066605416087554,5066571056349186,5348080392536064,5348063212535808,5348084688617473,5348050327437312,5348024557764608,5348076097634304,5348028852862976,5629551074344960,5629503829573632,5629538189246464,5629525304147968,5629555369246720,5629559665393665,5629499534475264,5910983102562304,6192501027766272,6192458078093314,6192509618618369,6192449487896576,6192505322668032,6192453782994944,6192518208880641,6192475257569280,6192488142667776,6473958825918464,6755408031318018,6755450980990978,6755438096089090,6755455275958274,6755399441383426,6755433801121794,6755446686023682,6755403736350722,6755425211187202,7036913072930818,7036908777963522,7036878713192450,7036930252800002,7036883008159746,7036925957832706,7036921662865410,7036900188028930,7036874418225154,7318388049444866,7318353689706498,7318400934346754,7318349394739202,7318383754477570,7318396639379458,7318357984673794,7318375164542978,7318405229314050,7599832961712130,7881350888030208,7881303643258880,7881355182931968,7881359479341057,7881299348160512,7881325117833216,7881338002931712,8162800094806018,8162825864609794,8162778619969538,8162830159577090,8162821569642498,8162812979707906,8162782914936834,8162808684740610,8162774325002242,];

pub fn make_parser() -> ZCParser<Term,Vec<LBox<Term>>>
{
 let mut parser1:ZCParser<Term,Vec<LBox<Term>>> = ZCParser::new(13,30);
 let mut rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("start");
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item1_ = parser.popstack(); let mut x = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Ts");
 rule.Ruleaction = |parser|{ let mut _item2_ = parser.popstack(); let mut x = parser.popstack(); let mut _item0_ = parser.popstack();  parser.exstate.push(x.lbox()); Nothing };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* var */  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); 
  if let ((x),)=(_item0_.value,) {  x } /* const*/  else {parser.bad_pattern("((x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut _item3_ = parser.popstack(); let mut _item2_ = parser.popstack(); let mut a = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut ts),)=(_item2_.value,) { 
  if ts.len()<1 {return a.value;}
  let mut apterm = App(a.lbox(), ts.pop().unwrap());
  while ts.len()>0 {
    apterm = App(parser.lbx(0,apterm), ts.pop().unwrap());
  }
  apterm }  else {parser.bad_pattern("(Seq(mut ts),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item1_.value,) { 
  let mut t = b.value;
  while vs.len()>0 {
    t = Abs(getvar(&unbox!(vs.pop().unwrap())),parser.lbx(0,t));
  }
  return t; }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut b = parser.popstack(); let mut _item4_ = parser.popstack(); let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) {  App(parser.lbx(0,Abs(x,b.lbox())), v.lbox()) }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("T");
 rule.Ruleaction = |parser|{ let mut v = parser.popstack(); let mut _item2_ = parser.popstack(); let mut _item1_ = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Var(x),)=(_item1_.value,) { 
  let nv = Def(true,x,v.lbox());
  //parser.exstate.push(parser.lbx(0,nv));
  nv 
 }  else {parser.bad_pattern("(Var(x),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Moreargs");
 rule.Ruleaction = |parser|{  Seq(Vec::new()) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Moreargs");
 rule.Ruleaction = |parser|{ let mut ms = parser.popstack(); let mut b = parser.popstack(); 
  if let (Seq(ts),)=(&mut ms.value,) {  ts.push(b.lbox()); ms.value }  else {parser.bad_pattern("(Seq(ts),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut x = parser.popstack();  Seq(vec![x.lbox()]) };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("Vars");
 rule.Ruleaction = |parser|{ let mut y = parser.popstack(); let mut _item0_ = parser.popstack(); 
  if let (Seq(mut vs),)=(_item0_.value,) {  vs.push(y.lbox()); Seq(vs) }  else {parser.bad_pattern("(Seq(mut vs),)")} };
 parser1.Rules.push(rule);
 rule = ZCRProduction::<Term,Vec<LBox<Term>>>::new_skeleton("START");
 rule.Ruleaction = |parser|{ let mut _item0_ = parser.popstack(); <Term>::default()};
 parser1.Rules.push(rule);
 parser1.Errsym = "";

 for i in 0..154 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 for s in SYMBOLS { parser1.Symset.insert(s); }

 load_extras(&mut parser1);
 return parser1;
} //make_parser

fn load_extras(parser:&mut ZCParser<Term,Vec<LBox<Term>>>)
{
}//end of load_extras: don't change this line as it affects augmentation

//Parser generated by RustLr

#![allow(dead_code)]
#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_assignments)]
extern crate RustLr;
use RustLr::{Parser,RGrule,Stateaction};

pub fn make_parser() -> Parser<i64>
{
 let mut parser1:Parser<i64> = Parser::new(7,14);
 let mut rule = RGrule::<i64>::new_skeleton("start");
 rule = RGrule::<i64>::new_skeleton("E");
 rule.Ruleaction = |pstack|{ pstack.pop();  pstack.pop();  pstack.pop();   return i64::default();};
 parser1.Rules.push(rule);
 rule = RGrule::<i64>::new_skeleton("E");
 rule.Ruleaction = |pstack|{ pstack.pop();  pstack.pop();  pstack.pop();   return i64::default();};
 parser1.Rules.push(rule);
 rule = RGrule::<i64>::new_skeleton("E");
 rule.Ruleaction = |pstack|{ pstack.pop();  pstack.pop();  pstack.pop();   return i64::default();};
 parser1.Rules.push(rule);
 rule = RGrule::<i64>::new_skeleton("E");
 rule.Ruleaction = |pstack|{ pstack.pop();  pstack.pop();  pstack.pop();   return i64::default();};
 parser1.Rules.push(rule);
 rule = RGrule::<i64>::new_skeleton("T");
 rule.Ruleaction = |pstack|{ pstack.pop();   return i64::default();};
 parser1.Rules.push(rule);
 rule = RGrule::<i64>::new_skeleton("F");
 rule.Ruleaction = |pstack|{ pstack.pop();   return i64::default();};
 parser1.Rules.push(rule);
 rule = RGrule::<i64>::new_skeleton("START");
 rule.Ruleaction = |pstack|{ pstack.pop();   return i64::default();};
 parser1.Rules.push(rule);
 parser1.RSM[0].insert("E",Stateaction::Gotonext(3));
 parser1.RSM[0].insert("a",Stateaction::Shift(1));
 parser1.RSM[0].insert("b",Stateaction::Shift(2));
 parser1.RSM[1].insert("F",Stateaction::Gotonext(6));
 parser1.RSM[1].insert("T",Stateaction::Gotonext(4));
 parser1.RSM[1].insert("c",Stateaction::Shift(5));
 parser1.RSM[2].insert("c",Stateaction::Shift(8));
 parser1.RSM[2].insert("F",Stateaction::Gotonext(9));
 parser1.RSM[2].insert("T",Stateaction::Gotonext(7));
 parser1.RSM[3].insert("EOF",Stateaction::Accept);
 parser1.RSM[4].insert("d",Stateaction::Shift(10));
 parser1.RSM[5].insert("e",Stateaction::Reduce(5));
 parser1.RSM[5].insert("d",Stateaction::Reduce(4));
 parser1.RSM[6].insert("e",Stateaction::Shift(11));
 parser1.RSM[7].insert("e",Stateaction::Shift(12));
 parser1.RSM[8].insert("e",Stateaction::Reduce(4));
 parser1.RSM[8].insert("d",Stateaction::Reduce(5));
 parser1.RSM[9].insert("d",Stateaction::Shift(13));
 parser1.RSM[10].insert("EOF",Stateaction::Reduce(0));
 parser1.RSM[11].insert("EOF",Stateaction::Reduce(1));
 parser1.RSM[12].insert("EOF",Stateaction::Reduce(2));
 parser1.RSM[13].insert("EOF",Stateaction::Reduce(3));
 return parser1;
} //make_parser

//Parser generated by rustlr

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_assignments)]
extern crate rustlr;
use rustlr::{RuntimeParser,RProduction,decode_action};
use rustlr::{Lextoken,Lexer};
use std::io::{Write};

fn readln()-> String {
  let mut s = String::new();
  std::io::stdin().read_line(&mut s);
  s
}

struct Slex<'t> {
 split : std::str::SplitWhitespace<'t>,
}
impl<'t> Lexer<String> for Slex<'t> {
  fn nextsym(&mut self) -> Option<Lextoken<String>> {
    match self.split.next() {
     None => None,
     Some(sym) => Some(Lextoken::new(sym.trim().to_string(), sym.to_string())),
    }//match
  }//nextsym
  fn linenum(&self) -> usize {0}
}

fn main() {
   print!("Write something in C+- : ");
   std::io::stdout().flush().unwrap();
   let input = readln();
   let mut lexer1 =  Slex{split:input.split_whitespace()};
   let mut parser1 = make_parser();
   parser1.parse( &mut lexer1);
   println!("parsing success: {}",!parser1.error_occurred());
}//main

const SYMBOLS:[&'static str;17] = ["STAT","STATLIST","EXPR","EXPRLIST","x","y","z","cin","cout",";","(",")","<<",">>","ERROR","START","EOF"];

const TABLE:[u64;74] = [65537,30064967680,34360066048,4295098369,60129804288,281535106252802,281509336449026,281505041481730,281543696187394,562980018388992,563018672898051,562984313487360,562949953814529,563010083225600,844480765165568,1125938562072576,1407426423750656,1688884220067842,1688909989871618,1688918579806210,1688879925100546,1970342017695744,1970350607564800,1970346312531968,1970367787565056,1970333427564545,2251859943882754,2251829879111682,2251834174078978,2251868533817346,2533317740986368,2533283381313537,2533296265953280,2533287676346369,2533291971117056,2533300560986112,2814788422926336,3096263398850562,3096271988785154,3096276283752450,3377746965561346,3377751260528642,3377738375626754,3659226237108226,3659213352206338,3659221942140930,3940658265063425,3940675444539392,3940671149506560,3940692624539648,3940666854670336,4222163305889794,4222176190791682,4503651168288768,4503638283321344,4785143323688962,4785108963950594,4785104668983298,4785134733754370,5066596826808320,5348058917437442,5348084687241218,5348054622470146,5348093277175810,5629508125589505,5629521009770496,5629516714934272,5629542484803584,5629525304803328,5911013166088194,5911021756022786,5911026050990082,6192501027831810,6192488142929922,];

pub fn make_parser() -> RuntimeParser<String,String>
{
 let mut parser1:RuntimeParser<String,String> = RuntimeParser::new(12,23);
 let mut rule = RProduction::<String,String>::new_skeleton("start");
 rule = RProduction::<String,String>::new_skeleton("STATLIST");
 rule.Ruleaction = |parser|{ parser.stack.pop();   return String::default();};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("STATLIST");
 rule.Ruleaction = |parser|{ parser.stack.pop();  parser.stack.pop();   return String::default();};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("STAT");
 rule.Ruleaction = |parser|{ parser.stack.pop();  parser.stack.pop();  parser.stack.pop();  parser.stack.pop();  readln()};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("STAT");
 rule.Ruleaction = |parser|{ parser.stack.pop();   let mut s:String=parser.stack.pop().unwrap().value;  parser.stack.pop();  parser.stack.pop();  println!(": {}",&s); String::new()};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("EXPR");
 rule.Ruleaction = |parser|{ parser.stack.pop();  "x".to_string()};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("EXPR");
 rule.Ruleaction = |parser|{ parser.stack.pop();  "y".to_string()};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("EXPR");
 rule.Ruleaction = |parser|{ parser.stack.pop();  "z".to_string()};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("EXPR");
 rule.Ruleaction = |parser|{ parser.stack.pop();   let s:String=parser.stack.pop().unwrap().value;  parser.stack.pop();  s};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("EXPRLIST");
 rule.Ruleaction = |parser|{  let s:String=parser.stack.pop().unwrap().value;  s};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("EXPRLIST");
 rule.Ruleaction = |parser|{  let s:String=parser.stack.pop().unwrap().value;  parser.stack.pop();   let mut sl:String=parser.stack.pop().unwrap().value;   format!("{} {}",sl,s) };
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("STAT");
 rule.Ruleaction = |parser|{ parser.stack.pop();  parser.stack.pop();   parser.report("invalid statement, skipping to ;"); String::from("")};
 parser1.Rules.push(rule);
 rule = RProduction::<String,String>::new_skeleton("START");
 rule.Ruleaction = |parser|{ parser.stack.pop();   return String::default();};
 parser1.Rules.push(rule);
 parser1.Errsym = "";
 parser1.resynch.insert(")");
 parser1.resynch.insert(";");

 for i in 0..74 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 return parser1;
} //make_parser

//Parser generated by rustlr

#![allow(unused_variables)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]
#![allow(unused_mut)]
#![allow(unused_assignments)]
extern crate rustlr;
use rustlr::{RuntimeParser,RProduction,decode_action};
use crate::exprtrees::*;
use crate::exprtrees::Expr::*;

const SYMBOLS:[&'static str;9] = ["E","+","-","*","(",")","int","START","EOF"];

const TABLE:[u64;104] = [8590065664,65537,17180065792,25770065920,281509336449027,281483566972928,281479272136704,281487862005760,562958543486976,562949953945601,562975723487232,562967133487104,844424930721793,844450700591104,844442110722048,844433520852992,1125934266580994,1125912791744514,1125908496777218,1125904201809922,1407400653619200,1407383473618944,1407392063619072,1407374884405249,1688867040329728,1688875630329856,1688849861181441,1688858450329600,1970333427040256,1970342017040384,1970324837957633,1970350607040512,2251808403881986,2251812698980352,2251804108914690,2251834173685762,2533283381510144,2533296266280960,2533287676542976,2533279086477312,2814754062073858,2814771241943042,2814762652008450,2814758357041154,3096250514276352,3096233334538240,3096224745127937,3096241924407296,3377725490987008,3377699721904129,3377716901117952,3377708311248896,3659178992336898,3659183287304194,3659187582533632,3659209057107970,3940684033884162,3940662559047682,3940653969113090,3940658264080386,4222128945692674,4222159010463746,4222133240659970,4222137535954944,4503608217632770,4503633987436546,4503603922665474,4503612512600066,4785091784671232,4785074605522945,4785083194802176,4785100374540288,5066549582299137,5066558171512832,5066566761381888,5066575351250944,5348050327961600,5348024559075329,5348041738092544,5348033148223488,5629508125327360,5629521010688000,5629512420360192,5629503830294528,5910978806153218,5910983101120514,5910995986022402,5910987397070848,6192470962536450,6192458077634562,6192462373781504,6192453782667266,6473928759443458,6473937350492160,6473933054410754,6473945939312642,6755420916088834,6755408031186946,6755403736219650,6755412326154242,7036887302995970,7036895892930562,7036883008028674,7036878713061378,];

pub fn make_parser() -> RuntimeParser<Expr,Expr>
{
 let mut parser1:RuntimeParser<Expr,Expr> = RuntimeParser::new(7,26);
 let mut rule = RProduction::<Expr,Expr>::new_skeleton("start");
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let n:Expr=parser.stack.pop().unwrap().value;   n };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e2:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   let e1:Expr=parser.stack.pop().unwrap().value;   Plus(bx(e1),bx(e2)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e2:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   let e1:Expr=parser.stack.pop().unwrap().value;   Minus(bx(e1),bx(e2)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e2:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   let e1:Expr=parser.stack.pop().unwrap().value;   Times(bx(e1),bx(e2)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{  let e:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   Negative(bx(e)) };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("E");
 rule.Ruleaction = |parser|{ parser.stack.pop();   let e:Expr=parser.stack.pop().unwrap().value;  parser.stack.pop();   e };
 parser1.Rules.push(rule);
 rule = RProduction::<Expr,Expr>::new_skeleton("START");
 rule.Ruleaction = |parser|{ parser.stack.pop();   return Expr::default();};
 parser1.Rules.push(rule);
 parser1.Errsym = "";

 for i in 0..104 {
   let symi = ((TABLE[i] & 0x0000ffff00000000) >> 32) as usize;
   let sti = ((TABLE[i] & 0xffff000000000000) >> 48) as usize;
   parser1.RSM[sti].insert(SYMBOLS[symi],decode_action(TABLE[i]));
 }

 return parser1;
} //make_parser
